{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/Indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/avatar3.jpg","path":"img/avatar3.jpg","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/avatar4.jpg","path":"img/avatar4.jpg","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/Indigo/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/Indigo/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/Indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/Indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Indigo/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"1d658509dc93c1ec5ebebf144cfed6ecfdc58e6d","modified":1552454055621},{"_id":"source/CNAME","hash":"b1c3fdc1326c140841ad67dfe75629d49198c2e2","modified":1545117128125},{"_id":"themes/Indigo/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1551924749624},{"_id":"themes/Indigo/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1551924749624},{"_id":"themes/Indigo/README.md","hash":"4bf26d9b43bf24b8e0a1a0d058437a347972f5e6","modified":1551924749624},{"_id":"themes/Indigo/.DS_Store","hash":"d293e7191a06d7e2bce92ff5964173de3ee64529","modified":1551927097936},{"_id":"themes/Indigo/_config.yml","hash":"f3b16d6b7e7a6b8c91dff1b91a787a38867ea775","modified":1551927006851},{"_id":"themes/Indigo/package.json","hash":"c795e3100ae3655bfa8b39adcca7333a7925b47f","modified":1551924749639},{"_id":"source/404/index.md","hash":"5635402f6c20e3b1c083cf02921313a3696c4f28","modified":1551404990255},{"_id":"source/_posts/HandlerMessagequeueLooper-1551427172528.md","hash":"22faa4905eafef816b8b3e704e5d864c522b5b93","modified":1552037140081},{"_id":"source/_posts/JVMModel-1552035735257.md","hash":"a12fade87cb7045edd35431fd4b989590235de7a","modified":1552037210837},{"_id":"source/_posts/AsyncTask20190228155539.md","hash":"359c03041de5d94438f9d0ee535e2e97f13cf012","modified":1552037082266},{"_id":"source/_posts/ThradLocalCodeRead1551409309746.md","hash":"ad74a7f8db2c4608668276f8152895f182467a6a","modified":1552037155534},{"_id":"source/_posts/activitystartstep-1551942246673.md","hash":"134c5ae69876568cbda83516eaa8bc7457fd27bf","modified":1552037189286},{"_id":"source/about/index.md","hash":"a5569554529f35e193694461bbaeaf32dddfef38","modified":1551404946597},{"_id":"source/categories/index.md","hash":"abeba8b90154ef707abd7d32a4fe1f543bf7740a","modified":1551925081650},{"_id":"source/categories/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1551925095032},{"_id":"source/_posts/hello-world.md","hash":"905f569d73cb9ed5eec7ee43f7aa1fa72dcb95e2","modified":1551340462337},{"_id":"source/home/index.md","hash":"c21f221af7f1f60d2c2e005f681385d639a5f30e","modified":1551410159093},{"_id":"source/tags/.DS_Store","hash":"64dc80f95f42dbf12ce9ef6d86358c25c2d86d25","modified":1551925109620},{"_id":"source/tags/index-1.md","hash":"1b397f76f988279974163cdfba6a9dde66cf5f6c","modified":1552037024547},{"_id":"source/tags/index.md","hash":"a14c7c2b4135e8164a3cf018091d9da326925f66","modified":1551925101348},{"_id":"themes/Indigo/.git/HEAD","hash":"da237e0de55301608e7c572e119ab5c4e43c0e85","modified":1551924749619},{"_id":"themes/Indigo/.git/config","hash":"1096da7405bf0751ed8d5e91f24910015fb6928f","modified":1551924749621},{"_id":"themes/Indigo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1551924690580},{"_id":"themes/Indigo/.git/index","hash":"5f1f2c405cb798884f1c7f68673c6a3f0df763a2","modified":1551924749683},{"_id":"themes/Indigo/.git/packed-refs","hash":"c7ffafcc8cd05341c3adc76b1ede3a50249d7cef","modified":1551924749617},{"_id":"themes/Indigo/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1551924749624},{"_id":"themes/Indigo/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1551924749625},{"_id":"themes/Indigo/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1551924749625},{"_id":"themes/Indigo/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1551924749625},{"_id":"themes/Indigo/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1551924749625},{"_id":"themes/Indigo/layout/.DS_Store","hash":"be17bf9e1fdb19bbe9f7f8ec1cbc6172c89dfc81","modified":1551927097939},{"_id":"themes/Indigo/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1551924749636},{"_id":"themes/Indigo/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1551924749637},{"_id":"themes/Indigo/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1551924749636},{"_id":"themes/Indigo/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1551924749637},{"_id":"themes/Indigo/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1551924749637},{"_id":"themes/Indigo/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1551924749638},{"_id":"themes/Indigo/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1551924749638},{"_id":"themes/Indigo/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1551924749638},{"_id":"themes/Indigo/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1551924749639},{"_id":"themes/Indigo/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1551924749639},{"_id":"themes/Indigo/source/.DS_Store","hash":"5742c40d3f8a0840bb835356e5356a6876cd8d4c","modified":1551926509248},{"_id":"themes/Indigo/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1551924690580},{"_id":"themes/Indigo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1551924690583},{"_id":"themes/Indigo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1551924690581},{"_id":"themes/Indigo/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1551924690583},{"_id":"themes/Indigo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1551924690584},{"_id":"themes/Indigo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1551924690584},{"_id":"themes/Indigo/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1551924690582},{"_id":"themes/Indigo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1551924690585},{"_id":"themes/Indigo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1551924690583},{"_id":"themes/Indigo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1551924690581},{"_id":"themes/Indigo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1551924690585},{"_id":"themes/Indigo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1551924690584},{"_id":"themes/Indigo/.git/logs/HEAD","hash":"c9e3f08086ec5b036014bb41a8d9f21c0e0676ed","modified":1551924749620},{"_id":"themes/Indigo/layout/_partial/.DS_Store","hash":"55fee4304dde76dd938a1ed6022fcb02caf9da14","modified":1551927097941},{"_id":"themes/Indigo/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1551924749626},{"_id":"themes/Indigo/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1551924749626},{"_id":"themes/Indigo/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1551924749626},{"_id":"themes/Indigo/layout/_partial/head.ejs","hash":"02a95a88774cc50dbcc32242b6c8ac7e9d9028bb","modified":1551924749626},{"_id":"themes/Indigo/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1551924749626},{"_id":"themes/Indigo/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1551924749627},{"_id":"themes/Indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1551924749627},{"_id":"themes/Indigo/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1551924749628},{"_id":"themes/Indigo/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1551924749627},{"_id":"themes/Indigo/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1551924749631},{"_id":"themes/Indigo/layout/_partial/script.ejs","hash":"7e06d1c3ecf964a0a31e811d2c4935e084c6ad5c","modified":1551924749635},{"_id":"themes/Indigo/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1551924749635},{"_id":"themes/Indigo/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1551924749636},{"_id":"themes/Indigo/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1551924749678},{"_id":"themes/Indigo/source/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1551924749679},{"_id":"themes/Indigo/source/img/avatar.jpg","hash":"08f3e8eb52ef50080c8113fd020462c312134b88","modified":1551925528483},{"_id":"themes/Indigo/source/img/.DS_Store","hash":"5e2a0f2ba98c5e9b3d54f1b6eaa053ba32c9fa2c","modified":1551925628723},{"_id":"themes/Indigo/source/img/avatar3.jpg","hash":"99138adc19cb61c9720f475b6f76e96ca4230bbe","modified":1551925539820},{"_id":"themes/Indigo/source/img/avatar4.jpg","hash":"d3f90ec08a00f2111bb5c9e671694b6f1a1a875c","modified":1551925519216},{"_id":"themes/Indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1551924749680},{"_id":"themes/Indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1551924749679},{"_id":"themes/Indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1551924749680},{"_id":"themes/Indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1551924749680},{"_id":"themes/Indigo/source/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1551924749681},{"_id":"themes/Indigo/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1551924749682},{"_id":"themes/Indigo/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1551924749682},{"_id":"themes/Indigo/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1551924749681},{"_id":"themes/Indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1551924749683},{"_id":"themes/Indigo/.git/refs/heads/card","hash":"215cf3cc5ee9a6265fb8b0259977357fe8d4fdd0","modified":1551924749620},{"_id":"themes/Indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1551924749631},{"_id":"themes/Indigo/layout/_partial/post/comment.ejs","hash":"21530a1bc362d286d08dbce0baf37d09d7c58c92","modified":1551924749631},{"_id":"themes/Indigo/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1551924749632},{"_id":"themes/Indigo/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1551924749632},{"_id":"themes/Indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1551924749632},{"_id":"themes/Indigo/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1551924749633},{"_id":"themes/Indigo/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1551924749632},{"_id":"themes/Indigo/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1551924749632},{"_id":"themes/Indigo/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1551924749633},{"_id":"themes/Indigo/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1551924749634},{"_id":"themes/Indigo/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1551924749634},{"_id":"themes/Indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1551924749634},{"_id":"themes/Indigo/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1551924749635},{"_id":"themes/Indigo/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1551924749635},{"_id":"themes/Indigo/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1551924749628},{"_id":"themes/Indigo/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1551924749628},{"_id":"themes/Indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1551924749629},{"_id":"themes/Indigo/layout/_partial/plugins/gitalk.ejs","hash":"bcf792a5633151fd999319fd91cf477e6860ae9c","modified":1551924749629},{"_id":"themes/Indigo/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1551924749629},{"_id":"themes/Indigo/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1551924749629},{"_id":"themes/Indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"e5a83acc7c2e385b0c9abf428e86e8fdfd3a5202","modified":1551924749629},{"_id":"themes/Indigo/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1551924749630},{"_id":"themes/Indigo/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1551924749630},{"_id":"themes/Indigo/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1551924749630},{"_id":"themes/Indigo/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1551924749630},{"_id":"themes/Indigo/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1551924749630},{"_id":"themes/Indigo/layout/_partial/plugins/valine.ejs","hash":"a976ca36bd09aeb2902bf94fcc7a59975ea25148","modified":1551924749631},{"_id":"themes/Indigo/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1551924749640},{"_id":"themes/Indigo/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1551924749640},{"_id":"themes/Indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1551924749641},{"_id":"themes/Indigo/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1551924749642},{"_id":"themes/Indigo/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1551924749642},{"_id":"themes/Indigo/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1551924749642},{"_id":"themes/Indigo/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1551924749643},{"_id":"themes/Indigo/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1551924749643},{"_id":"themes/Indigo/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1551924749643},{"_id":"themes/Indigo/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1551924749644},{"_id":"themes/Indigo/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1551924749644},{"_id":"themes/Indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1551924749644},{"_id":"themes/Indigo/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1551924749645},{"_id":"themes/Indigo/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1551924749645},{"_id":"themes/Indigo/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1551924749645},{"_id":"themes/Indigo/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1551924749645},{"_id":"themes/Indigo/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1551924749646},{"_id":"themes/Indigo/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1551924749646},{"_id":"themes/Indigo/.git/objects/pack/pack-b3df9caa2fa7400388c221d55e996c7493b79212.idx","hash":"76f592d42e91f0b9e434b91e18de6973bece426b","modified":1551924749260},{"_id":"themes/Indigo/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1551924749641},{"_id":"themes/Indigo/.git/logs/refs/heads/card","hash":"c9e3f08086ec5b036014bb41a8d9f21c0e0676ed","modified":1551924749620},{"_id":"themes/Indigo/.git/refs/remotes/origin/HEAD","hash":"7f141be72288af81f8e55d94df5da3f87101e8f1","modified":1551924749619},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1551924749662},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1551924749665},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1551924749665},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1551924749668},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1551924749668},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1551924749672},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1551924749671},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1551924749674},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1551924749675},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1551924749674},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1551924749678},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1551924749677},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1551924749664},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1551924749660},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551924749661},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1551924749667},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1551924749666},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1551924749671},{"_id":"themes/Indigo/.git/logs/refs/remotes/origin/HEAD","hash":"c9e3f08086ec5b036014bb41a8d9f21c0e0676ed","modified":1551924749619},{"_id":"themes/Indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1551924749650},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551924749653},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1551924749660},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1551924749663},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1551924749670},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1551924749676},{"_id":"themes/Indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1551924749673},{"_id":"themes/Indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1551924749657},{"_id":"themes/Indigo/.git/objects/pack/pack-b3df9caa2fa7400388c221d55e996c7493b79212.pack","hash":"436946071396f1f0ec59fdfad57ed859a917796a","modified":1551924749259},{"_id":"public/atom.xml","hash":"de08c24546ee550b20dc0cad7e65cdc09744446e","modified":1552480975643},{"_id":"public/content.json","hash":"515b2d4f10b60ab21e6c03c5bb0ba9aff7218287","modified":1552480975643},{"_id":"public/404/index.html","hash":"eeb4b18178196170b7c71552b79c4e2e0b462eff","modified":1552273047200},{"_id":"public/about/index.html","hash":"a0be64323644714a3a8d6f1375567700652b99b1","modified":1552273047323},{"_id":"public/home/index.html","hash":"560be5f59d95611b65b94fdac308df955c40ce26","modified":1552273047200},{"_id":"public/2018/12/18/hello-world/index.html","hash":"68c5e97787c09a0ab0cb86b2320398806d59e837","modified":1552273047325},{"_id":"public/archives/2018/index.html","hash":"788ea138c77f5ad56c3a60e21f0f547186db0f42","modified":1552273047325},{"_id":"public/archives/2018/12/index.html","hash":"51467fc4b13a71afa8535bca850487d63469c001","modified":1552273047325},{"_id":"public/archives/2019/index.html","hash":"e3b4164bab771e9f5687398dfc20c22a3cd4acc1","modified":1552480976654},{"_id":"public/archives/2019/02/index.html","hash":"fada6c30e4be6abfbc304ef9823145e4f9e05448","modified":1552273047325},{"_id":"public/archives/2019/03/index.html","hash":"4475964c0a23aa1eace2acf91e9d6cc7cdf06df5","modified":1552480976725},{"_id":"public/categories/index.html","hash":"a88bfb66d3990809b04f945f2951b22610d86f99","modified":1552480976376},{"_id":"public/tags/index.html","hash":"8882caaf9c3630aaf9b3692f7c101beb17f1e81d","modified":1552480976376},{"_id":"public/2019/03/08/JVMModel-1552035735257/index.html","hash":"c40acdb871b9688253e0b1633fc5a1e58e63b86d","modified":1552273047326},{"_id":"public/2019/03/07/activitystartstep-1551942246673/index.html","hash":"1d8373ac32505a707ea5530786e07500118b9671","modified":1552273047326},{"_id":"public/2019/03/01/HandlerMessagequeueLooper-1551427172528/index.html","hash":"ded1c6ec4c7a75f1ce3af0e893d35594dc70e82a","modified":1552273047326},{"_id":"public/2019/03/01/ThradLocalCodeRead1551409309746/index.html","hash":"9dc2465593e9ef3f93031fa7f5bb3291bd41c8d8","modified":1552273047326},{"_id":"public/2019/02/28/AsyncTask20190228155539/index.html","hash":"75898f2a6cf945f45d802f13c929602cfe381776","modified":1552273047326},{"_id":"public/archives/index.html","hash":"ae4c8f42f8b721a0d727165bc18077fcce1fac2a","modified":1552480976652},{"_id":"public/index.html","hash":"9ba41652c11cfb1a5c2645d0868e4924650d1831","modified":1552480976725},{"_id":"public/tags/index-1.html","hash":"27227ec6ec81e2c553332147141b8ece0818931a","modified":1552273047324},{"_id":"public/categories/Java/index.html","hash":"cae22e62806729c997fd220aa4376eb1e081e514","modified":1552273047326},{"_id":"public/categories/Android/index.html","hash":"716925d305f845100603422e9dc2db0cff038359","modified":1552480976684},{"_id":"public/tags/JVM内存结构/index.html","hash":"8d067df7231c1a622826518ef5f5d09b28d2530a","modified":1552480976684},{"_id":"public/tags/Java内存模型/index.html","hash":"580b93793dd2950f0e2fa93e2f98f236808ba6df","modified":1552480976722},{"_id":"public/tags/Java对象模型/index.html","hash":"fd683268126941813bc883f9a11d30dfdda164fb","modified":1552480976724},{"_id":"public/tags/AsyncTask/index.html","hash":"a224507e78dfe6f0e1d270602499127791febb5e","modified":1552480976722},{"_id":"public/tags/ThreadLocal/index.html","hash":"00c2ffa1c750a30cbdc5257c11afcac940e45176","modified":1552480976723},{"_id":"public/tags/Handler/index.html","hash":"b7b0ce09f46497d4a6187844b28cacf8dd8c1255","modified":1552480976724},{"_id":"public/tags/MessageQueue/index.html","hash":"689686afc2e397a33ee8546fedbdf66d57e9c290","modified":1552480976723},{"_id":"public/tags/Looper/index.html","hash":"8dfd5edd6e2733a666613d855be3c7746759d70b","modified":1552480976724},{"_id":"public/tags/Android-消息机制/index.html","hash":"32e8127fc66f0ce32acbe1ad47f5e105844ee128","modified":1552480976724},{"_id":"public/tags/Activity-启动流程分析/index.html","hash":"04d9d9a6a8f1c1d6479a5a69a89933e58b9b8ef0","modified":1552480976724},{"_id":"public/CNAME","hash":"b1c3fdc1326c140841ad67dfe75629d49198c2e2","modified":1552037221335},{"_id":"public/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1552037221335},{"_id":"public/img/avatar.jpg","hash":"08f3e8eb52ef50080c8113fd020462c312134b88","modified":1552037221335},{"_id":"public/img/avatar3.jpg","hash":"99138adc19cb61c9720f475b6f76e96ca4230bbe","modified":1552037221335},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1552037221335},{"_id":"public/img/avatar4.jpg","hash":"d3f90ec08a00f2111bb5c9e671694b6f1a1a875c","modified":1552037221336},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1552037221336},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1552037221336},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1552037221336},{"_id":"public/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1552037221336},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1552037221337},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1552037221337},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1552037221337},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1552037221337},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1552037221337},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1552037221337},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1552037221337},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1552037221366},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1552037221366},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1552037221366},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1552037221366},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1552037221366},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1552037221366},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1552037221366},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1552037221371},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1552037221371},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1552037221371},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1552037221373},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1552037221374},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1552037221378},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1552037221432},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1552037221446},{"_id":"public/css/style.css","hash":"4f59712181405c963fe7e80740071022050bc096","modified":1552037221793},{"_id":"source/_posts/WhyhasJMMexit-1552272874543.md","hash":"336761e117d2ef44cc2c53d639d78264212dc00b","modified":1552273015056},{"_id":"public/2019/03/11/WhyhasJMMexit-1552272874543/index.html","hash":"b2ec075318e880ed35ed4af0837ab7dbb7b97765","modified":1552480976651},{"_id":"source/_posts/DecorViewAndViewRootImpl-1552480772465.md","hash":"e71acbd2c58d3efaee999c16909074d58dcc1ca0","modified":1552480958180},{"_id":"public/2019/03/13/DecorViewAndViewRootImpl-1552480772465/index.html","hash":"8884f7c715b632eb3c437b0c9cfa15ee363c0ceb","modified":1552480976725},{"_id":"public/tags/Android源码解析/index.html","hash":"e026fb79e763ade4998efae77e8b11ec2223e72c","modified":1552480976727},{"_id":"public/tags/DecorView/index.html","hash":"a119961a1de0e28f6501c19bf3fb7fb90edba9c8","modified":1552480976727},{"_id":"public/tags/ViewRootImpl/index.html","hash":"fb53dc35b9818ef32b6c409c28334b6b3840f06c","modified":1552480976727}],"Category":[{"name":"Java","_id":"cjszuvyt70009qk9yzkadowvp"},{"name":"Android","_id":"cjszuvyte000bqk9ytb3ifh0w"}],"Data":[],"Page":[{"title":"404","date":"2019-03-01T01:49:50.000Z","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2019-03-01 09:49:50\n---\n","updated":"2019-03-01T01:49:50.255Z","path":"404/index.html","comments":1,"layout":"page","_id":"cjszuvys90000qk9y9220lxsh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2019-03-01T01:49:06.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-03-01 09:49:06\n---\n","updated":"2019-03-01T01:49:06.597Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjszuvysg0002qk9y9zkg5x60","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"categories","comments":0,"_content":"title: categories\ndate: 2019-03-07 10:16:23\n---\n","source":"categories/index.md","raw":"layout: categories\ncomments: false\n---\ntitle: categories\ndate: 2019-03-07 10:16:23\n---\n","date":"2019-03-07T02:18:01.655Z","updated":"2019-03-07T02:18:01.650Z","path":"categories/index.html","title":"","_id":"cjszuvysi0003qk9yvvdh9unx","content":"<p>title: categories</p>\n<h2 id=\"date-2019-03-07-10-16-23\"><a href=\"#date-2019-03-07-10-16-23\" class=\"headerlink\" title=\"date: 2019-03-07 10:16:23\"></a>date: 2019-03-07 10:16:23</h2>","site":{"data":{}},"excerpt":"","more":"<p>title: categories</p>\n<h2 id=\"date-2019-03-07-10-16-23\"><a href=\"#date-2019-03-07-10-16-23\" class=\"headerlink\" title=\"date: 2019-03-07 10:16:23\"></a>date: 2019-03-07 10:16:23</h2>"},{"title":"home","date":"2019-03-01T03:15:59.000Z","_content":"","source":"home/index.md","raw":"---\ntitle: home\ndate: 2019-03-01 11:15:59\n---\n","updated":"2019-03-01T03:15:59.093Z","path":"home/index.html","comments":1,"layout":"page","_id":"cjszuvysi0004qk9y7txa1wxf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-03-08T09:23:44.000Z","_content":"","source":"tags/index-1.md","raw":"---\ntitle: tags\ndate: 2019-03-08 17:23:44\n---\n","updated":"2019-03-08T09:23:44.547Z","path":"tags/index-1.html","comments":1,"layout":"page","_id":"cjszuvysj0005qk9y33zfwh04","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","comments":0,"_content":"title: tags\ndate: 2019-03-01 09:48:50\n---\n","source":"tags/index.md","raw":"layout: tags\ncomments: false\n---\ntitle: tags\ndate: 2019-03-01 09:48:50\n---\n","date":"2019-03-08T09:24:06.639Z","updated":"2019-03-07T02:18:21.348Z","path":"tags/index.html","title":"","_id":"cjszuvysk0006qk9yg0l4ydd1","content":"<p>title: tags</p>\n<h2 id=\"date-2019-03-01-09-48-50\"><a href=\"#date-2019-03-01-09-48-50\" class=\"headerlink\" title=\"date: 2019-03-01 09:48:50\"></a>date: 2019-03-01 09:48:50</h2>","site":{"data":{}},"excerpt":"","more":"<p>title: tags</p>\n<h2 id=\"date-2019-03-01-09-48-50\"><a href=\"#date-2019-03-01-09-48-50\" class=\"headerlink\" title=\"date: 2019-03-01 09:48:50\"></a>date: 2019-03-01 09:48:50</h2>"}],"Post":[{"title":"Hello World","date":"2018-12-18T01:59:04.000Z","_content":"\n换硬盘博客都丢了,就从头再来吧!","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags: []\ncategories: []\ndate: 2018-12-18 09:59:04\n---\n\n换硬盘博客都丢了,就从头再来吧!","slug":"hello-world","published":1,"updated":"2019-02-28T07:54:22.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszuvysb0001qk9yd30yz3kr","content":"<p>换硬盘博客都丢了,就从头再来吧!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>换硬盘博客都丢了,就从头再来吧!</p>\n"},{"title":"JVM内存结构、 Java内存模型 以及 Java对象模型","date":"2019-03-08T09:02:15.000Z","_content":"\n# JVM内存结构、 Java内存模型 以及 Java对象模型\n\nJVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。\n\n可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。\n\n## 一、JVM内存结构\n\n\n我们都知道，Java代码是要运行在虚拟机上的，\n**Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故Java运行时内存结构，也就是指Java虚拟机的运行时内存结构。**而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在[《Java虚拟机规范（Java SE 8）》](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)中描述了JVM运行时内存区域结构如下：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vfh1rwz7j30m90dr3za.jpg)\n### 1.JVM简介\n#### 1.1线程私有区：\n这部分是线程独享\n\n**程序计数器：**记录正在执行的虚拟机字节码的地址,行号；\n**虚拟机栈：**方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；\n**本地方法栈：**虚拟机的`Native`方法执行的内存区；\n#### 1.2线程共享区：\n\n**Java堆：**对象分配内存的区域；\n**方法区：**存放类信息、常量、静态变量、编译器编译后的代码等数据；\n**常量池：**存放编译器生成的各种字面量和符号引用，是方法区的一部分。\n\n对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。\n\n### 2. JVM结构详解\n运行时内存分为五大块区域（常量池属于方法区，算作一块区域），前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java内存总体结构图如下：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vfplp5bxj30m70bwwfw.jpg)\n#### 2.1 程序计数器PC\n程序计数器PC，**当前线程**所执行的字节码行号指示器。**每个线程都有自己计数器**，是私有内存空间，该区域是整个内存中较小的一块。\n\n**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**\n\n当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；**当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）**。\n\n\n从上面的介绍中我们知道程序计数器主要有两个作用：\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n**注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**\n\n\n#### 2.2 虚拟机栈\n\n与程序计数器一样，**Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型**。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。\n\n虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)**执行的同时都会创建一个栈帧结构**，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。\n\n##### 2.2.1 栈帧(Stack Frame)结构\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhnbzfssj30gs0hiaau.jpg)\n\n**栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机栈的栈元素**。见上图， 栈帧包括：\n\n1. 局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位,局部变量表存放了编译期可知的各种**基本数据类型**`(boolean、byte、char、short、int、float、long、double)`,`String`引用类型，对象引用(`reference`类型)和`returnAddress`类型（它指向了一条字节码指令的地址） ,局部变量存储在局部变量表中，随着线程而生，线程而灭。并且线程间数据不共享。\n2. 操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配\n\n3. 动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。\n  1. 前面的解析过程其实是静态解析；\n  2. 对于运行期转化为直接引用，称为动态解析。\n4. 方法返回地址\n  1. 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者\n  2. 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。\n5. 额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。\n\n栈帧工作流程:\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhzrutg4j30g40afwjb.jpg)\n\n当Java应用程序调用函数调用时，会在调用堆栈上分配**栈帧**。**栈帧**包含调用**方法的参数**，其本地参数以及**方法的返回地址**。返回地址表示执行点，程序执行将在调用方法返回后继续执行。如果没有新栈帧的空间，则由Java虚拟机（JVM）抛出StackOverflowError。\n\n可能耗尽Java应用程序堆栈的最常见情况是递归。在递归中，方法在执行期间调用自身。递归被认为是一种强大的通用编程技术，但必须谨慎使用，以避免StackOverflowError。\n\n示例StackOverflowError：\n\nStackOverflowErrorExample.java：\n```java\npublic class StackOverflowErrorExample {\n\n    public static void recursivePrint(int num) {\n        System.out.println(\"Number: \" + num);\n\n        if(num == 0)\n            return;\n        else\n            recursivePrint(++num);\n    }\n\n    public static void main(String[] args) {\n        StackOverflowErrorExample.recursivePrint(1);\n    }\n}\n```\n在这个例子中，我们定义了一个递归方法，调用`recursivePrint`它打印一个整数，然后调用自身，下一个连续的整数作为参数。\n\n使用-Xss1M指定线程堆栈大小等于1MB 的标志的示例执行如下所示：\n\n\n```JAVA\nNumber: 1\nNumber: 2\nNumber: 3\n...\nNumber: 6262\nNumber: 6263\nNumber: 6264\nNumber: 6265\nNumber: 6266\nException in thread \"main\" java.lang.StackOverflowError\n        at java.io.PrintStream.write(PrintStream.java:480)\n        at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)\n        at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)\n        at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)\n        at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)\n        at java.io.PrintStream.write(PrintStream.java:527)\n        at java.io.PrintStream.print(PrintStream.java:669)\n        at java.io.PrintStream.println(PrintStream.java:806)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:4)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9)\n```\n\n\n\n\n\n##### 2.2.2 异常(Exception)\n\nJava虚拟机规范规定该区域有两种异常：\n\n**StackOverFlowError：**当线程请求栈深度超出虚拟机栈所允许的深度时抛出\n**OutOfMemoryError：**当Java虚拟机动态扩展到无法申请足够内存时抛出\n#### 2.3 本地方法栈\n本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。\n\n**异常(Exception)：**Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。\n\n### 2.4 Java堆\nJava堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。\n\n从内存回收角度，Java堆被分为**新生代和老年代**；这样划分的好处是为了更快的回收内存；\n从内存分配角度，Java堆可以划分出线程私有的分配**缓冲区(Thread Local Allocation Buffer,TLAB)**；这样划分的好处是为了更快的分配内存；\n对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhquz4ngj30kv0aqq3g.jpg)\n\n对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。\n\n另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存.\n\n**异常(Exception)：**Java虚拟机规范规定该区域可抛出**OutOfMemoryError**。\n\n\n#### 2.5 方法区\n1. 方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n2. Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。 \n这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。\n\n3. **很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。**\n\n4. 运行时常量池(Runtime Constant Pool)是方法区的一部分。\n\n> JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。\n\n异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。\n\n#### 2.6 运行时常量池\n运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。\n\n**字面量：**与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。\n**符号引用：**编译语言层面的概念，包括以下3类：\n* 类和接口的全限定名\n* 字段的名称和描述符\n* 方法的名称和描述符\n但是该区域不会抛出**OutOfMemoryError**异常。\n\n\n\n### 3. JVM总结\n\n一张图总结一下JVM\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhv2qwdfj30xa100whk.jpg)\n\n## Java内存模型\n\n**Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所问。**\n\n在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“**Java的线程间通过共享内存进行通信**”。\n\nJava内存模型是根据英文**Java Memory Model（JMM）**翻译过来的。**其实JMM并不像JVM内存结构一样是真实存在的,他只是一个抽象的概念**。[JSR-133: Java Memory Model and Thread Specification](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf)中描述了，**JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。**\n\n那么，简单总结下，**Java的多线程之间是通过共享内存进行通信的**，而由于采用共享内存进行通信，在通信过程中会存在一系列如**可见性、原子性、顺序性**等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。**JMM定义了一些语法集，这些语法集映射到Java语言中就是`volatile`、\n```synchronized```等关键字。**\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg)\n\n在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。\n\n## Java对象模型\n\nJava是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。\n\n`HotSpot`虚拟机中，设计了一个`OOP-Klass Model`。\n```OOP（Ordinary Object Pointer）```指的是普通对象指针，而Klass用来描述对象实例的具体类型。\n\n每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个\n```instanceKlass```，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个`instanceOopDesc`对象，这个对象中包含了对象头以及实例数据。\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vi3zdxbxj31840jsn8r.jpg)\n\n这就是一个简单的Java对象的`OOP-Klass`模型，即Java对象模型\n\n## 总结\n我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。\n\nJVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。\n\n","source":"_posts/JVMModel-1552035735257.md","raw":"---\ntitle: JVM内存结构、 Java内存模型 以及 Java对象模型\ntags: [JVM内存结构,Java内存模型,Java对象模型]\ncategories: [Java]\ndate: 2019-03-08 17:02:15\n---\n\n# JVM内存结构、 Java内存模型 以及 Java对象模型\n\nJVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。\n\n可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。\n\n## 一、JVM内存结构\n\n\n我们都知道，Java代码是要运行在虚拟机上的，\n**Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故Java运行时内存结构，也就是指Java虚拟机的运行时内存结构。**而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在[《Java虚拟机规范（Java SE 8）》](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)中描述了JVM运行时内存区域结构如下：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vfh1rwz7j30m90dr3za.jpg)\n### 1.JVM简介\n#### 1.1线程私有区：\n这部分是线程独享\n\n**程序计数器：**记录正在执行的虚拟机字节码的地址,行号；\n**虚拟机栈：**方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；\n**本地方法栈：**虚拟机的`Native`方法执行的内存区；\n#### 1.2线程共享区：\n\n**Java堆：**对象分配内存的区域；\n**方法区：**存放类信息、常量、静态变量、编译器编译后的代码等数据；\n**常量池：**存放编译器生成的各种字面量和符号引用，是方法区的一部分。\n\n对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。\n\n### 2. JVM结构详解\n运行时内存分为五大块区域（常量池属于方法区，算作一块区域），前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java内存总体结构图如下：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vfplp5bxj30m70bwwfw.jpg)\n#### 2.1 程序计数器PC\n程序计数器PC，**当前线程**所执行的字节码行号指示器。**每个线程都有自己计数器**，是私有内存空间，该区域是整个内存中较小的一块。\n\n**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**\n\n当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；**当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）**。\n\n\n从上面的介绍中我们知道程序计数器主要有两个作用：\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n**注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**\n\n\n#### 2.2 虚拟机栈\n\n与程序计数器一样，**Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型**。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。\n\n虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)**执行的同时都会创建一个栈帧结构**，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。\n\n##### 2.2.1 栈帧(Stack Frame)结构\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhnbzfssj30gs0hiaau.jpg)\n\n**栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机栈的栈元素**。见上图， 栈帧包括：\n\n1. 局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位,局部变量表存放了编译期可知的各种**基本数据类型**`(boolean、byte、char、short、int、float、long、double)`,`String`引用类型，对象引用(`reference`类型)和`returnAddress`类型（它指向了一条字节码指令的地址） ,局部变量存储在局部变量表中，随着线程而生，线程而灭。并且线程间数据不共享。\n2. 操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配\n\n3. 动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。\n  1. 前面的解析过程其实是静态解析；\n  2. 对于运行期转化为直接引用，称为动态解析。\n4. 方法返回地址\n  1. 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者\n  2. 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。\n5. 额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。\n\n栈帧工作流程:\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhzrutg4j30g40afwjb.jpg)\n\n当Java应用程序调用函数调用时，会在调用堆栈上分配**栈帧**。**栈帧**包含调用**方法的参数**，其本地参数以及**方法的返回地址**。返回地址表示执行点，程序执行将在调用方法返回后继续执行。如果没有新栈帧的空间，则由Java虚拟机（JVM）抛出StackOverflowError。\n\n可能耗尽Java应用程序堆栈的最常见情况是递归。在递归中，方法在执行期间调用自身。递归被认为是一种强大的通用编程技术，但必须谨慎使用，以避免StackOverflowError。\n\n示例StackOverflowError：\n\nStackOverflowErrorExample.java：\n```java\npublic class StackOverflowErrorExample {\n\n    public static void recursivePrint(int num) {\n        System.out.println(\"Number: \" + num);\n\n        if(num == 0)\n            return;\n        else\n            recursivePrint(++num);\n    }\n\n    public static void main(String[] args) {\n        StackOverflowErrorExample.recursivePrint(1);\n    }\n}\n```\n在这个例子中，我们定义了一个递归方法，调用`recursivePrint`它打印一个整数，然后调用自身，下一个连续的整数作为参数。\n\n使用-Xss1M指定线程堆栈大小等于1MB 的标志的示例执行如下所示：\n\n\n```JAVA\nNumber: 1\nNumber: 2\nNumber: 3\n...\nNumber: 6262\nNumber: 6263\nNumber: 6264\nNumber: 6265\nNumber: 6266\nException in thread \"main\" java.lang.StackOverflowError\n        at java.io.PrintStream.write(PrintStream.java:480)\n        at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)\n        at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)\n        at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)\n        at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)\n        at java.io.PrintStream.write(PrintStream.java:527)\n        at java.io.PrintStream.print(PrintStream.java:669)\n        at java.io.PrintStream.println(PrintStream.java:806)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:4)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9)\n        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9)\n```\n\n\n\n\n\n##### 2.2.2 异常(Exception)\n\nJava虚拟机规范规定该区域有两种异常：\n\n**StackOverFlowError：**当线程请求栈深度超出虚拟机栈所允许的深度时抛出\n**OutOfMemoryError：**当Java虚拟机动态扩展到无法申请足够内存时抛出\n#### 2.3 本地方法栈\n本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。\n\n**异常(Exception)：**Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。\n\n### 2.4 Java堆\nJava堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。\n\n从内存回收角度，Java堆被分为**新生代和老年代**；这样划分的好处是为了更快的回收内存；\n从内存分配角度，Java堆可以划分出线程私有的分配**缓冲区(Thread Local Allocation Buffer,TLAB)**；这样划分的好处是为了更快的分配内存；\n对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhquz4ngj30kv0aqq3g.jpg)\n\n对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。\n\n另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存.\n\n**异常(Exception)：**Java虚拟机规范规定该区域可抛出**OutOfMemoryError**。\n\n\n#### 2.5 方法区\n1. 方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n2. Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。 \n这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。\n\n3. **很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。**\n\n4. 运行时常量池(Runtime Constant Pool)是方法区的一部分。\n\n> JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。\n\n异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。\n\n#### 2.6 运行时常量池\n运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。\n\n**字面量：**与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。\n**符号引用：**编译语言层面的概念，包括以下3类：\n* 类和接口的全限定名\n* 字段的名称和描述符\n* 方法的名称和描述符\n但是该区域不会抛出**OutOfMemoryError**异常。\n\n\n\n### 3. JVM总结\n\n一张图总结一下JVM\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vhv2qwdfj30xa100whk.jpg)\n\n## Java内存模型\n\n**Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所问。**\n\n在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“**Java的线程间通过共享内存进行通信**”。\n\nJava内存模型是根据英文**Java Memory Model（JMM）**翻译过来的。**其实JMM并不像JVM内存结构一样是真实存在的,他只是一个抽象的概念**。[JSR-133: Java Memory Model and Thread Specification](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf)中描述了，**JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。**\n\n那么，简单总结下，**Java的多线程之间是通过共享内存进行通信的**，而由于采用共享内存进行通信，在通信过程中会存在一系列如**可见性、原子性、顺序性**等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。**JMM定义了一些语法集，这些语法集映射到Java语言中就是`volatile`、\n```synchronized```等关键字。**\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg)\n\n在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。\n\n## Java对象模型\n\nJava是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。\n\n`HotSpot`虚拟机中，设计了一个`OOP-Klass Model`。\n```OOP（Ordinary Object Pointer）```指的是普通对象指针，而Klass用来描述对象实例的具体类型。\n\n每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个\n```instanceKlass```，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个`instanceOopDesc`对象，这个对象中包含了对象头以及实例数据。\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vi3zdxbxj31840jsn8r.jpg)\n\n这就是一个简单的Java对象的`OOP-Klass`模型，即Java对象模型\n\n## 总结\n我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。\n\nJVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。\n\n","slug":"JVMModel-1552035735257","published":1,"updated":"2019-03-08T09:26:50.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszuvyt20007qk9ygg28izz4","content":"<h1 id=\"JVM内存结构、-Java内存模型-以及-Java对象模型\"><a href=\"#JVM内存结构、-Java内存模型-以及-Java对象模型\" class=\"headerlink\" title=\"JVM内存结构、 Java内存模型 以及 Java对象模型\"></a>JVM内存结构、 Java内存模型 以及 Java对象模型</h1><p>JVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。</p>\n<p>可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。</p>\n<h2 id=\"一、JVM内存结构\"><a href=\"#一、JVM内存结构\" class=\"headerlink\" title=\"一、JVM内存结构\"></a>一、JVM内存结构</h2><p>我们都知道，Java代码是要运行在虚拟机上的，<br><strong>Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故Java运行时内存结构，也就是指Java虚拟机的运行时内存结构。</strong>而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4\" target=\"_blank\" rel=\"noopener\">《Java虚拟机规范（Java SE 8）》</a>中描述了JVM运行时内存区域结构如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vfh1rwz7j30m90dr3za.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<h3 id=\"1-JVM简介\"><a href=\"#1-JVM简介\" class=\"headerlink\" title=\"1.JVM简介\"></a>1.JVM简介</h3><h4 id=\"1-1线程私有区：\"><a href=\"#1-1线程私有区：\" class=\"headerlink\" title=\"1.1线程私有区：\"></a>1.1线程私有区：</h4><p>这部分是线程独享</p>\n<p><strong>程序计数器：</strong>记录正在执行的虚拟机字节码的地址,行号；<br><strong>虚拟机栈：</strong>方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；<br><strong>本地方法栈：</strong>虚拟机的<code>Native</code>方法执行的内存区；</p>\n<h4 id=\"1-2线程共享区：\"><a href=\"#1-2线程共享区：\" class=\"headerlink\" title=\"1.2线程共享区：\"></a>1.2线程共享区：</h4><p><strong>Java堆：</strong>对象分配内存的区域；<br><strong>方法区：</strong>存放类信息、常量、静态变量、编译器编译后的代码等数据；<br><strong>常量池：</strong>存放编译器生成的各种字面量和符号引用，是方法区的一部分。</p>\n<p>对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。</p>\n<h3 id=\"2-JVM结构详解\"><a href=\"#2-JVM结构详解\" class=\"headerlink\" title=\"2. JVM结构详解\"></a>2. JVM结构详解</h3><p>运行时内存分为五大块区域（常量池属于方法区，算作一块区域），前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java内存总体结构图如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vfplp5bxj30m70bwwfw.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<h4 id=\"2-1-程序计数器PC\"><a href=\"#2-1-程序计数器PC\" class=\"headerlink\" title=\"2.1 程序计数器PC\"></a>2.1 程序计数器PC</h4><p>程序计数器PC，<strong>当前线程</strong>所执行的字节码行号指示器。<strong>每个线程都有自己计数器</strong>，是私有内存空间，该区域是整个内存中较小的一块。</p>\n<p><strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p>\n<p>当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；<strong>当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）</strong>。</p>\n<p>从上面的介绍中我们知道程序计数器主要有两个作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>\n<h4 id=\"2-2-虚拟机栈\"><a href=\"#2-2-虚拟机栈\" class=\"headerlink\" title=\"2.2 虚拟机栈\"></a>2.2 虚拟机栈</h4><p>与程序计数器一样，<strong>Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型</strong>。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。</p>\n<p>虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)<strong>执行的同时都会创建一个栈帧结构</strong>，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。</p>\n<h5 id=\"2-2-1-栈帧-Stack-Frame-结构\"><a href=\"#2-2-1-栈帧-Stack-Frame-结构\" class=\"headerlink\" title=\"2.2.1 栈帧(Stack Frame)结构\"></a>2.2.1 栈帧(Stack Frame)结构</h5><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhnbzfssj30gs0hiaau.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p><strong>栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机栈的栈元素</strong>。见上图， 栈帧包括：</p>\n<ol>\n<li>局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位,局部变量表存放了编译期可知的各种<strong>基本数据类型</strong><code>(boolean、byte、char、short、int、float、long、double)</code>,<code>String</code>引用类型，对象引用(<code>reference</code>类型)和<code>returnAddress</code>类型（它指向了一条字节码指令的地址） ,局部变量存储在局部变量表中，随着线程而生，线程而灭。并且线程间数据不共享。</li>\n<li><p>操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配</p>\n</li>\n<li><p>动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。</p>\n<ol>\n<li>前面的解析过程其实是静态解析；</li>\n<li>对于运行期转化为直接引用，称为动态解析。</li>\n</ol>\n</li>\n<li>方法返回地址<ol>\n<li>正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者</li>\n<li>异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。</li>\n</ol>\n</li>\n<li>额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。</li>\n</ol>\n<p>栈帧工作流程:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhzrutg4j30g40afwjb.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>当Java应用程序调用函数调用时，会在调用堆栈上分配<strong>栈帧</strong>。<strong>栈帧</strong>包含调用<strong>方法的参数</strong>，其本地参数以及<strong>方法的返回地址</strong>。返回地址表示执行点，程序执行将在调用方法返回后继续执行。如果没有新栈帧的空间，则由Java虚拟机（JVM）抛出StackOverflowError。</p>\n<p>可能耗尽Java应用程序堆栈的最常见情况是递归。在递归中，方法在执行期间调用自身。递归被认为是一种强大的通用编程技术，但必须谨慎使用，以避免StackOverflowError。</p>\n<p>示例StackOverflowError：</p>\n<p>StackOverflowErrorExample.java：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackOverflowErrorExample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">recursivePrint</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Number: \"</span> + num);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            recursivePrint(++num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        StackOverflowErrorExample.recursivePrint(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，我们定义了一个递归方法，调用<code>recursivePrint</code>它打印一个整数，然后调用自身，下一个连续的整数作为参数。</p>\n<p>使用-Xss1M指定线程堆栈大小等于1MB 的标志的示例执行如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number: <span class=\"number\">1</span></span><br><span class=\"line\">Number: <span class=\"number\">2</span></span><br><span class=\"line\">Number: <span class=\"number\">3</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Number: <span class=\"number\">6262</span></span><br><span class=\"line\">Number: <span class=\"number\">6263</span></span><br><span class=\"line\">Number: <span class=\"number\">6264</span></span><br><span class=\"line\">Number: <span class=\"number\">6265</span></span><br><span class=\"line\">Number: <span class=\"number\">6266</span></span><br><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.StackOverflowError</span><br><span class=\"line\">        at java.io.PrintStream.write(PrintStream.java:<span class=\"number\">480</span>)</span><br><span class=\"line\">        at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:<span class=\"number\">221</span>)</span><br><span class=\"line\">        at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:<span class=\"number\">291</span>)</span><br><span class=\"line\">        at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:<span class=\"number\">104</span>)</span><br><span class=\"line\">        at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:<span class=\"number\">185</span>)</span><br><span class=\"line\">        at java.io.PrintStream.write(PrintStream.java:<span class=\"number\">527</span>)</span><br><span class=\"line\">        at java.io.PrintStream.print(PrintStream.java:<span class=\"number\">669</span>)</span><br><span class=\"line\">        at java.io.PrintStream.println(PrintStream.java:<span class=\"number\">806</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">4</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">9</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">9</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-2-2-异常-Exception\"><a href=\"#2-2-2-异常-Exception\" class=\"headerlink\" title=\"2.2.2 异常(Exception)\"></a>2.2.2 异常(Exception)</h5><p>Java虚拟机规范规定该区域有两种异常：</p>\n<p><strong>StackOverFlowError：</strong>当线程请求栈深度超出虚拟机栈所允许的深度时抛出<br><strong>OutOfMemoryError：</strong>当Java虚拟机动态扩展到无法申请足够内存时抛出</p>\n<h4 id=\"2-3-本地方法栈\"><a href=\"#2-3-本地方法栈\" class=\"headerlink\" title=\"2.3 本地方法栈\"></a>2.3 本地方法栈</h4><p>本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。</p>\n<p><strong>异常(Exception)：</strong>Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。</p>\n<h3 id=\"2-4-Java堆\"><a href=\"#2-4-Java堆\" class=\"headerlink\" title=\"2.4 Java堆\"></a>2.4 Java堆</h3><p>Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。</p>\n<p>从内存回收角度，Java堆被分为<strong>新生代和老年代</strong>；这样划分的好处是为了更快的回收内存；<br>从内存分配角度，Java堆可以划分出线程私有的分配<strong>缓冲区(Thread Local Allocation Buffer,TLAB)</strong>；这样划分的好处是为了更快的分配内存；<br>对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhquz4ngj30kv0aqq3g.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。</p>\n<p>另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存.</p>\n<p><strong>异常(Exception)：</strong>Java虚拟机规范规定该区域可抛出<strong>OutOfMemoryError</strong>。</p>\n<h4 id=\"2-5-方法区\"><a href=\"#2-5-方法区\" class=\"headerlink\" title=\"2.5 方法区\"></a>2.5 方法区</h4><ol>\n<li><p>方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n</li>\n<li><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。<br>这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。</p>\n</li>\n<li><p><strong>很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。</strong></p>\n</li>\n<li><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。</p>\n</li>\n</ol>\n<blockquote>\n<p>JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。</p>\n</blockquote>\n<p>异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。</p>\n<h4 id=\"2-6-运行时常量池\"><a href=\"#2-6-运行时常量池\" class=\"headerlink\" title=\"2.6 运行时常量池\"></a>2.6 运行时常量池</h4><p>运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。</p>\n<p><strong>字面量：</strong>与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。<br><strong>符号引用：</strong>编译语言层面的概念，包括以下3类：</p>\n<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符<br>但是该区域不会抛出<strong>OutOfMemoryError</strong>异常。</li>\n</ul>\n<h3 id=\"3-JVM总结\"><a href=\"#3-JVM总结\" class=\"headerlink\" title=\"3. JVM总结\"></a>3. JVM总结</h3><p>一张图总结一下JVM</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhv2qwdfj30xa100whk.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p><strong>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所问。</strong></p>\n<p>在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“<strong>Java的线程间通过共享内存进行通信</strong>”。</p>\n<p>Java内存模型是根据英文<strong>Java Memory Model（JMM）</strong>翻译过来的。<strong>其实JMM并不像JVM内存结构一样是真实存在的,他只是一个抽象的概念</strong>。<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf\" target=\"_blank\" rel=\"noopener\">JSR-133: Java Memory Model and Thread Specification</a>中描述了，<strong>JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</strong></p>\n<p>那么，简单总结下，<strong>Java的多线程之间是通过共享内存进行通信的</strong>，而由于采用共享内存进行通信，在通信过程中会存在一系列如<strong>可见性、原子性、顺序性</strong>等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。<strong>JMM定义了一些语法集，这些语法集映射到Java语言中就是<code>volatile</code>、<br><code>synchronized</code>等关键字。</strong><br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。</p>\n<h2 id=\"Java对象模型\"><a href=\"#Java对象模型\" class=\"headerlink\" title=\"Java对象模型\"></a>Java对象模型</h2><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>\n<p><code>HotSpot</code>虚拟机中，设计了一个<code>OOP-Klass Model</code>。<br><code>OOP（Ordinary Object Pointer）</code>指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p>\n<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<br><code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vi3zdxbxj31840jsn8r.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这就是一个简单的Java对象的<code>OOP-Klass</code>模型，即Java对象模型</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。</p>\n<p>JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JVM内存结构、-Java内存模型-以及-Java对象模型\"><a href=\"#JVM内存结构、-Java内存模型-以及-Java对象模型\" class=\"headerlink\" title=\"JVM内存结构、 Java内存模型 以及 Java对象模型\"></a>JVM内存结构、 Java内存模型 以及 Java对象模型</h1><p>JVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。</p>\n<p>可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。</p>\n<h2 id=\"一、JVM内存结构\"><a href=\"#一、JVM内存结构\" class=\"headerlink\" title=\"一、JVM内存结构\"></a>一、JVM内存结构</h2><p>我们都知道，Java代码是要运行在虚拟机上的，<br><strong>Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故Java运行时内存结构，也就是指Java虚拟机的运行时内存结构。</strong>而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4\" target=\"_blank\" rel=\"noopener\">《Java虚拟机规范（Java SE 8）》</a>中描述了JVM运行时内存区域结构如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vfh1rwz7j30m90dr3za.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<h3 id=\"1-JVM简介\"><a href=\"#1-JVM简介\" class=\"headerlink\" title=\"1.JVM简介\"></a>1.JVM简介</h3><h4 id=\"1-1线程私有区：\"><a href=\"#1-1线程私有区：\" class=\"headerlink\" title=\"1.1线程私有区：\"></a>1.1线程私有区：</h4><p>这部分是线程独享</p>\n<p><strong>程序计数器：</strong>记录正在执行的虚拟机字节码的地址,行号；<br><strong>虚拟机栈：</strong>方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；<br><strong>本地方法栈：</strong>虚拟机的<code>Native</code>方法执行的内存区；</p>\n<h4 id=\"1-2线程共享区：\"><a href=\"#1-2线程共享区：\" class=\"headerlink\" title=\"1.2线程共享区：\"></a>1.2线程共享区：</h4><p><strong>Java堆：</strong>对象分配内存的区域；<br><strong>方法区：</strong>存放类信息、常量、静态变量、编译器编译后的代码等数据；<br><strong>常量池：</strong>存放编译器生成的各种字面量和符号引用，是方法区的一部分。</p>\n<p>对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。</p>\n<h3 id=\"2-JVM结构详解\"><a href=\"#2-JVM结构详解\" class=\"headerlink\" title=\"2. JVM结构详解\"></a>2. JVM结构详解</h3><p>运行时内存分为五大块区域（常量池属于方法区，算作一块区域），前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java内存总体结构图如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vfplp5bxj30m70bwwfw.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<h4 id=\"2-1-程序计数器PC\"><a href=\"#2-1-程序计数器PC\" class=\"headerlink\" title=\"2.1 程序计数器PC\"></a>2.1 程序计数器PC</h4><p>程序计数器PC，<strong>当前线程</strong>所执行的字节码行号指示器。<strong>每个线程都有自己计数器</strong>，是私有内存空间，该区域是整个内存中较小的一块。</p>\n<p><strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p>\n<p>当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；<strong>当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）</strong>。</p>\n<p>从上面的介绍中我们知道程序计数器主要有两个作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>\n<h4 id=\"2-2-虚拟机栈\"><a href=\"#2-2-虚拟机栈\" class=\"headerlink\" title=\"2.2 虚拟机栈\"></a>2.2 虚拟机栈</h4><p>与程序计数器一样，<strong>Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型</strong>。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。</p>\n<p>虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)<strong>执行的同时都会创建一个栈帧结构</strong>，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。</p>\n<h5 id=\"2-2-1-栈帧-Stack-Frame-结构\"><a href=\"#2-2-1-栈帧-Stack-Frame-结构\" class=\"headerlink\" title=\"2.2.1 栈帧(Stack Frame)结构\"></a>2.2.1 栈帧(Stack Frame)结构</h5><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhnbzfssj30gs0hiaau.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p><strong>栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机栈的栈元素</strong>。见上图， 栈帧包括：</p>\n<ol>\n<li>局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位,局部变量表存放了编译期可知的各种<strong>基本数据类型</strong><code>(boolean、byte、char、short、int、float、long、double)</code>,<code>String</code>引用类型，对象引用(<code>reference</code>类型)和<code>returnAddress</code>类型（它指向了一条字节码指令的地址） ,局部变量存储在局部变量表中，随着线程而生，线程而灭。并且线程间数据不共享。</li>\n<li><p>操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配</p>\n</li>\n<li><p>动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。</p>\n<ol>\n<li>前面的解析过程其实是静态解析；</li>\n<li>对于运行期转化为直接引用，称为动态解析。</li>\n</ol>\n</li>\n<li>方法返回地址<ol>\n<li>正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者</li>\n<li>异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。</li>\n</ol>\n</li>\n<li>额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。</li>\n</ol>\n<p>栈帧工作流程:</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhzrutg4j30g40afwjb.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>当Java应用程序调用函数调用时，会在调用堆栈上分配<strong>栈帧</strong>。<strong>栈帧</strong>包含调用<strong>方法的参数</strong>，其本地参数以及<strong>方法的返回地址</strong>。返回地址表示执行点，程序执行将在调用方法返回后继续执行。如果没有新栈帧的空间，则由Java虚拟机（JVM）抛出StackOverflowError。</p>\n<p>可能耗尽Java应用程序堆栈的最常见情况是递归。在递归中，方法在执行期间调用自身。递归被认为是一种强大的通用编程技术，但必须谨慎使用，以避免StackOverflowError。</p>\n<p>示例StackOverflowError：</p>\n<p>StackOverflowErrorExample.java：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackOverflowErrorExample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">recursivePrint</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Number: \"</span> + num);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            recursivePrint(++num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        StackOverflowErrorExample.recursivePrint(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，我们定义了一个递归方法，调用<code>recursivePrint</code>它打印一个整数，然后调用自身，下一个连续的整数作为参数。</p>\n<p>使用-Xss1M指定线程堆栈大小等于1MB 的标志的示例执行如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number: <span class=\"number\">1</span></span><br><span class=\"line\">Number: <span class=\"number\">2</span></span><br><span class=\"line\">Number: <span class=\"number\">3</span></span><br><span class=\"line\">...</span><br><span class=\"line\">Number: <span class=\"number\">6262</span></span><br><span class=\"line\">Number: <span class=\"number\">6263</span></span><br><span class=\"line\">Number: <span class=\"number\">6264</span></span><br><span class=\"line\">Number: <span class=\"number\">6265</span></span><br><span class=\"line\">Number: <span class=\"number\">6266</span></span><br><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.StackOverflowError</span><br><span class=\"line\">        at java.io.PrintStream.write(PrintStream.java:<span class=\"number\">480</span>)</span><br><span class=\"line\">        at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:<span class=\"number\">221</span>)</span><br><span class=\"line\">        at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:<span class=\"number\">291</span>)</span><br><span class=\"line\">        at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:<span class=\"number\">104</span>)</span><br><span class=\"line\">        at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:<span class=\"number\">185</span>)</span><br><span class=\"line\">        at java.io.PrintStream.write(PrintStream.java:<span class=\"number\">527</span>)</span><br><span class=\"line\">        at java.io.PrintStream.print(PrintStream.java:<span class=\"number\">669</span>)</span><br><span class=\"line\">        at java.io.PrintStream.println(PrintStream.java:<span class=\"number\">806</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">4</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">9</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">9</span>)</span><br><span class=\"line\">        at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:<span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-2-2-异常-Exception\"><a href=\"#2-2-2-异常-Exception\" class=\"headerlink\" title=\"2.2.2 异常(Exception)\"></a>2.2.2 异常(Exception)</h5><p>Java虚拟机规范规定该区域有两种异常：</p>\n<p><strong>StackOverFlowError：</strong>当线程请求栈深度超出虚拟机栈所允许的深度时抛出<br><strong>OutOfMemoryError：</strong>当Java虚拟机动态扩展到无法申请足够内存时抛出</p>\n<h4 id=\"2-3-本地方法栈\"><a href=\"#2-3-本地方法栈\" class=\"headerlink\" title=\"2.3 本地方法栈\"></a>2.3 本地方法栈</h4><p>本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。</p>\n<p><strong>异常(Exception)：</strong>Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。</p>\n<h3 id=\"2-4-Java堆\"><a href=\"#2-4-Java堆\" class=\"headerlink\" title=\"2.4 Java堆\"></a>2.4 Java堆</h3><p>Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。</p>\n<p>从内存回收角度，Java堆被分为<strong>新生代和老年代</strong>；这样划分的好处是为了更快的回收内存；<br>从内存分配角度，Java堆可以划分出线程私有的分配<strong>缓冲区(Thread Local Allocation Buffer,TLAB)</strong>；这样划分的好处是为了更快的分配内存；<br>对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhquz4ngj30kv0aqq3g.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。</p>\n<p>另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存.</p>\n<p><strong>异常(Exception)：</strong>Java虚拟机规范规定该区域可抛出<strong>OutOfMemoryError</strong>。</p>\n<h4 id=\"2-5-方法区\"><a href=\"#2-5-方法区\" class=\"headerlink\" title=\"2.5 方法区\"></a>2.5 方法区</h4><ol>\n<li><p>方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n</li>\n<li><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。<br>这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。</p>\n</li>\n<li><p><strong>很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。</strong></p>\n</li>\n<li><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。</p>\n</li>\n</ol>\n<blockquote>\n<p>JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。</p>\n</blockquote>\n<p>异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。</p>\n<h4 id=\"2-6-运行时常量池\"><a href=\"#2-6-运行时常量池\" class=\"headerlink\" title=\"2.6 运行时常量池\"></a>2.6 运行时常量池</h4><p>运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。</p>\n<p><strong>字面量：</strong>与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。<br><strong>符号引用：</strong>编译语言层面的概念，包括以下3类：</p>\n<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符<br>但是该区域不会抛出<strong>OutOfMemoryError</strong>异常。</li>\n</ul>\n<h3 id=\"3-JVM总结\"><a href=\"#3-JVM总结\" class=\"headerlink\" title=\"3. JVM总结\"></a>3. JVM总结</h3><p>一张图总结一下JVM</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vhv2qwdfj30xa100whk.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p><strong>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所问。</strong></p>\n<p>在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“<strong>Java的线程间通过共享内存进行通信</strong>”。</p>\n<p>Java内存模型是根据英文<strong>Java Memory Model（JMM）</strong>翻译过来的。<strong>其实JMM并不像JVM内存结构一样是真实存在的,他只是一个抽象的概念</strong>。<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf\" target=\"_blank\" rel=\"noopener\">JSR-133: Java Memory Model and Thread Specification</a>中描述了，<strong>JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</strong></p>\n<p>那么，简单总结下，<strong>Java的多线程之间是通过共享内存进行通信的</strong>，而由于采用共享内存进行通信，在通信过程中会存在一系列如<strong>可见性、原子性、顺序性</strong>等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。<strong>JMM定义了一些语法集，这些语法集映射到Java语言中就是<code>volatile</code>、<br><code>synchronized</code>等关键字。</strong><br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。</p>\n<h2 id=\"Java对象模型\"><a href=\"#Java对象模型\" class=\"headerlink\" title=\"Java对象模型\"></a>Java对象模型</h2><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p>\n<p><code>HotSpot</code>虚拟机中，设计了一个<code>OOP-Klass Model</code>。<br><code>OOP（Ordinary Object Pointer）</code>指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p>\n<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<br><code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vi3zdxbxj31840jsn8r.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这就是一个简单的Java对象的<code>OOP-Klass</code>模型，即Java对象模型</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。</p>\n<p>JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。</p>\n"},{"title":"Android 源码分析之 AsyncTask 源码分析","date":"2019-02-28T07:54:26.000Z","_content":"\n# Android 源码分析之 AsyncTask 源码分析\n\n## 1、AsyncTask的使用\n使用 **AsyncTask** 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 **ThreadPoolExecutor** 和 **FutureTask**等。\nAsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 **Params**、**Progress** 和 **Result**，分别用来指定参数、进度和结果的值的类型。\n以及四个重要的方法，分别是 **onPreExecute()**, **doInBackground()**, **onProgressUpdate()** 和 **onPostExecute()**。\n这四个方法中，除了 **doInBackground()**，其他三个都是运行在**UI线程**的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 **doInBackground()** 运行在后台线程中，用来执行耗时的任务。\n\n<!-- more -->\n一种典型的使用方法如下：\n\n```JAVA\nprivate class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {\n    \n    @Override\n    protected Long doInBackground(URL... urls) {\n        int count = urls.length;\n        long totalSize = 0;\n        for (int i = 0; i < count; i++) {\n            totalSize += Downloader.downloadFile(urls[i]);\n            publishProgress((int) ((i / (float) count) * 100));\n            if (isCancelled()) break;\n        }\n        return totalSize;\n    }\n\n    @Override\n    protected void onProgressUpdate(Integer... progress) {\n        setProgressPercent(progress[0]);\n    }\n\n    @Override\n    protected void onPostExecute(Long result) {\n        showDialog(\"Downloaded \" + result + \" bytes\");\n    }\n}\n\n```\n\n\n上面说 **AsyncTask** 有4个重要的方法，这里我们覆写了3个。**doInBackground()**运行在线程当中，耗时的任务可以放在这里进行；**onProgressUpdate()** 用来处理当任务的进度发生变化时候的逻辑；**onPostExecute()** 用来处理当任务执行完毕之后的逻辑。另外，这里我们还用到了 **publishProgress()** 和 **isCancelled()** 两个方法，分别用来发布任务进度和判断任务是否被取消。\n然后，我们可以用下面的方式来使用它：\n\n```JAVA\n    new DownloadFilesTask().execute(url1, url2, url3);\n```\n使用AsyncTask的时候要注意以下几点内容：\n\n1. AsyncTask 的类必须在主线程中进行加载，当在4.1之后这个过程会自动进行；\n2. AsyncTask 的对象必须在主线程中创建；\n3. **execute()**方法必须在UI线程中被调用；\n4. 不要直接调用 **onPreExecute()**, **doInBackground()**, **onProgressUpdate()** 和 **onPostExecute()**；\n5. 一个AsyncTask对象的 **execute()** 方法只能被调用一次；\n\nAndroid 1.6 之前，AsyncTask 是**串行执行任务**的；1.6 采用线程池处理**并行任务**；从 3.0 开始，又采用一个线程来串行执行任务。\n3.0 之后可以用 **executeOnExecutor()** 来并行地执行任务，如果我们希望在3.0之后能并行地执行上面的任务，那么我们应该这样去写：\n\n```JAVA\n    new DownloadFilesTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url1, url2, url3);\n\n```\n这里的 **AsyncTask.THREAD_POOL_EXECUTOR** 是 AsyncTask 内部定义的一个线程池，我们可以使用它来将 AsyncTask 设置成并行的。\n\n\n## 2、AsyncTask源码分析\n\n### 2.1 AsyncTask 的初始化过程\n当初始化一个 AsyncTask 的时候，所有的重载构造方法都会调用下面的这个构造方法。这里做了几件事情：\n\n1. 初始化一个 Handler 对象 mHandler，该 Handler 用来将消息发送到它所在的线程中，通常使用默认的值，即主线程的 Handler；\n2. 初始化一个 **WorkerRunnable** 对象 **mWorker**。它是一个 **WorkerRunnable** 类型的实例，而 **WorkerRunnable 又继承自 Callable**，因此它是一个可以被执行的对象。我们会把在该对象中回调 doInBackground() 来将我们的业务逻辑放在线程池中执行。\n3. 初始化一个 **FutureTask** 对象 **mFuture**。该对象包装了 **mWorker** 并且当 **mWorker** 执行完毕之后会调用它的 **postResultIfNotInvoked()**方法来通知主线程（不论任务已经执行完毕还是被取消了，都会调用这个方法）。\n\n```JAVA\n    public AsyncTask(@Nullable Looper callbackLooper) {\n        // 1. 初始化用来发送消息的 Handler\n        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()\n            ? getMainHandler()\n            : new Handler(callbackLooper);\n\n        // 2. 封装一个对象用来执行我们的任务\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n                Result result = null;\n                try {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                    // 回调我们的业务逻辑\n                    result = doInBackground(mParams);\n                    Binder.flushPendingCommands();\n                } catch (Throwable tr) {\n                    mCancelled.set(true);\n                    throw tr;\n                } finally {\n                    // 发送结果给主线程\n                    postResult(result);\n                }\n                return result;\n            }\n        };\n\n        // 3. 初始化一个 FutureTask，并且当它执行完毕的时候，会调用 postResultIfNotInvoked 来将消息的执行结果发送到主线程中\n        mFuture = new FutureTask<Result>(mWorker) {\n            @Override\n            protected void done() {\n                try {\n                    // 如果任务没有被触发，也要发送一个结果\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n        };\n    }\n\n```\n\n当这样设置完毕之后，我们就可以使用 execute() 方法来开始执行任务了。\n\n### 2.2 AsyncTask 中任务的串行执行过程\n我们从 execute() 方法开始分析 AsyncTask:\n\n\n```JAVA\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params) {\n        if (mStatus != Status.PENDING) { // 1.判断线程当前的状态\n            switch (mStatus) {\n                case RUNNING: throw new IllegalStateException(...);\n                case FINISHED: throw new IllegalStateException(...);\n            }\n        }\n        mStatus = Status.RUNNING;\n        onPreExecute();             // 2.回调生命周期方法\n        mWorker.mParams = params;   // 3.赋值给可执行的对象 WorkerRunnable\n        exec.execute(mFuture);      // 4.在线程池中执行任务\n        return this;\n    }\n\n```\n\n当我们调用 **AsyncTask** 的 **execute()** 方法的时候会立即调用它的 **executeOnExecutor()** 方法。这里传入了两个参数，分别是一个 **Executor** 和任务的参数 **params**。从上面我们可以看出，当直接调用 **execute() **方法的时候会使用默认的线程池 **sDefaultExecutor**，而当我们指定了线程池之后，会使用我们指定的线程池来执行任务。\n在 1 处，会对 **AsyncTask** 当前的状态进行判断，这就对应了前面说的，一个任务只能被执行一次。在 2 处会调用**onPreExecute()**方法，如果我们覆写了该方法，那么它就会在这个时候被调用。在 3 处的操作是在为 **mWorker** 赋值，即把调用 **execute** 方法时传入的参数赋值给了 **mWorker**。接下来，会将 **mFuture** 添加到线程池中执行。\n当我们不指定任何线程池的时候使用的 **sDefaultExecutor** 是一个串行的线程池，它的定义如下：\n\n```JAVA\n    public static final Executor SERIAL_EXECUTOR = new SerialExecutor();\n    private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n\n    private static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        // 相当于对传入的Runnable进行了一层包装\n                        r.run();\n                    } finally {\n                        // 分配下一个任务\n                        scheduleNext();\n                    }\n                }\n            });\n            // 如果当前没有正在执行的任务，那么就尝试从队列中取出并执行\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            // 从队列中取任务并使用THREAD_POOL_EXECUTOR执行\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n\n```\n\n从上面我们可以看出，我们添加到线程池中的任务实际上并没有直接交给线程池来执行，而是对其进行了处理之后才执行的，**SerialExecutor** 通过内部维护了**双端队列**，每当一个 AsyncTask 调用 execute() 方法的时候都会被放在该队列当中进行排队。如果当前没有正在执行的任务，那么就从队列中取一个任务交给 **THREAD_POOL_EXECUTOR** 执行；当一个任务执行完毕之后又会调用 **scheduleNext()** 取下一个任务执行。也就是说，实际上 **sDefaultExecutor** 在这里只是起了一个任务调度的作用，任务最终还是交给 **THREAD_POOL_EXECUTOR** 执行的。\n这里的**THREAD_POOL_EXECUTOR**也是一个线程池，它在静态代码块中被初始化：\n\n```JAVA\n    static {\n        // 使用指定的参数创建一个线程池\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n                sPoolWorkQueue, sThreadFactory);\n        threadPoolExecutor.allowCoreThreadTimeOut(true);\n        THREAD_POOL_EXECUTOR = threadPoolExecutor;\n    }\n```\n\n我们也可以直接将这个静态的线程池作为我们任务执行的线程池而不是放在上面的队列中被串行地执行。\n\n### 2.3 将任务执行的结果发送到其他线程\n上面的 **WorkerRunnable** 中已经用到了 **postResult** 方法，它用来将任务执行的结果发送给 Handler：\n\n```JAVA\n    private Result postResult(Result result) {\n        @SuppressWarnings(\"unchecked\")\n        Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult<Result>(this, result));\n        message.sendToTarget();\n        return result;\n    }\n\n```\n\n**mHandler** 会在创建 **AsyncTask** 的时候初始化。我们可以通过 AsyncTask 的构造方法传入 **Handler** 和 **Looper** 来指定该对象所在的线程。当我们没有指定的时候，会使用 **AsyncTask** 内部的 **InternalHandler** 创建 Handler：\n\n```JAVA\n    private final Handler mHandler;\n\n    public AsyncTask(@Nullable Looper callbackLooper) {\n        // 根据传入的参数创建Handler对象\n        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() \n            ? getMainHandler() : new Handler(callbackLooper);\n    }\n\n    private static Handler getMainHandler() {\n        synchronized (AsyncTask.class) {\n            if (sHandler == null) {\n                // 使用 InternalHandler 创建对象\n                sHandler = new InternalHandler(Looper.getMainLooper());\n            }\n            return sHandler;\n        }\n    }\n\n    // AsyncTask 内部定义 的Handler 类型\n    private static class InternalHandler extends Handler {\n        public InternalHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            // 根据传入的消息类型进行处理\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break;\n                case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break;\n            }\n        }\n    }\n\n```\n\n## 3、总结\n上面我们梳理了 AsyncTask 的大致过程，我们来梳理下：\n每当我们实例化一个 AsyncTask 的时候都会在内部封装成一个 Runnable 对象，该对象可以直接放在线程池中执行。这里存在两个线程池，一个是 SerialExecutor 一个是 THREAD_POOL_EXECUTOR，前者主要用来进行任务调度，即把交给线程的任务放在队列中进行排队执行，而时机上所有的任务都是在后者中执行完成的。这个两个线程池都是静态的字段，所以它们对应于整个类的。也就是说，当使用默认的线程池的时候，实例化的 AsyncTask 会一个个地，按照加入到队列中的顺序依次执行。\n","source":"_posts/AsyncTask20190228155539.md","raw":"---\ntitle: Android 源码分析之 AsyncTask 源码分析\ntags: [AsyncTask]\ncategories: [Android]\ndate: 2019-02-28 15:54:26\n---\n\n# Android 源码分析之 AsyncTask 源码分析\n\n## 1、AsyncTask的使用\n使用 **AsyncTask** 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 **ThreadPoolExecutor** 和 **FutureTask**等。\nAsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 **Params**、**Progress** 和 **Result**，分别用来指定参数、进度和结果的值的类型。\n以及四个重要的方法，分别是 **onPreExecute()**, **doInBackground()**, **onProgressUpdate()** 和 **onPostExecute()**。\n这四个方法中，除了 **doInBackground()**，其他三个都是运行在**UI线程**的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 **doInBackground()** 运行在后台线程中，用来执行耗时的任务。\n\n<!-- more -->\n一种典型的使用方法如下：\n\n```JAVA\nprivate class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {\n    \n    @Override\n    protected Long doInBackground(URL... urls) {\n        int count = urls.length;\n        long totalSize = 0;\n        for (int i = 0; i < count; i++) {\n            totalSize += Downloader.downloadFile(urls[i]);\n            publishProgress((int) ((i / (float) count) * 100));\n            if (isCancelled()) break;\n        }\n        return totalSize;\n    }\n\n    @Override\n    protected void onProgressUpdate(Integer... progress) {\n        setProgressPercent(progress[0]);\n    }\n\n    @Override\n    protected void onPostExecute(Long result) {\n        showDialog(\"Downloaded \" + result + \" bytes\");\n    }\n}\n\n```\n\n\n上面说 **AsyncTask** 有4个重要的方法，这里我们覆写了3个。**doInBackground()**运行在线程当中，耗时的任务可以放在这里进行；**onProgressUpdate()** 用来处理当任务的进度发生变化时候的逻辑；**onPostExecute()** 用来处理当任务执行完毕之后的逻辑。另外，这里我们还用到了 **publishProgress()** 和 **isCancelled()** 两个方法，分别用来发布任务进度和判断任务是否被取消。\n然后，我们可以用下面的方式来使用它：\n\n```JAVA\n    new DownloadFilesTask().execute(url1, url2, url3);\n```\n使用AsyncTask的时候要注意以下几点内容：\n\n1. AsyncTask 的类必须在主线程中进行加载，当在4.1之后这个过程会自动进行；\n2. AsyncTask 的对象必须在主线程中创建；\n3. **execute()**方法必须在UI线程中被调用；\n4. 不要直接调用 **onPreExecute()**, **doInBackground()**, **onProgressUpdate()** 和 **onPostExecute()**；\n5. 一个AsyncTask对象的 **execute()** 方法只能被调用一次；\n\nAndroid 1.6 之前，AsyncTask 是**串行执行任务**的；1.6 采用线程池处理**并行任务**；从 3.0 开始，又采用一个线程来串行执行任务。\n3.0 之后可以用 **executeOnExecutor()** 来并行地执行任务，如果我们希望在3.0之后能并行地执行上面的任务，那么我们应该这样去写：\n\n```JAVA\n    new DownloadFilesTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url1, url2, url3);\n\n```\n这里的 **AsyncTask.THREAD_POOL_EXECUTOR** 是 AsyncTask 内部定义的一个线程池，我们可以使用它来将 AsyncTask 设置成并行的。\n\n\n## 2、AsyncTask源码分析\n\n### 2.1 AsyncTask 的初始化过程\n当初始化一个 AsyncTask 的时候，所有的重载构造方法都会调用下面的这个构造方法。这里做了几件事情：\n\n1. 初始化一个 Handler 对象 mHandler，该 Handler 用来将消息发送到它所在的线程中，通常使用默认的值，即主线程的 Handler；\n2. 初始化一个 **WorkerRunnable** 对象 **mWorker**。它是一个 **WorkerRunnable** 类型的实例，而 **WorkerRunnable 又继承自 Callable**，因此它是一个可以被执行的对象。我们会把在该对象中回调 doInBackground() 来将我们的业务逻辑放在线程池中执行。\n3. 初始化一个 **FutureTask** 对象 **mFuture**。该对象包装了 **mWorker** 并且当 **mWorker** 执行完毕之后会调用它的 **postResultIfNotInvoked()**方法来通知主线程（不论任务已经执行完毕还是被取消了，都会调用这个方法）。\n\n```JAVA\n    public AsyncTask(@Nullable Looper callbackLooper) {\n        // 1. 初始化用来发送消息的 Handler\n        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()\n            ? getMainHandler()\n            : new Handler(callbackLooper);\n\n        // 2. 封装一个对象用来执行我们的任务\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n                Result result = null;\n                try {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                    // 回调我们的业务逻辑\n                    result = doInBackground(mParams);\n                    Binder.flushPendingCommands();\n                } catch (Throwable tr) {\n                    mCancelled.set(true);\n                    throw tr;\n                } finally {\n                    // 发送结果给主线程\n                    postResult(result);\n                }\n                return result;\n            }\n        };\n\n        // 3. 初始化一个 FutureTask，并且当它执行完毕的时候，会调用 postResultIfNotInvoked 来将消息的执行结果发送到主线程中\n        mFuture = new FutureTask<Result>(mWorker) {\n            @Override\n            protected void done() {\n                try {\n                    // 如果任务没有被触发，也要发送一个结果\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n        };\n    }\n\n```\n\n当这样设置完毕之后，我们就可以使用 execute() 方法来开始执行任务了。\n\n### 2.2 AsyncTask 中任务的串行执行过程\n我们从 execute() 方法开始分析 AsyncTask:\n\n\n```JAVA\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params) {\n        if (mStatus != Status.PENDING) { // 1.判断线程当前的状态\n            switch (mStatus) {\n                case RUNNING: throw new IllegalStateException(...);\n                case FINISHED: throw new IllegalStateException(...);\n            }\n        }\n        mStatus = Status.RUNNING;\n        onPreExecute();             // 2.回调生命周期方法\n        mWorker.mParams = params;   // 3.赋值给可执行的对象 WorkerRunnable\n        exec.execute(mFuture);      // 4.在线程池中执行任务\n        return this;\n    }\n\n```\n\n当我们调用 **AsyncTask** 的 **execute()** 方法的时候会立即调用它的 **executeOnExecutor()** 方法。这里传入了两个参数，分别是一个 **Executor** 和任务的参数 **params**。从上面我们可以看出，当直接调用 **execute() **方法的时候会使用默认的线程池 **sDefaultExecutor**，而当我们指定了线程池之后，会使用我们指定的线程池来执行任务。\n在 1 处，会对 **AsyncTask** 当前的状态进行判断，这就对应了前面说的，一个任务只能被执行一次。在 2 处会调用**onPreExecute()**方法，如果我们覆写了该方法，那么它就会在这个时候被调用。在 3 处的操作是在为 **mWorker** 赋值，即把调用 **execute** 方法时传入的参数赋值给了 **mWorker**。接下来，会将 **mFuture** 添加到线程池中执行。\n当我们不指定任何线程池的时候使用的 **sDefaultExecutor** 是一个串行的线程池，它的定义如下：\n\n```JAVA\n    public static final Executor SERIAL_EXECUTOR = new SerialExecutor();\n    private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n\n    private static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        // 相当于对传入的Runnable进行了一层包装\n                        r.run();\n                    } finally {\n                        // 分配下一个任务\n                        scheduleNext();\n                    }\n                }\n            });\n            // 如果当前没有正在执行的任务，那么就尝试从队列中取出并执行\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            // 从队列中取任务并使用THREAD_POOL_EXECUTOR执行\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n\n```\n\n从上面我们可以看出，我们添加到线程池中的任务实际上并没有直接交给线程池来执行，而是对其进行了处理之后才执行的，**SerialExecutor** 通过内部维护了**双端队列**，每当一个 AsyncTask 调用 execute() 方法的时候都会被放在该队列当中进行排队。如果当前没有正在执行的任务，那么就从队列中取一个任务交给 **THREAD_POOL_EXECUTOR** 执行；当一个任务执行完毕之后又会调用 **scheduleNext()** 取下一个任务执行。也就是说，实际上 **sDefaultExecutor** 在这里只是起了一个任务调度的作用，任务最终还是交给 **THREAD_POOL_EXECUTOR** 执行的。\n这里的**THREAD_POOL_EXECUTOR**也是一个线程池，它在静态代码块中被初始化：\n\n```JAVA\n    static {\n        // 使用指定的参数创建一个线程池\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,\n                sPoolWorkQueue, sThreadFactory);\n        threadPoolExecutor.allowCoreThreadTimeOut(true);\n        THREAD_POOL_EXECUTOR = threadPoolExecutor;\n    }\n```\n\n我们也可以直接将这个静态的线程池作为我们任务执行的线程池而不是放在上面的队列中被串行地执行。\n\n### 2.3 将任务执行的结果发送到其他线程\n上面的 **WorkerRunnable** 中已经用到了 **postResult** 方法，它用来将任务执行的结果发送给 Handler：\n\n```JAVA\n    private Result postResult(Result result) {\n        @SuppressWarnings(\"unchecked\")\n        Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult<Result>(this, result));\n        message.sendToTarget();\n        return result;\n    }\n\n```\n\n**mHandler** 会在创建 **AsyncTask** 的时候初始化。我们可以通过 AsyncTask 的构造方法传入 **Handler** 和 **Looper** 来指定该对象所在的线程。当我们没有指定的时候，会使用 **AsyncTask** 内部的 **InternalHandler** 创建 Handler：\n\n```JAVA\n    private final Handler mHandler;\n\n    public AsyncTask(@Nullable Looper callbackLooper) {\n        // 根据传入的参数创建Handler对象\n        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() \n            ? getMainHandler() : new Handler(callbackLooper);\n    }\n\n    private static Handler getMainHandler() {\n        synchronized (AsyncTask.class) {\n            if (sHandler == null) {\n                // 使用 InternalHandler 创建对象\n                sHandler = new InternalHandler(Looper.getMainLooper());\n            }\n            return sHandler;\n        }\n    }\n\n    // AsyncTask 内部定义 的Handler 类型\n    private static class InternalHandler extends Handler {\n        public InternalHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            // 根据传入的消息类型进行处理\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break;\n                case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break;\n            }\n        }\n    }\n\n```\n\n## 3、总结\n上面我们梳理了 AsyncTask 的大致过程，我们来梳理下：\n每当我们实例化一个 AsyncTask 的时候都会在内部封装成一个 Runnable 对象，该对象可以直接放在线程池中执行。这里存在两个线程池，一个是 SerialExecutor 一个是 THREAD_POOL_EXECUTOR，前者主要用来进行任务调度，即把交给线程的任务放在队列中进行排队执行，而时机上所有的任务都是在后者中执行完成的。这个两个线程池都是静态的字段，所以它们对应于整个类的。也就是说，当使用默认的线程池的时候，实例化的 AsyncTask 会一个个地，按照加入到队列中的顺序依次执行。\n","slug":"AsyncTask20190228155539","published":1,"updated":"2019-03-08T09:24:42.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszuvyt50008qk9yympx46in","content":"<h1 id=\"Android-源码分析之-AsyncTask-源码分析\"><a href=\"#Android-源码分析之-AsyncTask-源码分析\" class=\"headerlink\" title=\"Android 源码分析之 AsyncTask 源码分析\"></a>Android 源码分析之 AsyncTask 源码分析</h1><h2 id=\"1、AsyncTask的使用\"><a href=\"#1、AsyncTask的使用\" class=\"headerlink\" title=\"1、AsyncTask的使用\"></a>1、AsyncTask的使用</h2><p>使用 <strong>AsyncTask</strong> 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 <strong>ThreadPoolExecutor</strong> 和 <strong>FutureTask</strong>等。<br>AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 <strong>Params</strong>、<strong>Progress</strong> 和 <strong>Result</strong>，分别用来指定参数、进度和结果的值的类型。<br>以及四个重要的方法，分别是 <strong>onPreExecute()</strong>, <strong>doInBackground()</strong>, <strong>onProgressUpdate()</strong> 和 <strong>onPostExecute()</strong>。<br>这四个方法中，除了 <strong>doInBackground()</strong>，其他三个都是运行在<strong>UI线程</strong>的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 <strong>doInBackground()</strong> 运行在后台线程中，用来执行耗时的任务。</p>\n<a id=\"more\"></a>\n<p>一种典型的使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadFilesTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">URL</span>, <span class=\"title\">Integer</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Long <span class=\"title\">doInBackground</span><span class=\"params\">(URL... urls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = urls.length;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> totalSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            totalSize += Downloader.downloadFile(urls[i]);</span><br><span class=\"line\">            publishProgress((<span class=\"keyword\">int</span>) ((i / (<span class=\"keyword\">float</span>) count) * <span class=\"number\">100</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isCancelled()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(Integer... progress)</span> </span>&#123;</span><br><span class=\"line\">        setProgressPercent(progress[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPostExecute</span><span class=\"params\">(Long result)</span> </span>&#123;</span><br><span class=\"line\">        showDialog(<span class=\"string\">\"Downloaded \"</span> + result + <span class=\"string\">\" bytes\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面说 <strong>AsyncTask</strong> 有4个重要的方法，这里我们覆写了3个。<strong>doInBackground()</strong>运行在线程当中，耗时的任务可以放在这里进行；<strong>onProgressUpdate()</strong> 用来处理当任务的进度发生变化时候的逻辑；<strong>onPostExecute()</strong> 用来处理当任务执行完毕之后的逻辑。另外，这里我们还用到了 <strong>publishProgress()</strong> 和 <strong>isCancelled()</strong> 两个方法，分别用来发布任务进度和判断任务是否被取消。<br>然后，我们可以用下面的方式来使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> DownloadFilesTask().execute(url1, url2, url3);</span><br></pre></td></tr></table></figure>\n<p>使用AsyncTask的时候要注意以下几点内容：</p>\n<ol>\n<li>AsyncTask 的类必须在主线程中进行加载，当在4.1之后这个过程会自动进行；</li>\n<li>AsyncTask 的对象必须在主线程中创建；</li>\n<li><strong>execute()</strong>方法必须在UI线程中被调用；</li>\n<li>不要直接调用 <strong>onPreExecute()</strong>, <strong>doInBackground()</strong>, <strong>onProgressUpdate()</strong> 和 <strong>onPostExecute()</strong>；</li>\n<li>一个AsyncTask对象的 <strong>execute()</strong> 方法只能被调用一次；</li>\n</ol>\n<p>Android 1.6 之前，AsyncTask 是<strong>串行执行任务</strong>的；1.6 采用线程池处理<strong>并行任务</strong>；从 3.0 开始，又采用一个线程来串行执行任务。<br>3.0 之后可以用 <strong>executeOnExecutor()</strong> 来并行地执行任务，如果我们希望在3.0之后能并行地执行上面的任务，那么我们应该这样去写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> DownloadFilesTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url1, url2, url3);</span><br></pre></td></tr></table></figure>\n<p>这里的 <strong>AsyncTask.THREAD_POOL_EXECUTOR</strong> 是 AsyncTask 内部定义的一个线程池，我们可以使用它来将 AsyncTask 设置成并行的。</p>\n<h2 id=\"2、AsyncTask源码分析\"><a href=\"#2、AsyncTask源码分析\" class=\"headerlink\" title=\"2、AsyncTask源码分析\"></a>2、AsyncTask源码分析</h2><h3 id=\"2-1-AsyncTask-的初始化过程\"><a href=\"#2-1-AsyncTask-的初始化过程\" class=\"headerlink\" title=\"2.1 AsyncTask 的初始化过程\"></a>2.1 AsyncTask 的初始化过程</h3><p>当初始化一个 AsyncTask 的时候，所有的重载构造方法都会调用下面的这个构造方法。这里做了几件事情：</p>\n<ol>\n<li>初始化一个 Handler 对象 mHandler，该 Handler 用来将消息发送到它所在的线程中，通常使用默认的值，即主线程的 Handler；</li>\n<li>初始化一个 <strong>WorkerRunnable</strong> 对象 <strong>mWorker</strong>。它是一个 <strong>WorkerRunnable</strong> 类型的实例，而 <strong>WorkerRunnable 又继承自 Callable</strong>，因此它是一个可以被执行的对象。我们会把在该对象中回调 doInBackground() 来将我们的业务逻辑放在线程池中执行。</li>\n<li>初始化一个 <strong>FutureTask</strong> 对象 <strong>mFuture</strong>。该对象包装了 <strong>mWorker</strong> 并且当 <strong>mWorker</strong> 执行完毕之后会调用它的 <strong>postResultIfNotInvoked()</strong>方法来通知主线程（不论任务已经执行完毕还是被取消了，都会调用这个方法）。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncTask</span><span class=\"params\">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 初始化用来发送消息的 Handler</span></span><br><span class=\"line\">    mHandler = callbackLooper == <span class=\"keyword\">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class=\"line\">        ? getMainHandler()</span><br><span class=\"line\">        : <span class=\"keyword\">new</span> Handler(callbackLooper);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 封装一个对象用来执行我们的任务</span></span><br><span class=\"line\">    mWorker = <span class=\"keyword\">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            mTaskInvoked.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            Result result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                <span class=\"comment\">// 回调我们的业务逻辑</span></span><br><span class=\"line\">                result = doInBackground(mParams);</span><br><span class=\"line\">                Binder.flushPendingCommands();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable tr) &#123;</span><br><span class=\"line\">                mCancelled.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> tr;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 发送结果给主线程</span></span><br><span class=\"line\">                postResult(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 初始化一个 FutureTask，并且当它执行完毕的时候，会调用 postResultIfNotInvoked 来将消息的执行结果发送到主线程中</span></span><br><span class=\"line\">    mFuture = <span class=\"keyword\">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果任务没有被触发，也要发送一个结果</span></span><br><span class=\"line\">                postResultIfNotInvoked(get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                android.util.Log.w(LOG_TAG, e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"An error occurred while executing doInBackground()\"</span>, e.getCause());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (CancellationException e) &#123;</span><br><span class=\"line\">                postResultIfNotInvoked(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当这样设置完毕之后，我们就可以使用 execute() 方法来开始执行任务了。</p>\n<h3 id=\"2-2-AsyncTask-中任务的串行执行过程\"><a href=\"#2-2-AsyncTask-中任务的串行执行过程\" class=\"headerlink\" title=\"2.2 AsyncTask 中任务的串行执行过程\"></a>2.2 AsyncTask 中任务的串行执行过程</h3><p>我们从 execute() 方法开始分析 AsyncTask:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class=\"title\">execute</span><span class=\"params\">(Params... params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class=\"title\">executeOnExecutor</span><span class=\"params\">(Executor exec, Params... params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStatus != Status.PENDING) &#123; <span class=\"comment\">// 1.判断线程当前的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (mStatus) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> RUNNING: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(...);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FINISHED: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(...);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mStatus = Status.RUNNING;</span><br><span class=\"line\">    onPreExecute();             <span class=\"comment\">// 2.回调生命周期方法</span></span><br><span class=\"line\">    mWorker.mParams = params;   <span class=\"comment\">// 3.赋值给可执行的对象 WorkerRunnable</span></span><br><span class=\"line\">    exec.execute(mFuture);      <span class=\"comment\">// 4.在线程池中执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们调用 <strong>AsyncTask</strong> 的 <strong>execute()</strong> 方法的时候会立即调用它的 <strong>executeOnExecutor()</strong> 方法。这里传入了两个参数，分别是一个 <strong>Executor</strong> 和任务的参数 <strong>params</strong>。从上面我们可以看出，当直接调用 <strong>execute() </strong>方法的时候会使用默认的线程池 <strong>sDefaultExecutor</strong>，而当我们指定了线程池之后，会使用我们指定的线程池来执行任务。<br>在 1 处，会对 <strong>AsyncTask</strong> 当前的状态进行判断，这就对应了前面说的，一个任务只能被执行一次。在 2 处会调用<strong>onPreExecute()</strong>方法，如果我们覆写了该方法，那么它就会在这个时候被调用。在 3 处的操作是在为 <strong>mWorker</strong> 赋值，即把调用 <strong>execute</strong> 方法时传入的参数赋值给了 <strong>mWorker</strong>。接下来，会将 <strong>mFuture</strong> 添加到线程池中执行。<br>当我们不指定任何线程池的时候使用的 <strong>sDefaultExecutor</strong> 是一个串行的线程池，它的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor SERIAL_EXECUTOR = <span class=\"keyword\">new</span> SerialExecutor();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerialExecutor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class=\"keyword\">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class=\"line\">    Runnable mActive;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        mTasks.offer(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 相当于对传入的Runnable进行了一层包装</span></span><br><span class=\"line\">                    r.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 分配下一个任务</span></span><br><span class=\"line\">                    scheduleNext();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前没有正在执行的任务，那么就尝试从队列中取出并执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActive == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            scheduleNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从队列中取任务并使用THREAD_POOL_EXECUTOR执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mActive = mTasks.poll()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出，我们添加到线程池中的任务实际上并没有直接交给线程池来执行，而是对其进行了处理之后才执行的，<strong>SerialExecutor</strong> 通过内部维护了<strong>双端队列</strong>，每当一个 AsyncTask 调用 execute() 方法的时候都会被放在该队列当中进行排队。如果当前没有正在执行的任务，那么就从队列中取一个任务交给 <strong>THREAD_POOL_EXECUTOR</strong> 执行；当一个任务执行完毕之后又会调用 <strong>scheduleNext()</strong> 取下一个任务执行。也就是说，实际上 <strong>sDefaultExecutor</strong> 在这里只是起了一个任务调度的作用，任务最终还是交给 <strong>THREAD_POOL_EXECUTOR</strong> 执行的。<br>这里的<strong>THREAD_POOL_EXECUTOR</strong>也是一个线程池，它在静态代码块中被初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用指定的参数创建一个线程池</span></span><br><span class=\"line\">    ThreadPoolExecutor threadPoolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class=\"line\">            sPoolWorkQueue, sThreadFactory);</span><br><span class=\"line\">    threadPoolExecutor.allowCoreThreadTimeOut(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以直接将这个静态的线程池作为我们任务执行的线程池而不是放在上面的队列中被串行地执行。</p>\n<h3 id=\"2-3-将任务执行的结果发送到其他线程\"><a href=\"#2-3-将任务执行的结果发送到其他线程\" class=\"headerlink\" title=\"2.3 将任务执行的结果发送到其他线程\"></a>2.3 将任务执行的结果发送到其他线程</h3><p>上面的 <strong>WorkerRunnable</strong> 中已经用到了 <strong>postResult</strong> 方法，它用来将任务执行的结果发送给 Handler：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Result <span class=\"title\">postResult</span><span class=\"params\">(Result result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, <span class=\"keyword\">new</span> AsyncTaskResult&lt;Result&gt;(<span class=\"keyword\">this</span>, result));</span><br><span class=\"line\">    message.sendToTarget();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>mHandler</strong> 会在创建 <strong>AsyncTask</strong> 的时候初始化。我们可以通过 AsyncTask 的构造方法传入 <strong>Handler</strong> 和 <strong>Looper</strong> 来指定该对象所在的线程。当我们没有指定的时候，会使用 <strong>AsyncTask</strong> 内部的 <strong>InternalHandler</strong> 创建 Handler：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncTask</span><span class=\"params\">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据传入的参数创建Handler对象</span></span><br><span class=\"line\">    mHandler = callbackLooper == <span class=\"keyword\">null</span> || callbackLooper == Looper.getMainLooper() </span><br><span class=\"line\">        ? getMainHandler() : <span class=\"keyword\">new</span> Handler(callbackLooper);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Handler <span class=\"title\">getMainHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (AsyncTask.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sHandler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用 InternalHandler 创建对象</span></span><br><span class=\"line\">            sHandler = <span class=\"keyword\">new</span> InternalHandler(Looper.getMainLooper());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AsyncTask 内部定义 的Handler 类型</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InternalHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InternalHandler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class=\"line\">        <span class=\"comment\">// 根据传入的消息类型进行处理</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MESSAGE_POST_RESULT: result.mTask.finish(result.mData[<span class=\"number\">0</span>]); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><p>上面我们梳理了 AsyncTask 的大致过程，我们来梳理下：<br>每当我们实例化一个 AsyncTask 的时候都会在内部封装成一个 Runnable 对象，该对象可以直接放在线程池中执行。这里存在两个线程池，一个是 SerialExecutor 一个是 THREAD_POOL_EXECUTOR，前者主要用来进行任务调度，即把交给线程的任务放在队列中进行排队执行，而时机上所有的任务都是在后者中执行完成的。这个两个线程池都是静态的字段，所以它们对应于整个类的。也就是说，当使用默认的线程池的时候，实例化的 AsyncTask 会一个个地，按照加入到队列中的顺序依次执行。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android-源码分析之-AsyncTask-源码分析\"><a href=\"#Android-源码分析之-AsyncTask-源码分析\" class=\"headerlink\" title=\"Android 源码分析之 AsyncTask 源码分析\"></a>Android 源码分析之 AsyncTask 源码分析</h1><h2 id=\"1、AsyncTask的使用\"><a href=\"#1、AsyncTask的使用\" class=\"headerlink\" title=\"1、AsyncTask的使用\"></a>1、AsyncTask的使用</h2><p>使用 <strong>AsyncTask</strong> 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 <strong>ThreadPoolExecutor</strong> 和 <strong>FutureTask</strong>等。<br>AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 <strong>Params</strong>、<strong>Progress</strong> 和 <strong>Result</strong>，分别用来指定参数、进度和结果的值的类型。<br>以及四个重要的方法，分别是 <strong>onPreExecute()</strong>, <strong>doInBackground()</strong>, <strong>onProgressUpdate()</strong> 和 <strong>onPostExecute()</strong>。<br>这四个方法中，除了 <strong>doInBackground()</strong>，其他三个都是运行在<strong>UI线程</strong>的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 <strong>doInBackground()</strong> 运行在后台线程中，用来执行耗时的任务。</p>","more":"<p>一种典型的使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadFilesTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">URL</span>, <span class=\"title\">Integer</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Long <span class=\"title\">doInBackground</span><span class=\"params\">(URL... urls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = urls.length;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> totalSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            totalSize += Downloader.downloadFile(urls[i]);</span><br><span class=\"line\">            publishProgress((<span class=\"keyword\">int</span>) ((i / (<span class=\"keyword\">float</span>) count) * <span class=\"number\">100</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isCancelled()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(Integer... progress)</span> </span>&#123;</span><br><span class=\"line\">        setProgressPercent(progress[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPostExecute</span><span class=\"params\">(Long result)</span> </span>&#123;</span><br><span class=\"line\">        showDialog(<span class=\"string\">\"Downloaded \"</span> + result + <span class=\"string\">\" bytes\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面说 <strong>AsyncTask</strong> 有4个重要的方法，这里我们覆写了3个。<strong>doInBackground()</strong>运行在线程当中，耗时的任务可以放在这里进行；<strong>onProgressUpdate()</strong> 用来处理当任务的进度发生变化时候的逻辑；<strong>onPostExecute()</strong> 用来处理当任务执行完毕之后的逻辑。另外，这里我们还用到了 <strong>publishProgress()</strong> 和 <strong>isCancelled()</strong> 两个方法，分别用来发布任务进度和判断任务是否被取消。<br>然后，我们可以用下面的方式来使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> DownloadFilesTask().execute(url1, url2, url3);</span><br></pre></td></tr></table></figure>\n<p>使用AsyncTask的时候要注意以下几点内容：</p>\n<ol>\n<li>AsyncTask 的类必须在主线程中进行加载，当在4.1之后这个过程会自动进行；</li>\n<li>AsyncTask 的对象必须在主线程中创建；</li>\n<li><strong>execute()</strong>方法必须在UI线程中被调用；</li>\n<li>不要直接调用 <strong>onPreExecute()</strong>, <strong>doInBackground()</strong>, <strong>onProgressUpdate()</strong> 和 <strong>onPostExecute()</strong>；</li>\n<li>一个AsyncTask对象的 <strong>execute()</strong> 方法只能被调用一次；</li>\n</ol>\n<p>Android 1.6 之前，AsyncTask 是<strong>串行执行任务</strong>的；1.6 采用线程池处理<strong>并行任务</strong>；从 3.0 开始，又采用一个线程来串行执行任务。<br>3.0 之后可以用 <strong>executeOnExecutor()</strong> 来并行地执行任务，如果我们希望在3.0之后能并行地执行上面的任务，那么我们应该这样去写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> DownloadFilesTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url1, url2, url3);</span><br></pre></td></tr></table></figure>\n<p>这里的 <strong>AsyncTask.THREAD_POOL_EXECUTOR</strong> 是 AsyncTask 内部定义的一个线程池，我们可以使用它来将 AsyncTask 设置成并行的。</p>\n<h2 id=\"2、AsyncTask源码分析\"><a href=\"#2、AsyncTask源码分析\" class=\"headerlink\" title=\"2、AsyncTask源码分析\"></a>2、AsyncTask源码分析</h2><h3 id=\"2-1-AsyncTask-的初始化过程\"><a href=\"#2-1-AsyncTask-的初始化过程\" class=\"headerlink\" title=\"2.1 AsyncTask 的初始化过程\"></a>2.1 AsyncTask 的初始化过程</h3><p>当初始化一个 AsyncTask 的时候，所有的重载构造方法都会调用下面的这个构造方法。这里做了几件事情：</p>\n<ol>\n<li>初始化一个 Handler 对象 mHandler，该 Handler 用来将消息发送到它所在的线程中，通常使用默认的值，即主线程的 Handler；</li>\n<li>初始化一个 <strong>WorkerRunnable</strong> 对象 <strong>mWorker</strong>。它是一个 <strong>WorkerRunnable</strong> 类型的实例，而 <strong>WorkerRunnable 又继承自 Callable</strong>，因此它是一个可以被执行的对象。我们会把在该对象中回调 doInBackground() 来将我们的业务逻辑放在线程池中执行。</li>\n<li>初始化一个 <strong>FutureTask</strong> 对象 <strong>mFuture</strong>。该对象包装了 <strong>mWorker</strong> 并且当 <strong>mWorker</strong> 执行完毕之后会调用它的 <strong>postResultIfNotInvoked()</strong>方法来通知主线程（不论任务已经执行完毕还是被取消了，都会调用这个方法）。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncTask</span><span class=\"params\">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 初始化用来发送消息的 Handler</span></span><br><span class=\"line\">    mHandler = callbackLooper == <span class=\"keyword\">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class=\"line\">        ? getMainHandler()</span><br><span class=\"line\">        : <span class=\"keyword\">new</span> Handler(callbackLooper);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 封装一个对象用来执行我们的任务</span></span><br><span class=\"line\">    mWorker = <span class=\"keyword\">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            mTaskInvoked.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            Result result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                <span class=\"comment\">// 回调我们的业务逻辑</span></span><br><span class=\"line\">                result = doInBackground(mParams);</span><br><span class=\"line\">                Binder.flushPendingCommands();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable tr) &#123;</span><br><span class=\"line\">                mCancelled.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> tr;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 发送结果给主线程</span></span><br><span class=\"line\">                postResult(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 初始化一个 FutureTask，并且当它执行完毕的时候，会调用 postResultIfNotInvoked 来将消息的执行结果发送到主线程中</span></span><br><span class=\"line\">    mFuture = <span class=\"keyword\">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果任务没有被触发，也要发送一个结果</span></span><br><span class=\"line\">                postResultIfNotInvoked(get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                android.util.Log.w(LOG_TAG, e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"An error occurred while executing doInBackground()\"</span>, e.getCause());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (CancellationException e) &#123;</span><br><span class=\"line\">                postResultIfNotInvoked(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当这样设置完毕之后，我们就可以使用 execute() 方法来开始执行任务了。</p>\n<h3 id=\"2-2-AsyncTask-中任务的串行执行过程\"><a href=\"#2-2-AsyncTask-中任务的串行执行过程\" class=\"headerlink\" title=\"2.2 AsyncTask 中任务的串行执行过程\"></a>2.2 AsyncTask 中任务的串行执行过程</h3><p>我们从 execute() 方法开始分析 AsyncTask:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class=\"title\">execute</span><span class=\"params\">(Params... params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class=\"title\">executeOnExecutor</span><span class=\"params\">(Executor exec, Params... params)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mStatus != Status.PENDING) &#123; <span class=\"comment\">// 1.判断线程当前的状态</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (mStatus) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> RUNNING: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(...);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FINISHED: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(...);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mStatus = Status.RUNNING;</span><br><span class=\"line\">    onPreExecute();             <span class=\"comment\">// 2.回调生命周期方法</span></span><br><span class=\"line\">    mWorker.mParams = params;   <span class=\"comment\">// 3.赋值给可执行的对象 WorkerRunnable</span></span><br><span class=\"line\">    exec.execute(mFuture);      <span class=\"comment\">// 4.在线程池中执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们调用 <strong>AsyncTask</strong> 的 <strong>execute()</strong> 方法的时候会立即调用它的 <strong>executeOnExecutor()</strong> 方法。这里传入了两个参数，分别是一个 <strong>Executor</strong> 和任务的参数 <strong>params</strong>。从上面我们可以看出，当直接调用 <strong>execute() </strong>方法的时候会使用默认的线程池 <strong>sDefaultExecutor</strong>，而当我们指定了线程池之后，会使用我们指定的线程池来执行任务。<br>在 1 处，会对 <strong>AsyncTask</strong> 当前的状态进行判断，这就对应了前面说的，一个任务只能被执行一次。在 2 处会调用<strong>onPreExecute()</strong>方法，如果我们覆写了该方法，那么它就会在这个时候被调用。在 3 处的操作是在为 <strong>mWorker</strong> 赋值，即把调用 <strong>execute</strong> 方法时传入的参数赋值给了 <strong>mWorker</strong>。接下来，会将 <strong>mFuture</strong> 添加到线程池中执行。<br>当我们不指定任何线程池的时候使用的 <strong>sDefaultExecutor</strong> 是一个串行的线程池，它的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor SERIAL_EXECUTOR = <span class=\"keyword\">new</span> SerialExecutor();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerialExecutor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class=\"keyword\">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class=\"line\">    Runnable mActive;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        mTasks.offer(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 相当于对传入的Runnable进行了一层包装</span></span><br><span class=\"line\">                    r.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 分配下一个任务</span></span><br><span class=\"line\">                    scheduleNext();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前没有正在执行的任务，那么就尝试从队列中取出并执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActive == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            scheduleNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从队列中取任务并使用THREAD_POOL_EXECUTOR执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mActive = mTasks.poll()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出，我们添加到线程池中的任务实际上并没有直接交给线程池来执行，而是对其进行了处理之后才执行的，<strong>SerialExecutor</strong> 通过内部维护了<strong>双端队列</strong>，每当一个 AsyncTask 调用 execute() 方法的时候都会被放在该队列当中进行排队。如果当前没有正在执行的任务，那么就从队列中取一个任务交给 <strong>THREAD_POOL_EXECUTOR</strong> 执行；当一个任务执行完毕之后又会调用 <strong>scheduleNext()</strong> 取下一个任务执行。也就是说，实际上 <strong>sDefaultExecutor</strong> 在这里只是起了一个任务调度的作用，任务最终还是交给 <strong>THREAD_POOL_EXECUTOR</strong> 执行的。<br>这里的<strong>THREAD_POOL_EXECUTOR</strong>也是一个线程池，它在静态代码块中被初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用指定的参数创建一个线程池</span></span><br><span class=\"line\">    ThreadPoolExecutor threadPoolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class=\"line\">            sPoolWorkQueue, sThreadFactory);</span><br><span class=\"line\">    threadPoolExecutor.allowCoreThreadTimeOut(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以直接将这个静态的线程池作为我们任务执行的线程池而不是放在上面的队列中被串行地执行。</p>\n<h3 id=\"2-3-将任务执行的结果发送到其他线程\"><a href=\"#2-3-将任务执行的结果发送到其他线程\" class=\"headerlink\" title=\"2.3 将任务执行的结果发送到其他线程\"></a>2.3 将任务执行的结果发送到其他线程</h3><p>上面的 <strong>WorkerRunnable</strong> 中已经用到了 <strong>postResult</strong> 方法，它用来将任务执行的结果发送给 Handler：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Result <span class=\"title\">postResult</span><span class=\"params\">(Result result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, <span class=\"keyword\">new</span> AsyncTaskResult&lt;Result&gt;(<span class=\"keyword\">this</span>, result));</span><br><span class=\"line\">    message.sendToTarget();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>mHandler</strong> 会在创建 <strong>AsyncTask</strong> 的时候初始化。我们可以通过 AsyncTask 的构造方法传入 <strong>Handler</strong> 和 <strong>Looper</strong> 来指定该对象所在的线程。当我们没有指定的时候，会使用 <strong>AsyncTask</strong> 内部的 <strong>InternalHandler</strong> 创建 Handler：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handler mHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncTask</span><span class=\"params\">(@Nullable Looper callbackLooper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据传入的参数创建Handler对象</span></span><br><span class=\"line\">    mHandler = callbackLooper == <span class=\"keyword\">null</span> || callbackLooper == Looper.getMainLooper() </span><br><span class=\"line\">        ? getMainHandler() : <span class=\"keyword\">new</span> Handler(callbackLooper);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Handler <span class=\"title\">getMainHandler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (AsyncTask.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sHandler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用 InternalHandler 创建对象</span></span><br><span class=\"line\">            sHandler = <span class=\"keyword\">new</span> InternalHandler(Looper.getMainLooper());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AsyncTask 内部定义 的Handler 类型</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InternalHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InternalHandler</span><span class=\"params\">(Looper looper)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(looper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class=\"line\">        <span class=\"comment\">// 根据传入的消息类型进行处理</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MESSAGE_POST_RESULT: result.mTask.finish(result.mData[<span class=\"number\">0</span>]); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><p>上面我们梳理了 AsyncTask 的大致过程，我们来梳理下：<br>每当我们实例化一个 AsyncTask 的时候都会在内部封装成一个 Runnable 对象，该对象可以直接放在线程池中执行。这里存在两个线程池，一个是 SerialExecutor 一个是 THREAD_POOL_EXECUTOR，前者主要用来进行任务调度，即把交给线程的任务放在队列中进行排队执行，而时机上所有的任务都是在后者中执行完成的。这个两个线程池都是静态的字段，所以它们对应于整个类的。也就是说，当使用默认的线程池的时候，实例化的 AsyncTask 会一个个地，按照加入到队列中的顺序依次执行。</p>"},{"title":"ThreadLocal 源码深入分析","date":"2019-03-01T03:01:49.000Z","_content":"\n# ThreadLocal 源码深入分析\n\n以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～\n\n`ThreadLocal` 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 `GC`。`ThreadLocal` 相当于提供了一种线程隔离，将变量与线程相绑定。`ThreadLocal` 通常定义为 `private static` 类型。\n\n\n假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，`Thread作为key`，变量作为`value`。事实上，JDK 中确实使用了类似 `Map` 的结构存储变量，但不是像我们想的那样。下面我们来探究`OpenJDK 1.8`中`ThreadLocal`的实现。\n\n<!-- more -->\n## 初探 ThreadLocal\n我们从 `ThreadLocal` 的几个成员变量入手：\n\n\n```JAVA\nprivate final int threadLocalHashCode = nextHashCode();\n/**\n * The next hash code to be given out. Updated atomically. Starts at\n * zero.\n */\nprivate static AtomicInteger nextHashCode =\n    new AtomicInteger();\n/**\n * The difference between successively generated hash codes - turns\n * implicit sequential thread-local IDs into near-optimally spread\n * multiplicative hash values for power-of-two-sized tables.\n */\nprivate static final int HASH_INCREMENT = 0x61c88647;\n/**\n * Returns the next hash code.\n */\nprivate static int nextHashCode() {\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\n}\n```\n\n`ThreadLocal` 通过 `threadLocalHashCode` 来标识每一个 `ThreadLocal` 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(这个数的原理没有探究)。\n\n再看 set 方法：\n\n```JAVA\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n```\n\n可以看到通过`Thread.currentThread()`方法获取了当前的线程引用，并传给了`getMap(Thread)`方法获取一个`ThreadLocalMap`的实例。我们继续跟进`getMap(Thread)`方法：\n\n\n```JAVA\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n可以看到`getMap(Thread)`方法直接返回`Thread`实例的成员变量`threadLocals`。它的定义在`Thread`内部，访问级别为`package`级别：\n\n```JAVA\n/* ThreadLocal values pertaining to this thread. This map is maintained\n * by the ThreadLocal class. */\nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n到了这里，我们可以看出，每个`Thread`里面都有一个`ThreadLocal.ThreadLocalMap`成员变量，也就是说每个线程通过`ThreadLocal.ThreadLocalMap`与`ThreadLocal`相绑定，这样可以确保每个线程访问到的`thread-local variable`都是本线程的。\n\n我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals。\n\nThreadLocal#createMap方法的源码如下：\n\n```JAVA\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n下面我们探究一下 ThreadLocalMap 的实现。\n\n### ThreadLocalMap\nThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下：\n![ThreadLocalMap](https://ws1.sinaimg.cn/large/007lnl1egy1g0n3taxdfxj30cc0fd40a.jpg)\n\n可以看到ThreadLocalMap有一个常量和三个成员变量：\n\n\n```JAVA\n/**\n * The initial capacity -- MUST be a power of two.\n */\nprivate static final int INITIAL_CAPACITY = 16;\n/**\n * The table, resized as necessary.\n * table.length MUST always be a power of two.\n */\nprivate Entry[] table;\n/**\n * The number of entries in the table.\n */\nprivate int size = 0;\n/**\n * The next size value at which to resize.\n */\nprivate int threshold; // Default to 0\n```\n\n其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。\n\nEntry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下：\n\n\n```JAVA\n/**\n * The entries in this hash map extend WeakReference, using\n * its main ref field as the key (which is always a\n * ThreadLocal object).  Note that null keys (i.e. entry.get()\n * == null) mean that the key is no longer referenced, so the\n * entry can be expunged from table.  Such entries are referred to\n * as \"stale entries\" in the code that follows.\n */\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\nEntry类继承了WeakReference<ThreadLocal<?>>，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。\n\nThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue)：\n\n\n```JAVA\n/**\n * Construct a new map initially containing (firstKey, firstValue).\n * ThreadLocalMaps are constructed lazily, so we only create\n * one when we have at least one entry to put in it.\n */\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    table = new Entry[INITIAL_CAPACITY];\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    setThreshold(INITIAL_CAPACITY);\n}\n```\n\n构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。\n\n注意一个细节，计算hash的时候里面采用了hashCode & (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 2的指数，因为这可以使得hash发生冲突的次数减小。\n\n接下来我们来看ThreadLocalMap#set方法的实现：\n\n\n```JAVA\n/**\n * Set the value associated with key.\n *\n * @param key the thread local object\n * @param value the value to be set\n */\nprivate void set(ThreadLocal<?> key, Object value) {\n    // We don't use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n\n如果冲突了，就会通过nextIndex方法再次计算哈希值：\n\n\n```JAVA\n/**\n * Increment i modulo len.\n */\nprivate static int nextIndex(int i, int len) {\n    return ((i + 1 < len) ? i + 1 : 0);\n}\n```\n\n到这里，我们看到 ThreadLocalMap 解决冲突的方法是 线性探测法（不断加 1），而不是 HashMap 的 链地址法，这一点也能从 Entry 的结构上推断出来。\n\n如果entry里对应的key为null的话，表明此entry为staled entry，就将其替换为当前的key和value：\n\n\n```JAVA\n/**\n * Replace a stale entry encountered during a set operation\n * with an entry for the specified key.  The value passed in\n * the value parameter is stored in the entry, whether or not\n * an entry already exists for the specified key.\n *\n * As a side effect, this method expunges all stale entries in the\n * \"run\" containing the stale entry.  (A run is a sequence of entries\n * between two null slots.)\n *\n * @param  key the key\n * @param  value the value to be associated with key\n * @param  staleSlot index of the first stale entry encountered while\n *         searching for key.\n */\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                               int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n    // Back up to check for prior stale entry in current run.\n    // We clean out whole runs at a time to avoid continual\n    // incremental rehashing due to garbage collector freeing\n    // up refs in bunches (i.e., whenever the collector runs).\n    int slotToExpunge = staleSlot;\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n    // Find either the key or trailing null slot of run, whichever\n    // occurs first\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // If we find key, then we need to swap it\n        // with the stale entry to maintain hash table order.\n        // The newly stale slot, or any other stale slot\n        // encountered above it, can then be sent to expungeStaleEntry\n        // to remove or rehash all of the other entries in run.\n        if (k == key) {\n            e.value = value;\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n            // Start expunge at preceding stale entry if it exists\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n        // If we didn't find stale entry on backward scan, the\n        // first stale entry seen while scanning for key is the\n        // first still present in the run.\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n    // If key not found, put new entry in stale slot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n    // If there are any other stale entries in run, expunge them\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n\n具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。\n\n若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）：\n\n\n```JAVA\n/**\n * Heuristically scan some cells looking for stale entries.\n * This is invoked when either a new element is added, or\n * another stale one has been expunged. It performs a\n * logarithmic number of scans, as a balance between no\n * scanning (fast but retains garbage) and a number of scans\n * proportional to number of elements, that would find all\n * garbage but would cause some insertions to take O(n) time.\n *\n * @param i a position known NOT to hold a stale entry. The\n * scan starts at the element after i.\n *\n * @param n scan control: {@code log2(n)} cells are scanned,\n * unless a stale entry is found, in which case\n * {@code log2(table.length)-1} additional cells are scanned.\n * When called from insertions, this parameter is the number\n * of elements, but when from replaceStaleEntry, it is the\n * table length. (Note: all this could be changed to be either\n * more or less aggressive by weighting n instead of just\n * using straight log n. But this version is simple, fast, and\n * seems to work well.)\n *\n * @return true if any stale entries have been removed.\n */\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n\n一旦发现一个位置对应的 Entry 所持有的 ThreadLocal 弱引用为null，就会把此位置当做 staleSlot 并调用 expungeStaleEntry 方法进行整理 (rehashing) 的操作：\n\n\n```JAVA\n/**\n * Expunge a stale entry by rehashing any possibly colliding entries\n * lying between staleSlot and the next null slot.  This also expunges\n * any other stale entries encountered before the trailing null.  See\n * Knuth, Section 6.4\n *\n * @param staleSlot index of slot known to have null key\n * @return the index of the next null slot after staleSlot\n * (all between staleSlot and this slot will have been checked\n * for expunging).\n */\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n只要没有清理任何的 stale entries 并且 size 达到阈值的时候（即 table 已满，所有元素都可用），都会触发rehashing：\n\n\n```JAVA\n/**\n * Re-pack and/or re-size the table. First scan the entire\n * table removing stale entries. If this doesn't sufficiently\n * shrink the size of the table, double the table size.\n */\nprivate void rehash() {\n    expungeStaleEntries();\n    // Use lower threshold for doubling to avoid hysteresis\n    if (size >= threshold - threshold / 4)\n        resize();\n}\n/**\n * Expunge all stale entries in the table.\n */\nprivate void expungeStaleEntries() {\n    Entry[] tab = table;\n    int len = tab.length;\n    for (int j = 0; j < len; j++) {\n        Entry e = tab[j];\n        if (e != null && e.get() == null)\n            expungeStaleEntry(j);\n    }\n}\n```\n\nrehash 操作会执行一次全表的扫描清理工作，并在 size 大于等于 threshold 的四分之三时进行 resize。但注意在 setThreshold 的时候又取了三分之二：\n\n```JAVA\n/**\n * Set the resize threshold to maintain at worst a 2/3 load factor.\n */\nprivate void setThreshold(int len) {\n    threshold = len * 2 / 3;\n}\n```\n\n因此 ThreadLocalMap 的实际 load factor 为 3/4 * 2/3 = 0.5。\n\n我们继续看 getEntry 的源码：\n\n\n```JAVA\n/**\n * Get the entry associated with key.  This method\n * itself handles only the fast path: a direct hit of existing\n * key. It otherwise relays to getEntryAfterMiss.  This is\n * designed to maximize performance for direct hits, in part\n * by making this method readily inlinable.\n *\n * @param  key the thread local object\n * @return the entry associated with key, or null if no such\n */\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n/**\n * Version of getEntry method for use when key is not found in\n * its direct hash slot.\n *\n * @param  key the thread local object\n * @param  i the table index for key's hash code\n * @param  e the entry at table[i]\n * @return the entry associated with key, or null if no such\n */\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用getEntryAfterMiss方法，根据线性探测法继续查找，直到找到或对应entry为null，并返回。\n\nThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法：\n\n```JAVA\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n```\n\nremove 方法的思想类似，直接放源码：\n\n```JAVA\n/**\n * Remove the entry for key.\n */\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n```\nremove的时候同样也会调用expungeStaleEntry方法执行清理工作。\n\n\n## 总结\n每个 Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的 ThreadLocal 被及时回收，不会造成内存泄露，又可以提升性能。假如我们把 ThreadLocalMap 做成一个 Map<t extends Thread, ?> 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将 ThreadLocalMap 与线程相绑定的实现，完美地解决了这个问题。\n\n总结一下什么时候无用的 Entry 会被清理：\n\nThread 结束的时候\n插入元素时，发现 staled entry，则会进行替换并清理\n插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容\n调用 ThreadLocalMap 的 remove 方法或set(null) 时\n尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。\n\n特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 remove 了。\n\n总的来说，对于多线程资源共享的问题，同步机制采用了 以时间换空间 的方式，而 ThreadLocal 则采用了 以空间换时间 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。\n","source":"_posts/ThradLocalCodeRead1551409309746.md","raw":"---\ntitle: ThreadLocal 源码深入分析\ntags: [ThreadLocal]\ncategories: [Java]\ndate: 2019-03-01 11:01:49\n---\n\n# ThreadLocal 源码深入分析\n\n以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～\n\n`ThreadLocal` 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 `GC`。`ThreadLocal` 相当于提供了一种线程隔离，将变量与线程相绑定。`ThreadLocal` 通常定义为 `private static` 类型。\n\n\n假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，`Thread作为key`，变量作为`value`。事实上，JDK 中确实使用了类似 `Map` 的结构存储变量，但不是像我们想的那样。下面我们来探究`OpenJDK 1.8`中`ThreadLocal`的实现。\n\n<!-- more -->\n## 初探 ThreadLocal\n我们从 `ThreadLocal` 的几个成员变量入手：\n\n\n```JAVA\nprivate final int threadLocalHashCode = nextHashCode();\n/**\n * The next hash code to be given out. Updated atomically. Starts at\n * zero.\n */\nprivate static AtomicInteger nextHashCode =\n    new AtomicInteger();\n/**\n * The difference between successively generated hash codes - turns\n * implicit sequential thread-local IDs into near-optimally spread\n * multiplicative hash values for power-of-two-sized tables.\n */\nprivate static final int HASH_INCREMENT = 0x61c88647;\n/**\n * Returns the next hash code.\n */\nprivate static int nextHashCode() {\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\n}\n```\n\n`ThreadLocal` 通过 `threadLocalHashCode` 来标识每一个 `ThreadLocal` 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(这个数的原理没有探究)。\n\n再看 set 方法：\n\n```JAVA\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n```\n\n可以看到通过`Thread.currentThread()`方法获取了当前的线程引用，并传给了`getMap(Thread)`方法获取一个`ThreadLocalMap`的实例。我们继续跟进`getMap(Thread)`方法：\n\n\n```JAVA\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n可以看到`getMap(Thread)`方法直接返回`Thread`实例的成员变量`threadLocals`。它的定义在`Thread`内部，访问级别为`package`级别：\n\n```JAVA\n/* ThreadLocal values pertaining to this thread. This map is maintained\n * by the ThreadLocal class. */\nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n到了这里，我们可以看出，每个`Thread`里面都有一个`ThreadLocal.ThreadLocalMap`成员变量，也就是说每个线程通过`ThreadLocal.ThreadLocalMap`与`ThreadLocal`相绑定，这样可以确保每个线程访问到的`thread-local variable`都是本线程的。\n\n我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals。\n\nThreadLocal#createMap方法的源码如下：\n\n```JAVA\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n下面我们探究一下 ThreadLocalMap 的实现。\n\n### ThreadLocalMap\nThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下：\n![ThreadLocalMap](https://ws1.sinaimg.cn/large/007lnl1egy1g0n3taxdfxj30cc0fd40a.jpg)\n\n可以看到ThreadLocalMap有一个常量和三个成员变量：\n\n\n```JAVA\n/**\n * The initial capacity -- MUST be a power of two.\n */\nprivate static final int INITIAL_CAPACITY = 16;\n/**\n * The table, resized as necessary.\n * table.length MUST always be a power of two.\n */\nprivate Entry[] table;\n/**\n * The number of entries in the table.\n */\nprivate int size = 0;\n/**\n * The next size value at which to resize.\n */\nprivate int threshold; // Default to 0\n```\n\n其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。\n\nEntry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下：\n\n\n```JAVA\n/**\n * The entries in this hash map extend WeakReference, using\n * its main ref field as the key (which is always a\n * ThreadLocal object).  Note that null keys (i.e. entry.get()\n * == null) mean that the key is no longer referenced, so the\n * entry can be expunged from table.  Such entries are referred to\n * as \"stale entries\" in the code that follows.\n */\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\nEntry类继承了WeakReference<ThreadLocal<?>>，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。\n\nThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue)：\n\n\n```JAVA\n/**\n * Construct a new map initially containing (firstKey, firstValue).\n * ThreadLocalMaps are constructed lazily, so we only create\n * one when we have at least one entry to put in it.\n */\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    table = new Entry[INITIAL_CAPACITY];\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    setThreshold(INITIAL_CAPACITY);\n}\n```\n\n构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。\n\n注意一个细节，计算hash的时候里面采用了hashCode & (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 2的指数，因为这可以使得hash发生冲突的次数减小。\n\n接下来我们来看ThreadLocalMap#set方法的实现：\n\n\n```JAVA\n/**\n * Set the value associated with key.\n *\n * @param key the thread local object\n * @param value the value to be set\n */\nprivate void set(ThreadLocal<?> key, Object value) {\n    // We don't use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n```\n\n如果冲突了，就会通过nextIndex方法再次计算哈希值：\n\n\n```JAVA\n/**\n * Increment i modulo len.\n */\nprivate static int nextIndex(int i, int len) {\n    return ((i + 1 < len) ? i + 1 : 0);\n}\n```\n\n到这里，我们看到 ThreadLocalMap 解决冲突的方法是 线性探测法（不断加 1），而不是 HashMap 的 链地址法，这一点也能从 Entry 的结构上推断出来。\n\n如果entry里对应的key为null的话，表明此entry为staled entry，就将其替换为当前的key和value：\n\n\n```JAVA\n/**\n * Replace a stale entry encountered during a set operation\n * with an entry for the specified key.  The value passed in\n * the value parameter is stored in the entry, whether or not\n * an entry already exists for the specified key.\n *\n * As a side effect, this method expunges all stale entries in the\n * \"run\" containing the stale entry.  (A run is a sequence of entries\n * between two null slots.)\n *\n * @param  key the key\n * @param  value the value to be associated with key\n * @param  staleSlot index of the first stale entry encountered while\n *         searching for key.\n */\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                               int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n    // Back up to check for prior stale entry in current run.\n    // We clean out whole runs at a time to avoid continual\n    // incremental rehashing due to garbage collector freeing\n    // up refs in bunches (i.e., whenever the collector runs).\n    int slotToExpunge = staleSlot;\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n    // Find either the key or trailing null slot of run, whichever\n    // occurs first\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // If we find key, then we need to swap it\n        // with the stale entry to maintain hash table order.\n        // The newly stale slot, or any other stale slot\n        // encountered above it, can then be sent to expungeStaleEntry\n        // to remove or rehash all of the other entries in run.\n        if (k == key) {\n            e.value = value;\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n            // Start expunge at preceding stale entry if it exists\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n        // If we didn't find stale entry on backward scan, the\n        // first stale entry seen while scanning for key is the\n        // first still present in the run.\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n    // If key not found, put new entry in stale slot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n    // If there are any other stale entries in run, expunge them\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n\n具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。\n\n若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）：\n\n\n```JAVA\n/**\n * Heuristically scan some cells looking for stale entries.\n * This is invoked when either a new element is added, or\n * another stale one has been expunged. It performs a\n * logarithmic number of scans, as a balance between no\n * scanning (fast but retains garbage) and a number of scans\n * proportional to number of elements, that would find all\n * garbage but would cause some insertions to take O(n) time.\n *\n * @param i a position known NOT to hold a stale entry. The\n * scan starts at the element after i.\n *\n * @param n scan control: {@code log2(n)} cells are scanned,\n * unless a stale entry is found, in which case\n * {@code log2(table.length)-1} additional cells are scanned.\n * When called from insertions, this parameter is the number\n * of elements, but when from replaceStaleEntry, it is the\n * table length. (Note: all this could be changed to be either\n * more or less aggressive by weighting n instead of just\n * using straight log n. But this version is simple, fast, and\n * seems to work well.)\n *\n * @return true if any stale entries have been removed.\n */\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n\n一旦发现一个位置对应的 Entry 所持有的 ThreadLocal 弱引用为null，就会把此位置当做 staleSlot 并调用 expungeStaleEntry 方法进行整理 (rehashing) 的操作：\n\n\n```JAVA\n/**\n * Expunge a stale entry by rehashing any possibly colliding entries\n * lying between staleSlot and the next null slot.  This also expunges\n * any other stale entries encountered before the trailing null.  See\n * Knuth, Section 6.4\n *\n * @param staleSlot index of slot known to have null key\n * @return the index of the next null slot after staleSlot\n * (all between staleSlot and this slot will have been checked\n * for expunging).\n */\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n只要没有清理任何的 stale entries 并且 size 达到阈值的时候（即 table 已满，所有元素都可用），都会触发rehashing：\n\n\n```JAVA\n/**\n * Re-pack and/or re-size the table. First scan the entire\n * table removing stale entries. If this doesn't sufficiently\n * shrink the size of the table, double the table size.\n */\nprivate void rehash() {\n    expungeStaleEntries();\n    // Use lower threshold for doubling to avoid hysteresis\n    if (size >= threshold - threshold / 4)\n        resize();\n}\n/**\n * Expunge all stale entries in the table.\n */\nprivate void expungeStaleEntries() {\n    Entry[] tab = table;\n    int len = tab.length;\n    for (int j = 0; j < len; j++) {\n        Entry e = tab[j];\n        if (e != null && e.get() == null)\n            expungeStaleEntry(j);\n    }\n}\n```\n\nrehash 操作会执行一次全表的扫描清理工作，并在 size 大于等于 threshold 的四分之三时进行 resize。但注意在 setThreshold 的时候又取了三分之二：\n\n```JAVA\n/**\n * Set the resize threshold to maintain at worst a 2/3 load factor.\n */\nprivate void setThreshold(int len) {\n    threshold = len * 2 / 3;\n}\n```\n\n因此 ThreadLocalMap 的实际 load factor 为 3/4 * 2/3 = 0.5。\n\n我们继续看 getEntry 的源码：\n\n\n```JAVA\n/**\n * Get the entry associated with key.  This method\n * itself handles only the fast path: a direct hit of existing\n * key. It otherwise relays to getEntryAfterMiss.  This is\n * designed to maximize performance for direct hits, in part\n * by making this method readily inlinable.\n *\n * @param  key the thread local object\n * @return the entry associated with key, or null if no such\n */\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n/**\n * Version of getEntry method for use when key is not found in\n * its direct hash slot.\n *\n * @param  key the thread local object\n * @param  i the table index for key's hash code\n * @param  e the entry at table[i]\n * @return the entry associated with key, or null if no such\n */\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用getEntryAfterMiss方法，根据线性探测法继续查找，直到找到或对应entry为null，并返回。\n\nThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法：\n\n```JAVA\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n```\n\nremove 方法的思想类似，直接放源码：\n\n```JAVA\n/**\n * Remove the entry for key.\n */\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n```\nremove的时候同样也会调用expungeStaleEntry方法执行清理工作。\n\n\n## 总结\n每个 Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的 ThreadLocal 被及时回收，不会造成内存泄露，又可以提升性能。假如我们把 ThreadLocalMap 做成一个 Map<t extends Thread, ?> 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将 ThreadLocalMap 与线程相绑定的实现，完美地解决了这个问题。\n\n总结一下什么时候无用的 Entry 会被清理：\n\nThread 结束的时候\n插入元素时，发现 staled entry，则会进行替换并清理\n插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容\n调用 ThreadLocalMap 的 remove 方法或set(null) 时\n尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。\n\n特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 remove 了。\n\n总的来说，对于多线程资源共享的问题，同步机制采用了 以时间换空间 的方式，而 ThreadLocal 则采用了 以空间换时间 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。\n","slug":"ThradLocalCodeRead1551409309746","published":1,"updated":"2019-03-08T09:25:55.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszuvytu000lqk9ys81ck9r6","content":"<h1 id=\"ThreadLocal-源码深入分析\"><a href=\"#ThreadLocal-源码深入分析\" class=\"headerlink\" title=\"ThreadLocal 源码深入分析\"></a>ThreadLocal 源码深入分析</h1><p>以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～</p>\n<p><code>ThreadLocal</code> 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 <code>GC</code>。<code>ThreadLocal</code> 相当于提供了一种线程隔离，将变量与线程相绑定。<code>ThreadLocal</code> 通常定义为 <code>private static</code> 类型。</p>\n<p>假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，<code>Thread作为key</code>，变量作为<code>value</code>。事实上，JDK 中确实使用了类似 <code>Map</code> 的结构存储变量，但不是像我们想的那样。下面我们来探究<code>OpenJDK 1.8</code>中<code>ThreadLocal</code>的实现。</p>\n<a id=\"more\"></a>\n<h2 id=\"初探-ThreadLocal\"><a href=\"#初探-ThreadLocal\" class=\"headerlink\" title=\"初探 ThreadLocal\"></a>初探 ThreadLocal</h2><p>我们从 <code>ThreadLocal</code> 的几个成员变量入手：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class=\"line\"><span class=\"comment\"> * zero.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger nextHashCode =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The difference between successively generated hash codes - turns</span></span><br><span class=\"line\"><span class=\"comment\"> * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class=\"line\"><span class=\"comment\"> * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_INCREMENT = <span class=\"number\">0x61c88647</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the next hash code.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextHashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ThreadLocal</code> 通过 <code>threadLocalHashCode</code> 来标识每一个 <code>ThreadLocal</code> 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(这个数的原理没有探究)。</p>\n<p>再看 set 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class=\"line\"><span class=\"comment\"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class=\"line\"><span class=\"comment\"> * override this method, relying solely on the &#123;<span class=\"doctag\">@link</span> #initialValue&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * method to set the values of thread-locals.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class=\"line\"><span class=\"comment\"> *        this thread-local.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到通过<code>Thread.currentThread()</code>方法获取了当前的线程引用，并传给了<code>getMap(Thread)</code>方法获取一个<code>ThreadLocalMap</code>的实例。我们继续跟进<code>getMap(Thread)</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>getMap(Thread)</code>方法直接返回<code>Thread</code>实例的成员变量<code>threadLocals</code>。它的定义在<code>Thread</code>内部，访问级别为<code>package</code>级别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\"> * by the ThreadLocal class. */</span></span><br><span class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>到了这里，我们可以看出，每个<code>Thread</code>里面都有一个<code>ThreadLocal.ThreadLocalMap</code>成员变量，也就是说每个线程通过<code>ThreadLocal.ThreadLocalMap</code>与<code>ThreadLocal</code>相绑定，这样可以确保每个线程访问到的<code>thread-local variable</code>都是本线程的。</p>\n<p>我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals。</p>\n<p>ThreadLocal#createMap方法的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们探究一下 ThreadLocalMap 的实现。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0n3taxdfxj30cc0fd40a.jpg\" alt=\"ThreadLocalMap\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ThreadLocalMap</div>\n            </figure></p>\n<p>可以看到ThreadLocalMap有一个常量和三个成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The initial capacity -- MUST be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The table, resized as necessary.</span></span><br><span class=\"line\"><span class=\"comment\"> * table.length MUST always be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The number of entries in the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The next size value at which to resize.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold; <span class=\"comment\">// Default to 0</span></span><br></pre></td></tr></table></figure>\n<p>其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。</p>\n<p>Entry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The entries in this hash map extend WeakReference, using</span></span><br><span class=\"line\"><span class=\"comment\"> * its main ref field as the key (which is always a</span></span><br><span class=\"line\"><span class=\"comment\"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class=\"line\"><span class=\"comment\"> * == null) mean that the key is no longer referenced, so the</span></span><br><span class=\"line\"><span class=\"comment\"> * entry can be expunged from table.  Such entries are referred to</span></span><br><span class=\"line\"><span class=\"comment\"> * as \"stale entries\" in the code that follows.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</p>\n<p>ThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class=\"line\"><span class=\"comment\"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class=\"line\"><span class=\"comment\"> * one when we have at least one entry to put in it.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">    table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">    size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。</p>\n<p>注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 2的指数，因为这可以使得hash发生冲突的次数减小。</p>\n<p>接下来我们来看ThreadLocalMap#set方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set the value associated with key.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to be set</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// We don't use a fast path as with get() because it is at</span></span><br><span class=\"line\">    <span class=\"comment\">// least as common to use set() to create new entries as</span></span><br><span class=\"line\">    <span class=\"comment\">// it is to replace existing ones, in which case, a fast</span></span><br><span class=\"line\">    <span class=\"comment\">// path would fail more often than not.</span></span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            replaceStaleEntry(key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">        rehash();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果冲突了，就会通过nextIndex方法再次计算哈希值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Increment i modulo len.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i + <span class=\"number\">1</span> &lt; len) ? i + <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们看到 ThreadLocalMap 解决冲突的方法是 线性探测法（不断加 1），而不是 HashMap 的 链地址法，这一点也能从 Entry 的结构上推断出来。</p>\n<p>如果entry里对应的key为null的话，表明此entry为staled entry，就将其替换为当前的key和value：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Replace a stale entry encountered during a set operation</span></span><br><span class=\"line\"><span class=\"comment\"> * with an entry for the specified key.  The value passed in</span></span><br><span class=\"line\"><span class=\"comment\"> * the value parameter is stored in the entry, whether or not</span></span><br><span class=\"line\"><span class=\"comment\"> * an entry already exists for the specified key.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * As a side effect, this method expunges all stale entries in the</span></span><br><span class=\"line\"><span class=\"comment\"> * \"run\" containing the stale entry.  (A run is a sequence of entries</span></span><br><span class=\"line\"><span class=\"comment\"> * between two null slots.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  value the value to be associated with key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  staleSlot index of the first stale entry encountered while</span></span><br><span class=\"line\"><span class=\"comment\"> *         searching for key.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceStaleEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"comment\">// Back up to check for prior stale entry in current run.</span></span><br><span class=\"line\">    <span class=\"comment\">// We clean out whole runs at a time to avoid continual</span></span><br><span class=\"line\">    <span class=\"comment\">// incremental rehashing due to garbage collector freeing</span></span><br><span class=\"line\">    <span class=\"comment\">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> slotToExpunge = staleSlot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = prevIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = prevIndex(i, len))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\">    <span class=\"comment\">// Find either the key or trailing null slot of run, whichever</span></span><br><span class=\"line\">    <span class=\"comment\">// occurs first</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"comment\">// If we find key, then we need to swap it</span></span><br><span class=\"line\">        <span class=\"comment\">// with the stale entry to maintain hash table order.</span></span><br><span class=\"line\">        <span class=\"comment\">// The newly stale slot, or any other stale slot</span></span><br><span class=\"line\">        <span class=\"comment\">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class=\"line\">        <span class=\"comment\">// to remove or rehash all of the other entries in run.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            tab[i] = tab[staleSlot];</span><br><span class=\"line\">            tab[staleSlot] = e;</span><br><span class=\"line\">            <span class=\"comment\">// Start expunge at preceding stale entry if it exists</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slotToExpunge == staleSlot)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// If we didn't find stale entry on backward scan, the</span></span><br><span class=\"line\">        <span class=\"comment\">// first stale entry seen while scanning for key is the</span></span><br><span class=\"line\">        <span class=\"comment\">// first still present in the run.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// If key not found, put new entry in stale slot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"comment\">// If there are any other stale entries in run, expunge them</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slotToExpunge != staleSlot)</span><br><span class=\"line\">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。</p>\n<p>若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Heuristically scan some cells looking for stale entries.</span></span><br><span class=\"line\"><span class=\"comment\"> * This is invoked when either a new element is added, or</span></span><br><span class=\"line\"><span class=\"comment\"> * another stale one has been expunged. It performs a</span></span><br><span class=\"line\"><span class=\"comment\"> * logarithmic number of scans, as a balance between no</span></span><br><span class=\"line\"><span class=\"comment\"> * scanning (fast but retains garbage) and a number of scans</span></span><br><span class=\"line\"><span class=\"comment\"> * proportional to number of elements, that would find all</span></span><br><span class=\"line\"><span class=\"comment\"> * garbage but would cause some insertions to take O(n) time.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> i a position known NOT to hold a stale entry. The</span></span><br><span class=\"line\"><span class=\"comment\"> * scan starts at the element after i.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> n scan control: &#123;<span class=\"doctag\">@code</span> log2(n)&#125; cells are scanned,</span></span><br><span class=\"line\"><span class=\"comment\"> * unless a stale entry is found, in which case</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> log2(table.length)-1&#125; additional cells are scanned.</span></span><br><span class=\"line\"><span class=\"comment\"> * When called from insertions, this parameter is the number</span></span><br><span class=\"line\"><span class=\"comment\"> * of elements, but when from replaceStaleEntry, it is the</span></span><br><span class=\"line\"><span class=\"comment\"> * table length. (Note: all this could be changed to be either</span></span><br><span class=\"line\"><span class=\"comment\"> * more or less aggressive by weighting n instead of just</span></span><br><span class=\"line\"><span class=\"comment\"> * using straight log n. But this version is simple, fast, and</span></span><br><span class=\"line\"><span class=\"comment\"> * seems to work well.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if any stale entries have been removed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cleanSomeSlots</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        i = nextIndex(i, len);</span><br><span class=\"line\">        Entry e = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n = len;</span><br><span class=\"line\">            removed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i = expungeStaleEntry(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ( (n &gt;&gt;&gt;= <span class=\"number\">1</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦发现一个位置对应的 Entry 所持有的 ThreadLocal 弱引用为null，就会把此位置当做 staleSlot 并调用 expungeStaleEntry 方法进行整理 (rehashing) 的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class=\"line\"><span class=\"comment\"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class=\"line\"><span class=\"comment\"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class=\"line\"><span class=\"comment\"> * Knuth, Section 6.4</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> staleSlot index of slot known to have null key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the index of the next null slot after staleSlot</span></span><br><span class=\"line\"><span class=\"comment\"> * (all between staleSlot and this slot will have been checked</span></span><br><span class=\"line\"><span class=\"comment\"> * for expunging).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有清理任何的 stale entries 并且 size 达到阈值的时候（即 table 已满，所有元素都可用），都会触发rehashing：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class=\"line\"><span class=\"comment\"> * table removing stale entries. If this doesn't sufficiently</span></span><br><span class=\"line\"><span class=\"comment\"> * shrink the size of the table, double the table size.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\">    <span class=\"comment\">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt;= threshold - threshold / <span class=\"number\">4</span>)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunge all stale entries in the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">        Entry e = tab[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            expungeStaleEntry(j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>rehash 操作会执行一次全表的扫描清理工作，并在 size 大于等于 threshold 的四分之三时进行 resize。但注意在 setThreshold 的时候又取了三分之二：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setThreshold</span><span class=\"params\">(<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    threshold = len * <span class=\"number\">2</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此 ThreadLocalMap 的实际 load factor 为 3/4 * 2/3 = 0.5。</p>\n<p>我们继续看 getEntry 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Get the entry associated with key.  This method</span></span><br><span class=\"line\"><span class=\"comment\"> * itself handles only the fast path: a direct hit of existing</span></span><br><span class=\"line\"><span class=\"comment\"> * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class=\"line\"><span class=\"comment\"> * designed to maximize performance for direct hits, in part</span></span><br><span class=\"line\"><span class=\"comment\"> * by making this method readily inlinable.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the entry associated with key, or null if no such</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Entry e = table[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Version of getEntry method for use when key is not found in</span></span><br><span class=\"line\"><span class=\"comment\"> * its direct hash slot.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  i the table index for key's hash code</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  e the entry at table[i]</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the entry associated with key, or null if no such</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            i = nextIndex(i, len);</span><br><span class=\"line\">        e = tab[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用getEntryAfterMiss方法，根据线性探测法继续查找，直到找到或对应entry为null，并返回。</p>\n<p>ThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove 方法的思想类似，直接放源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove the entry for key.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">            e.clear();</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove的时候同样也会调用expungeStaleEntry方法执行清理工作。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>每个 Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的 ThreadLocal 被及时回收，不会造成内存泄露，又可以提升性能。假如我们把 ThreadLocalMap 做成一个 Map<t extends=\"\" thread,=\"\" ?=\"\"> 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将 ThreadLocalMap 与线程相绑定的实现，完美地解决了这个问题。</t></p>\n<p>总结一下什么时候无用的 Entry 会被清理：</p>\n<p>Thread 结束的时候<br>插入元素时，发现 staled entry，则会进行替换并清理<br>插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容<br>调用 ThreadLocalMap 的 remove 方法或set(null) 时<br>尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。</p>\n<p>特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 remove 了。</p>\n<p>总的来说，对于多线程资源共享的问题，同步机制采用了 以时间换空间 的方式，而 ThreadLocal 则采用了 以空间换时间 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"ThreadLocal-源码深入分析\"><a href=\"#ThreadLocal-源码深入分析\" class=\"headerlink\" title=\"ThreadLocal 源码深入分析\"></a>ThreadLocal 源码深入分析</h1><p>以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～</p>\n<p><code>ThreadLocal</code> 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 <code>GC</code>。<code>ThreadLocal</code> 相当于提供了一种线程隔离，将变量与线程相绑定。<code>ThreadLocal</code> 通常定义为 <code>private static</code> 类型。</p>\n<p>假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，<code>Thread作为key</code>，变量作为<code>value</code>。事实上，JDK 中确实使用了类似 <code>Map</code> 的结构存储变量，但不是像我们想的那样。下面我们来探究<code>OpenJDK 1.8</code>中<code>ThreadLocal</code>的实现。</p>","more":"<h2 id=\"初探-ThreadLocal\"><a href=\"#初探-ThreadLocal\" class=\"headerlink\" title=\"初探 ThreadLocal\"></a>初探 ThreadLocal</h2><p>我们从 <code>ThreadLocal</code> 的几个成员变量入手：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class=\"line\"><span class=\"comment\"> * zero.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger nextHashCode =</span><br><span class=\"line\">    <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The difference between successively generated hash codes - turns</span></span><br><span class=\"line\"><span class=\"comment\"> * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class=\"line\"><span class=\"comment\"> * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_INCREMENT = <span class=\"number\">0x61c88647</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the next hash code.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextHashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ThreadLocal</code> 通过 <code>threadLocalHashCode</code> 来标识每一个 <code>ThreadLocal</code> 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(这个数的原理没有探究)。</p>\n<p>再看 set 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class=\"line\"><span class=\"comment\"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class=\"line\"><span class=\"comment\"> * override this method, relying solely on the &#123;<span class=\"doctag\">@link</span> #initialValue&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * method to set the values of thread-locals.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class=\"line\"><span class=\"comment\"> *        this thread-local.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到通过<code>Thread.currentThread()</code>方法获取了当前的线程引用，并传给了<code>getMap(Thread)</code>方法获取一个<code>ThreadLocalMap</code>的实例。我们继续跟进<code>getMap(Thread)</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>getMap(Thread)</code>方法直接返回<code>Thread</code>实例的成员变量<code>threadLocals</code>。它的定义在<code>Thread</code>内部，访问级别为<code>package</code>级别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\"> * by the ThreadLocal class. */</span></span><br><span class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>到了这里，我们可以看出，每个<code>Thread</code>里面都有一个<code>ThreadLocal.ThreadLocalMap</code>成员变量，也就是说每个线程通过<code>ThreadLocal.ThreadLocalMap</code>与<code>ThreadLocal</code>相绑定，这样可以确保每个线程访问到的<code>thread-local variable</code>都是本线程的。</p>\n<p>我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals。</p>\n<p>ThreadLocal#createMap方法的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们探究一下 ThreadLocalMap 的实现。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0n3taxdfxj30cc0fd40a.jpg\" alt=\"ThreadLocalMap\" title=\"\">\n                </div>\n                <div class=\"image-caption\">ThreadLocalMap</div>\n            </figure></p>\n<p>可以看到ThreadLocalMap有一个常量和三个成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The initial capacity -- MUST be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The table, resized as necessary.</span></span><br><span class=\"line\"><span class=\"comment\"> * table.length MUST always be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The number of entries in the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The next size value at which to resize.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold; <span class=\"comment\">// Default to 0</span></span><br></pre></td></tr></table></figure>\n<p>其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。</p>\n<p>Entry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The entries in this hash map extend WeakReference, using</span></span><br><span class=\"line\"><span class=\"comment\"> * its main ref field as the key (which is always a</span></span><br><span class=\"line\"><span class=\"comment\"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class=\"line\"><span class=\"comment\"> * == null) mean that the key is no longer referenced, so the</span></span><br><span class=\"line\"><span class=\"comment\"> * entry can be expunged from table.  Such entries are referred to</span></span><br><span class=\"line\"><span class=\"comment\"> * as \"stale entries\" in the code that follows.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</p>\n<p>ThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class=\"line\"><span class=\"comment\"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class=\"line\"><span class=\"comment\"> * one when we have at least one entry to put in it.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">    table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">    size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。</p>\n<p>注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 2的指数，因为这可以使得hash发生冲突的次数减小。</p>\n<p>接下来我们来看ThreadLocalMap#set方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set the value associated with key.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to be set</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// We don't use a fast path as with get() because it is at</span></span><br><span class=\"line\">    <span class=\"comment\">// least as common to use set() to create new entries as</span></span><br><span class=\"line\">    <span class=\"comment\">// it is to replace existing ones, in which case, a fast</span></span><br><span class=\"line\">    <span class=\"comment\">// path would fail more often than not.</span></span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            replaceStaleEntry(key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">        rehash();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果冲突了，就会通过nextIndex方法再次计算哈希值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Increment i modulo len.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i + <span class=\"number\">1</span> &lt; len) ? i + <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，我们看到 ThreadLocalMap 解决冲突的方法是 线性探测法（不断加 1），而不是 HashMap 的 链地址法，这一点也能从 Entry 的结构上推断出来。</p>\n<p>如果entry里对应的key为null的话，表明此entry为staled entry，就将其替换为当前的key和value：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Replace a stale entry encountered during a set operation</span></span><br><span class=\"line\"><span class=\"comment\"> * with an entry for the specified key.  The value passed in</span></span><br><span class=\"line\"><span class=\"comment\"> * the value parameter is stored in the entry, whether or not</span></span><br><span class=\"line\"><span class=\"comment\"> * an entry already exists for the specified key.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * As a side effect, this method expunges all stale entries in the</span></span><br><span class=\"line\"><span class=\"comment\"> * \"run\" containing the stale entry.  (A run is a sequence of entries</span></span><br><span class=\"line\"><span class=\"comment\"> * between two null slots.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  value the value to be associated with key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  staleSlot index of the first stale entry encountered while</span></span><br><span class=\"line\"><span class=\"comment\"> *         searching for key.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceStaleEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"comment\">// Back up to check for prior stale entry in current run.</span></span><br><span class=\"line\">    <span class=\"comment\">// We clean out whole runs at a time to avoid continual</span></span><br><span class=\"line\">    <span class=\"comment\">// incremental rehashing due to garbage collector freeing</span></span><br><span class=\"line\">    <span class=\"comment\">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> slotToExpunge = staleSlot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = prevIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = prevIndex(i, len))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\">    <span class=\"comment\">// Find either the key or trailing null slot of run, whichever</span></span><br><span class=\"line\">    <span class=\"comment\">// occurs first</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"comment\">// If we find key, then we need to swap it</span></span><br><span class=\"line\">        <span class=\"comment\">// with the stale entry to maintain hash table order.</span></span><br><span class=\"line\">        <span class=\"comment\">// The newly stale slot, or any other stale slot</span></span><br><span class=\"line\">        <span class=\"comment\">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class=\"line\">        <span class=\"comment\">// to remove or rehash all of the other entries in run.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            tab[i] = tab[staleSlot];</span><br><span class=\"line\">            tab[staleSlot] = e;</span><br><span class=\"line\">            <span class=\"comment\">// Start expunge at preceding stale entry if it exists</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slotToExpunge == staleSlot)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// If we didn't find stale entry on backward scan, the</span></span><br><span class=\"line\">        <span class=\"comment\">// first stale entry seen while scanning for key is the</span></span><br><span class=\"line\">        <span class=\"comment\">// first still present in the run.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// If key not found, put new entry in stale slot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"comment\">// If there are any other stale entries in run, expunge them</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slotToExpunge != staleSlot)</span><br><span class=\"line\">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。</p>\n<p>若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Heuristically scan some cells looking for stale entries.</span></span><br><span class=\"line\"><span class=\"comment\"> * This is invoked when either a new element is added, or</span></span><br><span class=\"line\"><span class=\"comment\"> * another stale one has been expunged. It performs a</span></span><br><span class=\"line\"><span class=\"comment\"> * logarithmic number of scans, as a balance between no</span></span><br><span class=\"line\"><span class=\"comment\"> * scanning (fast but retains garbage) and a number of scans</span></span><br><span class=\"line\"><span class=\"comment\"> * proportional to number of elements, that would find all</span></span><br><span class=\"line\"><span class=\"comment\"> * garbage but would cause some insertions to take O(n) time.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> i a position known NOT to hold a stale entry. The</span></span><br><span class=\"line\"><span class=\"comment\"> * scan starts at the element after i.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> n scan control: &#123;<span class=\"doctag\">@code</span> log2(n)&#125; cells are scanned,</span></span><br><span class=\"line\"><span class=\"comment\"> * unless a stale entry is found, in which case</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> log2(table.length)-1&#125; additional cells are scanned.</span></span><br><span class=\"line\"><span class=\"comment\"> * When called from insertions, this parameter is the number</span></span><br><span class=\"line\"><span class=\"comment\"> * of elements, but when from replaceStaleEntry, it is the</span></span><br><span class=\"line\"><span class=\"comment\"> * table length. (Note: all this could be changed to be either</span></span><br><span class=\"line\"><span class=\"comment\"> * more or less aggressive by weighting n instead of just</span></span><br><span class=\"line\"><span class=\"comment\"> * using straight log n. But this version is simple, fast, and</span></span><br><span class=\"line\"><span class=\"comment\"> * seems to work well.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if any stale entries have been removed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cleanSomeSlots</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        i = nextIndex(i, len);</span><br><span class=\"line\">        Entry e = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n = len;</span><br><span class=\"line\">            removed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i = expungeStaleEntry(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ( (n &gt;&gt;&gt;= <span class=\"number\">1</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦发现一个位置对应的 Entry 所持有的 ThreadLocal 弱引用为null，就会把此位置当做 staleSlot 并调用 expungeStaleEntry 方法进行整理 (rehashing) 的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class=\"line\"><span class=\"comment\"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class=\"line\"><span class=\"comment\"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class=\"line\"><span class=\"comment\"> * Knuth, Section 6.4</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> staleSlot index of slot known to have null key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the index of the next null slot after staleSlot</span></span><br><span class=\"line\"><span class=\"comment\"> * (all between staleSlot and this slot will have been checked</span></span><br><span class=\"line\"><span class=\"comment\"> * for expunging).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要没有清理任何的 stale entries 并且 size 达到阈值的时候（即 table 已满，所有元素都可用），都会触发rehashing：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class=\"line\"><span class=\"comment\"> * table removing stale entries. If this doesn't sufficiently</span></span><br><span class=\"line\"><span class=\"comment\"> * shrink the size of the table, double the table size.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    expungeStaleEntries();</span><br><span class=\"line\">    <span class=\"comment\">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &gt;= threshold - threshold / <span class=\"number\">4</span>)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunge all stale entries in the table.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">expungeStaleEntries</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">        Entry e = tab[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            expungeStaleEntry(j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>rehash 操作会执行一次全表的扫描清理工作，并在 size 大于等于 threshold 的四分之三时进行 resize。但注意在 setThreshold 的时候又取了三分之二：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Set the resize threshold to maintain at worst a 2/3 load factor.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setThreshold</span><span class=\"params\">(<span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    threshold = len * <span class=\"number\">2</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此 ThreadLocalMap 的实际 load factor 为 3/4 * 2/3 = 0.5。</p>\n<p>我们继续看 getEntry 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Get the entry associated with key.  This method</span></span><br><span class=\"line\"><span class=\"comment\"> * itself handles only the fast path: a direct hit of existing</span></span><br><span class=\"line\"><span class=\"comment\"> * key. It otherwise relays to getEntryAfterMiss.  This is</span></span><br><span class=\"line\"><span class=\"comment\"> * designed to maximize performance for direct hits, in part</span></span><br><span class=\"line\"><span class=\"comment\"> * by making this method readily inlinable.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the entry associated with key, or null if no such</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Entry e = table[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Version of getEntry method for use when key is not found in</span></span><br><span class=\"line\"><span class=\"comment\"> * its direct hash slot.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  i the table index for key's hash code</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  e the entry at table[i]</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the entry associated with key, or null if no such</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            i = nextIndex(i, len);</span><br><span class=\"line\">        e = tab[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用getEntryAfterMiss方法，根据线性探测法继续查找，直到找到或对应entry为null，并返回。</p>\n<p>ThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove 方法的思想类似，直接放源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove the entry for key.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">            e.clear();</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>remove的时候同样也会调用expungeStaleEntry方法执行清理工作。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>每个 Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的 ThreadLocal 被及时回收，不会造成内存泄露，又可以提升性能。假如我们把 ThreadLocalMap 做成一个 Map<t extends=\"\" thread,=\"\" ?=\"\"> 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将 ThreadLocalMap 与线程相绑定的实现，完美地解决了这个问题。</t></p>\n<p>总结一下什么时候无用的 Entry 会被清理：</p>\n<p>Thread 结束的时候<br>插入元素时，发现 staled entry，则会进行替换并清理<br>插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容<br>调用 ThreadLocalMap 的 remove 方法或set(null) 时<br>尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。</p>\n<p>特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 remove 了。</p>\n<p>总的来说，对于多线程资源共享的问题，同步机制采用了 以时间换空间 的方式，而 ThreadLocal 则采用了 以空间换时间 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>"},{"title":"深入理解Android 消息机制：Handler、MessageQueue 和 Looper","date":"2019-03-01T07:59:32.000Z","_content":"\n# Android 消息机制：Handler、MessageQueue 和 Looper\n\n在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。\n在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：\n\n<!-- more -->\n\n## 1、Handler 的作用\n\n通常，当我们在非主线程当中做了异步的操作之后使用 `Handler` 来在主线程当中更新 UI。之所以这么设计无非就是因为 `Android` 中的 `View` 不是线程安全的。之所以将 `View` 设计成非线程安全的，是因为：\n> 1).对 `View` 进行加锁之后会增加控件使用的复杂度；\n> 2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI，\n\n**确切来说它有两个作用：**\n1. 任务调度：即通过 `post()` 和 `send()` 等方法来指定某个任务在某个时间执行；\n2. 线程切换：你也许用过 `RxJava`，但如果在 `Android` 中使用的话还要配合 `RxAndroid`，而这里的 `RxAndroid` 内部就使用 `Handler` 来实现线程切换。\n\n下文中，我们就来分别看一下它的这两个功能的作用和原理。\n\n### 1.1 任务调度\n**使用 `Hanlder` 可以让一个任务在某个时间点执行或者等待某段时间之后执行**。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 `post()` 和 `sned()` 两类方法。`post()` 类的用来指定某个 `Runnable` 在**某个时间点执行**，`send()` 类的用来指定某个 `Message` 在某个时间点执行。\n这里的 **`Message`** 是 `Android` 中定义的一个类。它内部有多个字段，比如 `what`、`arg1`、`arg2`、`replyTo` 和 `sendingUid` 来帮助我们指定该消息的内容和对象。同时， `Message` 还实现了 `Parcelable` 接口，这表明**它可以被用来跨进程传输**。此外，它内部还定义了一个 `Message` 类型的 `next` 字段，这表明 `Message` 可以被用作链表的结点。实际上 `MessageQueue` 里面只存放了一个 `mMessage`，即链表的**头结点**。所以，`MessageQueue` 内部的消息队列，本质上是一个**单链表**，每个链表的结点就是 `Message`。\n当调用 `post()` 类型的方法来调度某个 `Runnable` 的时候，首先会将其包装成一个 `Message`，然后再使用 `send() `类的方法进行任务分发。所以，不论是 `post()` 类的方法还是 `send()` 类的方法，最终都会使用 `Handler`  的 `sendMessageAtTime()` 方法来将其加入到队列中：\n```JAVA\n    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            // ... 无关代码\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n使用 `Handler` 进行任务调度是非常简单的。下面的代码就实现了让一个 `Runnable` 在 `500ms` 之后执行的逻辑：\n\n```JAVA\n    new Handler().postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            // do something\n        }\n    }, 500);\n```\n\n上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。\n既然每个 `Runnable` 被 `post()` 发送之后还要被包装成 `Message`，那么 `Message` 的意义何在呢？\n`Runnable` 被包装的过程依赖于 `Handler` 内部的 `getPostMessage()` 方法。下面是该方法的定义：\n\n\n```JAVA\n    private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n```\n\n可见，我们的 `Runnable` 会被赋值给 `Message` 的 `callback`。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要：\n\n1. 首先，要使用 `send()` 类型的方法来传递我们的 `Message` 给 `Handler`；\n2. 然后，我们的 `Handler` 要覆写 `handleMessage()` 方法，并在该方法中获取每个 `Message` 并根据其内部的信息依次处理。\n\n下面的一个例子用来演示 `send()` 类型的方法。首先，我们要定义 `Handler` 并覆写其 `handleMessage()` 方法来处理消息：\n\n\n```JAVA\n    private final static int SAY_HELLO = 1;\n\n    private static Handler handler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case SAY_HELLO:\n                    LogUtils.d(\"Hello!\");\n                    break;\n            }\n        }\n    };\n```\n\n然后，我们向该 Handler 发送消息：\n\n```JAVA\n    Message message = Message.obtain(handler);\n    message.what = SAY_HELLO;\n    message.sendToTarget();\n```\n这样，我们的 `Handler` 接收到了消息并根据其 `what` 得知要 `SAY_HELLO`，于是就打印出了日志信息。除了调用 `Message` 的 `sendToTarget()` 方法，我们还可以直接调用 `handler` 的 `sendMessage()` 方法（`sendToTarget()` 内部调用了 `handler` 的 `sendMessage()`）。\n## 1.2 线程切换\n下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。\n\n\n```JAVA\n    // 在主线程中获取 Handler\n    private static Handler handler = new Handler();\t\t\n\n    // 更新UI，会将消息发送到主线程当中\n    new Thread(() -> {\n        try {\n            Thread.sleep(2000);\n            handler.post(() -> getBinding().tv.setText(\"主线程更新UI\"));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }).start();\n\n```\n\n上面之所以能够在主线程当中更新 UI，主要是因为**我们的 `Handler` 是在主线程当中进行获取的**。随后，我们调用 `handler` 的 `post()` 方法之后，传入的 `Runnable` 会被包装成 `Message`，然后加入到主线程对应的消息队列中去，并由主线程对应的 `Looper` 获取到并执行。所以，就使得该 `Runnable` 的操作最终在主线程中完成。\n也许你会觉得先在主线程当中获取到 `Handler` 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 `Looper` 的 `getMainLooper()` 方法来获取主线程对应的 `Looper`，然后使用它来实例化一个 `Handler` 并使用该 `Handler `来处理消息：\n\n```JAVA\n    new Handler(Looper.getMainLooper())\n        .post(() -> getBinding().tv.setText(\"主线程更新UI\"));\n```\n\n本质上，当我们调用 `Handler` 的无参构造方法，或者说不指定 `Looper` 的构造方法的时候，会直接使用当前线程对应的 `Looper` 来实例化 `Handler`。每个线程对应的 `Looper` 存储在该线程的局部变量 `ThreadLocal` 里。当某个线程的局部变量里面没有 `Looper` 的时候就会抛出一个**异常**。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。\n**主线程对应的 `Looper` 会在 `ActivityThread` 的静态方法 `main()` 中被创建，它会调用 `Looper` 的 `prepareMainLooper()` 静态方法来创建主线程对应的 Looper。**然后会调用 `Looper` 的 `loop()` 静态方法来开启 Looper 循环以不断处理消息。这里的 `ActivityThread` 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。`ActivityThread` 内部定义了一个内部类 `H`，它继承自 `Handler`，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。\n除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 `Looper`。下面的代码中，**我们开启了一个线程，并在线程中先调用 `Looper` 的 `prepare()` 静态方法，此时 `Looper` 会为我们当前的线程创建 `Looper`，**然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息：\n\n\n```JAVA\n    new Thread(() -> {\n        LogUtils.d(\"+++++++++\" + Thread.currentThread());\n        Looper.prepare();\n        new Handler().post(() -> LogUtils.d(\"+++++++++\" + Thread.currentThread()));\n        Looper.loop();\n    }).start();\n```\n\n从以上的内容我们可以看出，`Handler` 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 `ThreadLocal` 来对每个线程对应的`Looper`中的消息队列进行存储。\n## 2、源码解析\n以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。\n### 2.1 实例化 Handler\n`Handler` 提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 `Looper`，另一种在构造方法中不需要指定任何 `Looper`，在构造方法内部会获取当前线程对应的 `Looper` 来初始化 Handler。\n第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作：\n\n```JAVA\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n第二种初始化的方式最终会调用下面的方法。这里使用 `Looper` 的静态方法 `myLooper()` 来获取当前线程对应的 `Looper`。如果当前线程不存在任何 Looper 就会抛出一个异常。\n\n```JAVA\n    public Handler(Callback callback, boolean async) {\n        // 潜在内存泄漏的检查\n        if (FIND_POTENTIAL_LEAKS) {\n            final Class<? extends Handler> klass = getClass();\n            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n\n        // 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException();\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n而 Looper 的静态方法 `myLooper()` 会使用线程局部变量 `sThreadLocal` 来获取之前存储到该线程内部的 Looper：\n\n\n```JAVA\n  public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n\n### 2.2 Looper 的初始化\n前面我们也说过 `Looper` 的创建过程。对于主线程的 `Looper` 会在 `ActivityThread` 的 `main()` 方法中被调用：\n\n\n```JAVA\n  public static void main(String[] args) {\n        // ... 无关代码\n        Looper.prepareMainLooper();\n        // ... 无关代码\n        // 开启 Looper 循环\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n这里调用了 `Looper` 的静态方法 `prepareMainLooper()` 来初始化主线程的 Looper：\n\n\n```JAVA\n  public static void prepareMainLooper() {\n        prepare(false);\n        synchronized (Looper.class) {\n            if (sMainLooper != null) {\n                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n            }\n            sMainLooper = myLooper();\n        }\n    }\n```\n其内部先调用了 `prepare(boolean)` 方法来初始化一个 `Looper` 并将其放在线程局部变量 `sThreadLocal` 中，然后判断 `sMainLooper` 是否之前存在过。这是一种基本的**单例校验**，显然，我们只允许主线程的 Looper 被实例化一次。\n同样，非主线程的 `Looper` 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 `prepare()` 静态方法。它同样调用了  `prepare(boolean)` 方法来初始化一个 `Looper` 并将其放在线程局部变量 `sThreadLocal` 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。\n\n下面是 `prepare()` 方法的代码:\n```JAVA\n    public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n\n经过上述分析，我们可以得知，对于**一个线程只能实例化一个 `Looper`**，所以当我们在同一个线程中多次创建 Handler 实例，它们是**共享一个 Looper** 。或者说是一个 Looper 对应多个 Handler 也是可以的。\n\n### 2.3 MessageQueue 的实例化\n相比于 `Looper` 和 `Handler`，`MessageQueue` 就显得相对复杂一些。因为内部用到了 `JNI` 编程。初始化、销毁和入队等事件都用到了 `native` 的方法。你可以在 [`android_os_MessageQueue`](https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp) 查看其源码的定义。\n每当我们实例化一个 `Looper` 的时候会调用它的构造方法，并在其中实例化一个 `MessageQueue`：\n\n\n```JAVA\n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n在实例化 `Handler` 的小节中可以看出，每次实例化一个 `Handler` 的时候，会从当前线程对应的 `Looper` 中取出 `MessageQueue`。所以，这里我们又可以得出结论:\n\n> **一个 Handler 对应一个 MessageQueue**。\n\n当我们实例化一个 `MessageQueue` 的时候会使用它的构造方法。这里会调用 `native` 层的 `nativeInit()` 方法来完成 MessageQueue 的初始化：\n\n\n```JAVA\n    MessageQueue(boolean quitAllowed) {\n        mQuitAllowed = quitAllowed;\n        mPtr = nativeInit();\n    }\n```\n在 native 层，`nativeInit()` 方法的定义如下：\n\n\n```JAVA\n    static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n        NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n        if (!nativeMessageQueue) {\n            jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n            return 0;\n        }\n        nativeMessageQueue->incStrong(env);\n        return reinterpret_cast<jlong>(nativeMessageQueue);\n    }\n```\n\n上面我们可以看出，在该方法中实例化了一个`NativeMessageQueue` 之后返回了 **mPtr** 作为是 Java 层 `MessageQueue` 与`NativeMessesageQueue` 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 `MessageQueue` 同样使用 **mPtr** 来表示 `native` 层的消息队列。`NativeMessageQueue` 在 `native` 层的部分定义和其构造方法的定义如下。\n\n\n```JAVA\n    class NativeMessageQueue : public MessageQueue, public LooperCallback {\n    // ... 无关代码\n    NativeMessageQueue::NativeMessageQueue() :\n            mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n        mLooper = Looper::getForThread();\n        if (mLooper == NULL) {\n            mLooper = new Looper(false);\n            Looper::setForThread(mLooper);\n        }\n    }\n```\n从上面我们可以看出，`NativeMessageQueue` 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper （其源码在 [Looper](https://android.googlesource.com/platform/system/core/+/master/libutils/Looper.cpp)）。\n\n在 Android 的 `native` 层存在着一个于 `Java` 层类似的 `Looper`，**它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信**。当消息队列中有消息存入时，会唤醒 Native 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Native 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。\n\n\n\n既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？\n> 这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长以至于无法处理其他事件的时候才会出现 ANR。\n上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下：\n\n```JAVA\n    void Looper::rebuildEpollLocked() {\n        // 如果之前存在的话就关闭之前的 epoll 实例\n        if (mEpollFd >= 0) {\n            mEpollFd.reset(); // 关闭旧的epoll实例\n        }\n        // 申请新的 epoll 实例，并且注册 “Wake管道”\n        mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT));\n        LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance: %s\", strerror(errno));\n        struct epoll_event eventItem;\n        // 把未使用的数据区域进行置0操作\n        memset(& eventItem, 0, sizeof(epoll_event));\n        eventItem.events = EPOLLIN;\n        eventItem.data.fd = mWakeEventFd.get();\n        // 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd)\n        int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &eventItem);\n        LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\", strerror(errno));\n        // 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加\n        for (size_t i = 0; i < mRequests.size(); i++) {\n            const Request& request = mRequests.valueAt(i);\n            struct epoll_event eventItem;\n            request.initEventItem(&eventItem);\n            // 将 request 队列的事件，分别添加到 epoll 实例\n            int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &eventItem);\n        }\n    }\n\n```\n\n这里涉及了 [epoll](https://baike.baidu.com/item/epoll/10738144?fr=aladdin) 相关的知识。`epoll` 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，**整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的**，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。\n上面的代码中使用了 `epoll_ctl` 方法来将被监听的描述符添加到 `epoll` 句柄。关于 `epoll` 的指令，可以参考这篇博文 [《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》](https://blog.csdn.net/yusiguyuan/article/details/15027821)。这部分代码的主要作用是创建一个 `epoll` 实例并用它来监听 `event` 触发。\n\n## 2.4 消息的执行过程\n### 2.4.1 消息入队的过程\n在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？\n首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。\n\n```JAVA\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n从上面可以看出，入队的时候实际上是使用了 `MessageQueue` 的 `enqueueMessage()` 方法。所以，我们再来看下该方法的定义：\n\n\n```JAVA\n    boolean enqueueMessage(Message msg, long when) {\n        // ... 无关代码，校验\n        synchronized (this) {\n            // ... 无关代码\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p;\n                prev.next = msg;\n            }\n\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。\n这里的 `nativeWake()` 方法会最终调用 `native` 层的 Looper 的 `awake()` 方法：\n\n```JAVA\n    void Looper::wake() {\n        uint64_t inc = 1;\n        ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &inc, sizeof(uint64_t)));\n        if (nWrite != sizeof(uint64_t)) {\n            if (errno != EAGAIN) {\n                LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d: %s\", mWakeEventFd.get(), strerror(errno));\n            }\n        }\n    }\n```\n\n### 2.4.2 消息执行的过程\n在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。\n\n```JAVA\n    public static void loop() {\n        final Looper me = myLooper();\n        // .. 无关代码\n        final MessageQueue queue = me.mQueue;\n        // .. 无关代码\n        for (;;) {\n            Message msg = queue.next(); // 可能会 bolck\n            if (msg == null) {\n                return;\n            }\n            // ... 无关代码\n            final long dispatchEnd;\n            try {\n                msg.target.dispatchMessage(msg);\n                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;\n            } finally {\n                if (traceTag != 0) {\n                    Trace.traceEnd(traceTag);\n                }\n            }\n            // ... 无关代码\n            msg.recycleUnchecked();\n        }\n    }\n```\n\n从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 `MessageQueue` 的 `next()` 方法来取出下一个消息并进行分发。这里我们先不看 `next()` 方法的定义。我们先把这个方法中涉及的部分分析一下。\n当获取到了下一个消息之后，会调用它的`target` 也就是发送该消息的 `Handler` 的 `dispatchMessage()` 方法来进行处理。该方法的定义如下：\n\n```JAVA\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n从上面可以看出，如果该消息是通过包装 `Runnable` 得到的话，会直接调用它的 `handleCallback()` 方法进行处理。在该方法内部会直接调用 Runnable 的  `run()` 方法。因为比较见到那，我们就不贴出代码了。\n然后，会根据 `mCallback` 是否为空来决定是交给 `mCallback` 进行处理还是内部的 `handleMessage()` 方法。这里的 `mCallback` 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 `handleMessage()` 方法，我们就再熟悉不过了，它就是我们创建 `Handler` 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 `Handler` 中进行处理了。\n以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 `MessageQueue` 是如何获取 “下一个” 消息的。\n\n### 2.4.3 MessageQueue 的消息管理\n上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑：\n\n\n```JAVA\n    Message next() {\n        // 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。\n        final long ptr = mPtr;\n        if (ptr == 0) {\n            return null;\n        }\n        int pendingIdleHandlerCount = -1; // -1 only during first iteration\n        int nextPollTimeoutMillis = 0;\n        for (;;) {\n            if (nextPollTimeoutMillis != 0) {\n                Binder.flushPendingCommands();\n            }\n            // 调用 native 的方法，可能会这个函数发生 block\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n            // ... 无关代码\n        }\n    }\n```\n\n从上面可以看出 Java 层的 `MessageQueue` 的 `next()` 方法是一个循环。除了获取消息队列之外，还要监听` Natvie` 层 `Looper` 的事件触发。通过调用 native 层的 `nativePollOnce()` 方法来实现。该方法内部又会调用 `NativeMessageQueue` 的 `pollOnce()` 方法。而且注意下，在下面的方法中，`nativeMessageQueue` 是从 Java 层的 **mPtr** 中获取到的。所以我们说，在初始化 `MessageQueue` 的时候得到的 **mPtr** 起到了桥梁的作用：\n\n\n```JAVA\n    static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n            jlong ptr, jint timeoutMillis) {\n        NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n        nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n    }\n```\n\n在 `NativeMessageQueue` 的 `pollOnce()` 方法中会调用 `native` 层的 Looper 的 `pollOnce()`，并最终调用 native 层 Looper 的 `pollInner()` 方法：\n\n```JAVA\n    int Looper::pollInner(int timeoutMillis) {\n        // ... 根据下一个消息的事件调整超时时间\n        int result = POLL_WAKE;\n        mResponses.clear();\n        mResponseIndex = 0;\n        mPolling = true; // 将要空闲\n        struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n        // 待已注册之事件被触发或计时终了\n        int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n        mPolling = false; // 不再空闲\n        mLock.lock(); // 请求锁\n        if (mEpollRebuildRequired) {\n            mEpollRebuildRequired = false;\n            rebuildEpollLocked(); // 根据需要重建 epoll\n            goto Done;\n        }\n        // 进行检查\n        if (eventCount < 0) {\n            if (errno == EINTR) {\n                goto Done;\n            }\n            result = POLL_ERROR; // 错误\n            goto Done;\n        }\n        if (eventCount == 0) {\n            result = POLL_TIMEOUT; // 超时\n            goto Done;\n        }\n        // 处理所有消息\n        for (int i = 0; i < eventCount; i++) {\n            int fd = eventItems[i].data.fd;\n            uint32_t epollEvents = eventItems[i].events;\n            if (fd == mWakeEventFd.get()) { // 唤醒 fd 有反应\n                if (epollEvents & EPOLLIN) {\n                    awoken(); // 已经唤醒了，则读取并清空管道数据\n                }\n            } else {\n                // 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理\n                ssize_t requestIndex = mRequests.indexOfKey(fd);\n                if (requestIndex >= 0) {\n                    int events = 0;\n                    if (epollEvents & EPOLLIN) events |= EVENT_INPUT;\n                    if (epollEvents & EPOLLOUT) events |= EVENT_OUTPUT;\n                    if (epollEvents & EPOLLERR) events |= EVENT_ERROR;\n                    if (epollEvents & EPOLLHUP) events |= EVENT_HANGUP;\n                    // 将消息放进 mResponses 中\n                    pushResponse(events, mRequests.valueAt(requestIndex));\n                }\n            }\n        }\n    Done: ;\n        // 触发所有的消息回调，处理 Native 层的Message\n        mNextMessageUptime = LLONG_MAX;\n        while (mMessageEnvelopes.size() != 0) {\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n            const MessageEnvelope& messageEnvelope = mMessageEnvelopes.itemAt(0);\n            if (messageEnvelope.uptime <= now) {\n                { // 获取 handler\n                    sp<MessageHandler> handler = messageEnvelope.handler;\n                    Message message = messageEnvelope.message;\n                    mMessageEnvelopes.removeAt(0);\n                    mSendingMessage = true;\n                    mLock.unlock();\n                    handler->handleMessage(message);\n                } // 释放 handler\n                mLock.lock();\n                mSendingMessage = false;\n                result = POLL_CALLBACK;\n            } else {\n                // 队列头部的消息决定了下个唤醒的时间\n                mNextMessageUptime = messageEnvelope.uptime;\n                break;\n            }\n        }\n        mLock.unlock(); // 释放锁\n        // 触发所有的响应回调\n        for (size_t i = 0; i < mResponses.size(); i++) {\n            Response& response = mResponses.editItemAt(i);\n            if (response.request.ident == POLL_CALLBACK) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n                int callbackResult = response.request.callback->handleEvent(fd, events, data);\n                if (callbackResult == 0) {\n                    removeFd(fd, response.request.seq); // 移除文件描述符\n                }\n                response.request.callback.clear();\n                result = POLL_CALLBACK;\n            }\n        }\n        return result;\n    }\n```\n\n从上面我们可以看出 Native 层的 `pollInner()` 方法首先会根据 Java 层传入的 `timeoutMillis` 调用 `epoll_wait` 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 `enqueueMessage()` 方法的最后几行代码：\n\n```JAVA\n    if (needWake) {\n        nativeWake(mPtr);\n    }\n```\n即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。\n上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。\n## 3、总结\n在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。\n### 3.1 Handler、MessageQueue 和 Looper 之间的关系\n首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示：\n![HandlerMessageQueueLooper](https://ws1.sinaimg.cn/large/007lnl1egy1g0ncjal5w5j30ia07x0te.jpg)\n\n也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。\n### 3.2 Handler 的消息发送过程\n然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析：\n\n![Handler](https://ws1.sinaimg.cn/large/007lnl1egy1g0nck94sjfj30j405qjsc.jpg)\n\n根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 `Message` 类型的数据。但不论哪种类型最终都会调用 Handler 的 `sendMessageAtTime()` 方法来加入到 `MessageQueue` 的队列中。区别在于，post 类型的方法需要经过 Handler 的 `getPostMessage()` 包装成 Message 之后再发送。\n### 3.3 Looper 的执行过程\n当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 `loop()` 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述：\n\n![Looper](https://ws1.sinaimg.cn/large/007lnl1egy1g0nclv8eauj30jn09ywg2.jpg)\n\n当我们调用 Looper 的 `loop() `方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 `next()` 方法来获取下一个消息的时候，会调用 `nativePollOnce()` 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。\n","source":"_posts/HandlerMessagequeueLooper-1551427172528.md","raw":"---\ntitle: 深入理解Android 消息机制：Handler、MessageQueue 和 Looper\ntags: [Handler, MessageQueue, Looper,Android 消息机制]\ncategories: [Android]\ndate: 2019-03-01 15:59:32\n---\n\n# Android 消息机制：Handler、MessageQueue 和 Looper\n\n在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。\n在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：\n\n<!-- more -->\n\n## 1、Handler 的作用\n\n通常，当我们在非主线程当中做了异步的操作之后使用 `Handler` 来在主线程当中更新 UI。之所以这么设计无非就是因为 `Android` 中的 `View` 不是线程安全的。之所以将 `View` 设计成非线程安全的，是因为：\n> 1).对 `View` 进行加锁之后会增加控件使用的复杂度；\n> 2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI，\n\n**确切来说它有两个作用：**\n1. 任务调度：即通过 `post()` 和 `send()` 等方法来指定某个任务在某个时间执行；\n2. 线程切换：你也许用过 `RxJava`，但如果在 `Android` 中使用的话还要配合 `RxAndroid`，而这里的 `RxAndroid` 内部就使用 `Handler` 来实现线程切换。\n\n下文中，我们就来分别看一下它的这两个功能的作用和原理。\n\n### 1.1 任务调度\n**使用 `Hanlder` 可以让一个任务在某个时间点执行或者等待某段时间之后执行**。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 `post()` 和 `sned()` 两类方法。`post()` 类的用来指定某个 `Runnable` 在**某个时间点执行**，`send()` 类的用来指定某个 `Message` 在某个时间点执行。\n这里的 **`Message`** 是 `Android` 中定义的一个类。它内部有多个字段，比如 `what`、`arg1`、`arg2`、`replyTo` 和 `sendingUid` 来帮助我们指定该消息的内容和对象。同时， `Message` 还实现了 `Parcelable` 接口，这表明**它可以被用来跨进程传输**。此外，它内部还定义了一个 `Message` 类型的 `next` 字段，这表明 `Message` 可以被用作链表的结点。实际上 `MessageQueue` 里面只存放了一个 `mMessage`，即链表的**头结点**。所以，`MessageQueue` 内部的消息队列，本质上是一个**单链表**，每个链表的结点就是 `Message`。\n当调用 `post()` 类型的方法来调度某个 `Runnable` 的时候，首先会将其包装成一个 `Message`，然后再使用 `send() `类的方法进行任务分发。所以，不论是 `post()` 类的方法还是 `send()` 类的方法，最终都会使用 `Handler`  的 `sendMessageAtTime()` 方法来将其加入到队列中：\n```JAVA\n    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            // ... 无关代码\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n\n使用 `Handler` 进行任务调度是非常简单的。下面的代码就实现了让一个 `Runnable` 在 `500ms` 之后执行的逻辑：\n\n```JAVA\n    new Handler().postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            // do something\n        }\n    }, 500);\n```\n\n上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。\n既然每个 `Runnable` 被 `post()` 发送之后还要被包装成 `Message`，那么 `Message` 的意义何在呢？\n`Runnable` 被包装的过程依赖于 `Handler` 内部的 `getPostMessage()` 方法。下面是该方法的定义：\n\n\n```JAVA\n    private static Message getPostMessage(Runnable r) {\n        Message m = Message.obtain();\n        m.callback = r;\n        return m;\n    }\n```\n\n可见，我们的 `Runnable` 会被赋值给 `Message` 的 `callback`。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要：\n\n1. 首先，要使用 `send()` 类型的方法来传递我们的 `Message` 给 `Handler`；\n2. 然后，我们的 `Handler` 要覆写 `handleMessage()` 方法，并在该方法中获取每个 `Message` 并根据其内部的信息依次处理。\n\n下面的一个例子用来演示 `send()` 类型的方法。首先，我们要定义 `Handler` 并覆写其 `handleMessage()` 方法来处理消息：\n\n\n```JAVA\n    private final static int SAY_HELLO = 1;\n\n    private static Handler handler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case SAY_HELLO:\n                    LogUtils.d(\"Hello!\");\n                    break;\n            }\n        }\n    };\n```\n\n然后，我们向该 Handler 发送消息：\n\n```JAVA\n    Message message = Message.obtain(handler);\n    message.what = SAY_HELLO;\n    message.sendToTarget();\n```\n这样，我们的 `Handler` 接收到了消息并根据其 `what` 得知要 `SAY_HELLO`，于是就打印出了日志信息。除了调用 `Message` 的 `sendToTarget()` 方法，我们还可以直接调用 `handler` 的 `sendMessage()` 方法（`sendToTarget()` 内部调用了 `handler` 的 `sendMessage()`）。\n## 1.2 线程切换\n下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。\n\n\n```JAVA\n    // 在主线程中获取 Handler\n    private static Handler handler = new Handler();\t\t\n\n    // 更新UI，会将消息发送到主线程当中\n    new Thread(() -> {\n        try {\n            Thread.sleep(2000);\n            handler.post(() -> getBinding().tv.setText(\"主线程更新UI\"));\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }).start();\n\n```\n\n上面之所以能够在主线程当中更新 UI，主要是因为**我们的 `Handler` 是在主线程当中进行获取的**。随后，我们调用 `handler` 的 `post()` 方法之后，传入的 `Runnable` 会被包装成 `Message`，然后加入到主线程对应的消息队列中去，并由主线程对应的 `Looper` 获取到并执行。所以，就使得该 `Runnable` 的操作最终在主线程中完成。\n也许你会觉得先在主线程当中获取到 `Handler` 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 `Looper` 的 `getMainLooper()` 方法来获取主线程对应的 `Looper`，然后使用它来实例化一个 `Handler` 并使用该 `Handler `来处理消息：\n\n```JAVA\n    new Handler(Looper.getMainLooper())\n        .post(() -> getBinding().tv.setText(\"主线程更新UI\"));\n```\n\n本质上，当我们调用 `Handler` 的无参构造方法，或者说不指定 `Looper` 的构造方法的时候，会直接使用当前线程对应的 `Looper` 来实例化 `Handler`。每个线程对应的 `Looper` 存储在该线程的局部变量 `ThreadLocal` 里。当某个线程的局部变量里面没有 `Looper` 的时候就会抛出一个**异常**。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。\n**主线程对应的 `Looper` 会在 `ActivityThread` 的静态方法 `main()` 中被创建，它会调用 `Looper` 的 `prepareMainLooper()` 静态方法来创建主线程对应的 Looper。**然后会调用 `Looper` 的 `loop()` 静态方法来开启 Looper 循环以不断处理消息。这里的 `ActivityThread` 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。`ActivityThread` 内部定义了一个内部类 `H`，它继承自 `Handler`，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。\n除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 `Looper`。下面的代码中，**我们开启了一个线程，并在线程中先调用 `Looper` 的 `prepare()` 静态方法，此时 `Looper` 会为我们当前的线程创建 `Looper`，**然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息：\n\n\n```JAVA\n    new Thread(() -> {\n        LogUtils.d(\"+++++++++\" + Thread.currentThread());\n        Looper.prepare();\n        new Handler().post(() -> LogUtils.d(\"+++++++++\" + Thread.currentThread()));\n        Looper.loop();\n    }).start();\n```\n\n从以上的内容我们可以看出，`Handler` 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 `ThreadLocal` 来对每个线程对应的`Looper`中的消息队列进行存储。\n## 2、源码解析\n以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。\n### 2.1 实例化 Handler\n`Handler` 提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 `Looper`，另一种在构造方法中不需要指定任何 `Looper`，在构造方法内部会获取当前线程对应的 `Looper` 来初始化 Handler。\n第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作：\n\n```JAVA\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n第二种初始化的方式最终会调用下面的方法。这里使用 `Looper` 的静态方法 `myLooper()` 来获取当前线程对应的 `Looper`。如果当前线程不存在任何 Looper 就会抛出一个异常。\n\n```JAVA\n    public Handler(Callback callback, boolean async) {\n        // 潜在内存泄漏的检查\n        if (FIND_POTENTIAL_LEAKS) {\n            final Class<? extends Handler> klass = getClass();\n            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n\n        // 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException();\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n而 Looper 的静态方法 `myLooper()` 会使用线程局部变量 `sThreadLocal` 来获取之前存储到该线程内部的 Looper：\n\n\n```JAVA\n  public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n```\n\n### 2.2 Looper 的初始化\n前面我们也说过 `Looper` 的创建过程。对于主线程的 `Looper` 会在 `ActivityThread` 的 `main()` 方法中被调用：\n\n\n```JAVA\n  public static void main(String[] args) {\n        // ... 无关代码\n        Looper.prepareMainLooper();\n        // ... 无关代码\n        // 开启 Looper 循环\n        Looper.loop();\n        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n    }\n```\n\n这里调用了 `Looper` 的静态方法 `prepareMainLooper()` 来初始化主线程的 Looper：\n\n\n```JAVA\n  public static void prepareMainLooper() {\n        prepare(false);\n        synchronized (Looper.class) {\n            if (sMainLooper != null) {\n                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n            }\n            sMainLooper = myLooper();\n        }\n    }\n```\n其内部先调用了 `prepare(boolean)` 方法来初始化一个 `Looper` 并将其放在线程局部变量 `sThreadLocal` 中，然后判断 `sMainLooper` 是否之前存在过。这是一种基本的**单例校验**，显然，我们只允许主线程的 Looper 被实例化一次。\n同样，非主线程的 `Looper` 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 `prepare()` 静态方法。它同样调用了  `prepare(boolean)` 方法来初始化一个 `Looper` 并将其放在线程局部变量 `sThreadLocal` 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。\n\n下面是 `prepare()` 方法的代码:\n```JAVA\n    public static void prepare() {\n        prepare(true);\n    }\n\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n\n经过上述分析，我们可以得知，对于**一个线程只能实例化一个 `Looper`**，所以当我们在同一个线程中多次创建 Handler 实例，它们是**共享一个 Looper** 。或者说是一个 Looper 对应多个 Handler 也是可以的。\n\n### 2.3 MessageQueue 的实例化\n相比于 `Looper` 和 `Handler`，`MessageQueue` 就显得相对复杂一些。因为内部用到了 `JNI` 编程。初始化、销毁和入队等事件都用到了 `native` 的方法。你可以在 [`android_os_MessageQueue`](https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp) 查看其源码的定义。\n每当我们实例化一个 `Looper` 的时候会调用它的构造方法，并在其中实例化一个 `MessageQueue`：\n\n\n```JAVA\n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n在实例化 `Handler` 的小节中可以看出，每次实例化一个 `Handler` 的时候，会从当前线程对应的 `Looper` 中取出 `MessageQueue`。所以，这里我们又可以得出结论:\n\n> **一个 Handler 对应一个 MessageQueue**。\n\n当我们实例化一个 `MessageQueue` 的时候会使用它的构造方法。这里会调用 `native` 层的 `nativeInit()` 方法来完成 MessageQueue 的初始化：\n\n\n```JAVA\n    MessageQueue(boolean quitAllowed) {\n        mQuitAllowed = quitAllowed;\n        mPtr = nativeInit();\n    }\n```\n在 native 层，`nativeInit()` 方法的定义如下：\n\n\n```JAVA\n    static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n        NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n        if (!nativeMessageQueue) {\n            jniThrowRuntimeException(env, \"Unable to allocate native queue\");\n            return 0;\n        }\n        nativeMessageQueue->incStrong(env);\n        return reinterpret_cast<jlong>(nativeMessageQueue);\n    }\n```\n\n上面我们可以看出，在该方法中实例化了一个`NativeMessageQueue` 之后返回了 **mPtr** 作为是 Java 层 `MessageQueue` 与`NativeMessesageQueue` 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 `MessageQueue` 同样使用 **mPtr** 来表示 `native` 层的消息队列。`NativeMessageQueue` 在 `native` 层的部分定义和其构造方法的定义如下。\n\n\n```JAVA\n    class NativeMessageQueue : public MessageQueue, public LooperCallback {\n    // ... 无关代码\n    NativeMessageQueue::NativeMessageQueue() :\n            mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n        mLooper = Looper::getForThread();\n        if (mLooper == NULL) {\n            mLooper = new Looper(false);\n            Looper::setForThread(mLooper);\n        }\n    }\n```\n从上面我们可以看出，`NativeMessageQueue` 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper （其源码在 [Looper](https://android.googlesource.com/platform/system/core/+/master/libutils/Looper.cpp)）。\n\n在 Android 的 `native` 层存在着一个于 `Java` 层类似的 `Looper`，**它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信**。当消息队列中有消息存入时，会唤醒 Native 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Native 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。\n\n\n\n既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？\n> 这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长以至于无法处理其他事件的时候才会出现 ANR。\n上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下：\n\n```JAVA\n    void Looper::rebuildEpollLocked() {\n        // 如果之前存在的话就关闭之前的 epoll 实例\n        if (mEpollFd >= 0) {\n            mEpollFd.reset(); // 关闭旧的epoll实例\n        }\n        // 申请新的 epoll 实例，并且注册 “Wake管道”\n        mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT));\n        LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance: %s\", strerror(errno));\n        struct epoll_event eventItem;\n        // 把未使用的数据区域进行置0操作\n        memset(& eventItem, 0, sizeof(epoll_event));\n        eventItem.events = EPOLLIN;\n        eventItem.data.fd = mWakeEventFd.get();\n        // 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd)\n        int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &eventItem);\n        LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\", strerror(errno));\n        // 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加\n        for (size_t i = 0; i < mRequests.size(); i++) {\n            const Request& request = mRequests.valueAt(i);\n            struct epoll_event eventItem;\n            request.initEventItem(&eventItem);\n            // 将 request 队列的事件，分别添加到 epoll 实例\n            int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &eventItem);\n        }\n    }\n\n```\n\n这里涉及了 [epoll](https://baike.baidu.com/item/epoll/10738144?fr=aladdin) 相关的知识。`epoll` 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，**整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的**，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。\n上面的代码中使用了 `epoll_ctl` 方法来将被监听的描述符添加到 `epoll` 句柄。关于 `epoll` 的指令，可以参考这篇博文 [《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》](https://blog.csdn.net/yusiguyuan/article/details/15027821)。这部分代码的主要作用是创建一个 `epoll` 实例并用它来监听 `event` 触发。\n\n## 2.4 消息的执行过程\n### 2.4.1 消息入队的过程\n在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？\n首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。\n\n```JAVA\n    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n        msg.target = this;\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n从上面可以看出，入队的时候实际上是使用了 `MessageQueue` 的 `enqueueMessage()` 方法。所以，我们再来看下该方法的定义：\n\n\n```JAVA\n    boolean enqueueMessage(Message msg, long when) {\n        // ... 无关代码，校验\n        synchronized (this) {\n            // ... 无关代码\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p;\n                prev.next = msg;\n            }\n\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。\n这里的 `nativeWake()` 方法会最终调用 `native` 层的 Looper 的 `awake()` 方法：\n\n```JAVA\n    void Looper::wake() {\n        uint64_t inc = 1;\n        ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &inc, sizeof(uint64_t)));\n        if (nWrite != sizeof(uint64_t)) {\n            if (errno != EAGAIN) {\n                LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d: %s\", mWakeEventFd.get(), strerror(errno));\n            }\n        }\n    }\n```\n\n### 2.4.2 消息执行的过程\n在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。\n\n```JAVA\n    public static void loop() {\n        final Looper me = myLooper();\n        // .. 无关代码\n        final MessageQueue queue = me.mQueue;\n        // .. 无关代码\n        for (;;) {\n            Message msg = queue.next(); // 可能会 bolck\n            if (msg == null) {\n                return;\n            }\n            // ... 无关代码\n            final long dispatchEnd;\n            try {\n                msg.target.dispatchMessage(msg);\n                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;\n            } finally {\n                if (traceTag != 0) {\n                    Trace.traceEnd(traceTag);\n                }\n            }\n            // ... 无关代码\n            msg.recycleUnchecked();\n        }\n    }\n```\n\n从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 `MessageQueue` 的 `next()` 方法来取出下一个消息并进行分发。这里我们先不看 `next()` 方法的定义。我们先把这个方法中涉及的部分分析一下。\n当获取到了下一个消息之后，会调用它的`target` 也就是发送该消息的 `Handler` 的 `dispatchMessage()` 方法来进行处理。该方法的定义如下：\n\n```JAVA\n    public void dispatchMessage(Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n从上面可以看出，如果该消息是通过包装 `Runnable` 得到的话，会直接调用它的 `handleCallback()` 方法进行处理。在该方法内部会直接调用 Runnable 的  `run()` 方法。因为比较见到那，我们就不贴出代码了。\n然后，会根据 `mCallback` 是否为空来决定是交给 `mCallback` 进行处理还是内部的 `handleMessage()` 方法。这里的 `mCallback` 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 `handleMessage()` 方法，我们就再熟悉不过了，它就是我们创建 `Handler` 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 `Handler` 中进行处理了。\n以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 `MessageQueue` 是如何获取 “下一个” 消息的。\n\n### 2.4.3 MessageQueue 的消息管理\n上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑：\n\n\n```JAVA\n    Message next() {\n        // 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。\n        final long ptr = mPtr;\n        if (ptr == 0) {\n            return null;\n        }\n        int pendingIdleHandlerCount = -1; // -1 only during first iteration\n        int nextPollTimeoutMillis = 0;\n        for (;;) {\n            if (nextPollTimeoutMillis != 0) {\n                Binder.flushPendingCommands();\n            }\n            // 调用 native 的方法，可能会这个函数发生 block\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n            // ... 无关代码\n        }\n    }\n```\n\n从上面可以看出 Java 层的 `MessageQueue` 的 `next()` 方法是一个循环。除了获取消息队列之外，还要监听` Natvie` 层 `Looper` 的事件触发。通过调用 native 层的 `nativePollOnce()` 方法来实现。该方法内部又会调用 `NativeMessageQueue` 的 `pollOnce()` 方法。而且注意下，在下面的方法中，`nativeMessageQueue` 是从 Java 层的 **mPtr** 中获取到的。所以我们说，在初始化 `MessageQueue` 的时候得到的 **mPtr** 起到了桥梁的作用：\n\n\n```JAVA\n    static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n            jlong ptr, jint timeoutMillis) {\n        NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n        nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n    }\n```\n\n在 `NativeMessageQueue` 的 `pollOnce()` 方法中会调用 `native` 层的 Looper 的 `pollOnce()`，并最终调用 native 层 Looper 的 `pollInner()` 方法：\n\n```JAVA\n    int Looper::pollInner(int timeoutMillis) {\n        // ... 根据下一个消息的事件调整超时时间\n        int result = POLL_WAKE;\n        mResponses.clear();\n        mResponseIndex = 0;\n        mPolling = true; // 将要空闲\n        struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n        // 待已注册之事件被触发或计时终了\n        int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n        mPolling = false; // 不再空闲\n        mLock.lock(); // 请求锁\n        if (mEpollRebuildRequired) {\n            mEpollRebuildRequired = false;\n            rebuildEpollLocked(); // 根据需要重建 epoll\n            goto Done;\n        }\n        // 进行检查\n        if (eventCount < 0) {\n            if (errno == EINTR) {\n                goto Done;\n            }\n            result = POLL_ERROR; // 错误\n            goto Done;\n        }\n        if (eventCount == 0) {\n            result = POLL_TIMEOUT; // 超时\n            goto Done;\n        }\n        // 处理所有消息\n        for (int i = 0; i < eventCount; i++) {\n            int fd = eventItems[i].data.fd;\n            uint32_t epollEvents = eventItems[i].events;\n            if (fd == mWakeEventFd.get()) { // 唤醒 fd 有反应\n                if (epollEvents & EPOLLIN) {\n                    awoken(); // 已经唤醒了，则读取并清空管道数据\n                }\n            } else {\n                // 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理\n                ssize_t requestIndex = mRequests.indexOfKey(fd);\n                if (requestIndex >= 0) {\n                    int events = 0;\n                    if (epollEvents & EPOLLIN) events |= EVENT_INPUT;\n                    if (epollEvents & EPOLLOUT) events |= EVENT_OUTPUT;\n                    if (epollEvents & EPOLLERR) events |= EVENT_ERROR;\n                    if (epollEvents & EPOLLHUP) events |= EVENT_HANGUP;\n                    // 将消息放进 mResponses 中\n                    pushResponse(events, mRequests.valueAt(requestIndex));\n                }\n            }\n        }\n    Done: ;\n        // 触发所有的消息回调，处理 Native 层的Message\n        mNextMessageUptime = LLONG_MAX;\n        while (mMessageEnvelopes.size() != 0) {\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n            const MessageEnvelope& messageEnvelope = mMessageEnvelopes.itemAt(0);\n            if (messageEnvelope.uptime <= now) {\n                { // 获取 handler\n                    sp<MessageHandler> handler = messageEnvelope.handler;\n                    Message message = messageEnvelope.message;\n                    mMessageEnvelopes.removeAt(0);\n                    mSendingMessage = true;\n                    mLock.unlock();\n                    handler->handleMessage(message);\n                } // 释放 handler\n                mLock.lock();\n                mSendingMessage = false;\n                result = POLL_CALLBACK;\n            } else {\n                // 队列头部的消息决定了下个唤醒的时间\n                mNextMessageUptime = messageEnvelope.uptime;\n                break;\n            }\n        }\n        mLock.unlock(); // 释放锁\n        // 触发所有的响应回调\n        for (size_t i = 0; i < mResponses.size(); i++) {\n            Response& response = mResponses.editItemAt(i);\n            if (response.request.ident == POLL_CALLBACK) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n                int callbackResult = response.request.callback->handleEvent(fd, events, data);\n                if (callbackResult == 0) {\n                    removeFd(fd, response.request.seq); // 移除文件描述符\n                }\n                response.request.callback.clear();\n                result = POLL_CALLBACK;\n            }\n        }\n        return result;\n    }\n```\n\n从上面我们可以看出 Native 层的 `pollInner()` 方法首先会根据 Java 层传入的 `timeoutMillis` 调用 `epoll_wait` 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 `enqueueMessage()` 方法的最后几行代码：\n\n```JAVA\n    if (needWake) {\n        nativeWake(mPtr);\n    }\n```\n即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。\n上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。\n## 3、总结\n在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。\n### 3.1 Handler、MessageQueue 和 Looper 之间的关系\n首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示：\n![HandlerMessageQueueLooper](https://ws1.sinaimg.cn/large/007lnl1egy1g0ncjal5w5j30ia07x0te.jpg)\n\n也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。\n### 3.2 Handler 的消息发送过程\n然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析：\n\n![Handler](https://ws1.sinaimg.cn/large/007lnl1egy1g0nck94sjfj30j405qjsc.jpg)\n\n根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 `Message` 类型的数据。但不论哪种类型最终都会调用 Handler 的 `sendMessageAtTime()` 方法来加入到 `MessageQueue` 的队列中。区别在于，post 类型的方法需要经过 Handler 的 `getPostMessage()` 包装成 Message 之后再发送。\n### 3.3 Looper 的执行过程\n当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 `loop()` 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述：\n\n![Looper](https://ws1.sinaimg.cn/large/007lnl1egy1g0nclv8eauj30jn09ywg2.jpg)\n\n当我们调用 Looper 的 `loop() `方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 `next()` 方法来获取下一个消息的时候，会调用 `nativePollOnce()` 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。\n","slug":"HandlerMessagequeueLooper-1551427172528","published":1,"updated":"2019-03-08T09:25:40.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszuvyug000pqk9ynt1939hw","content":"<h1 id=\"Android-消息机制：Handler、MessageQueue-和-Looper\"><a href=\"#Android-消息机制：Handler、MessageQueue-和-Looper\" class=\"headerlink\" title=\"Android 消息机制：Handler、MessageQueue 和 Looper\"></a>Android 消息机制：Handler、MessageQueue 和 Looper</h1><p>在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。<br>在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：</p>\n<a id=\"more\"></a>\n<h2 id=\"1、Handler-的作用\"><a href=\"#1、Handler-的作用\" class=\"headerlink\" title=\"1、Handler 的作用\"></a>1、Handler 的作用</h2><p>通常，当我们在非主线程当中做了异步的操作之后使用 <code>Handler</code> 来在主线程当中更新 UI。之所以这么设计无非就是因为 <code>Android</code> 中的 <code>View</code> 不是线程安全的。之所以将 <code>View</code> 设计成非线程安全的，是因为：</p>\n<blockquote>\n<p>1).对 <code>View</code> 进行加锁之后会增加控件使用的复杂度；<br>2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI，</p>\n</blockquote>\n<p><strong>确切来说它有两个作用：</strong></p>\n<ol>\n<li>任务调度：即通过 <code>post()</code> 和 <code>send()</code> 等方法来指定某个任务在某个时间执行；</li>\n<li>线程切换：你也许用过 <code>RxJava</code>，但如果在 <code>Android</code> 中使用的话还要配合 <code>RxAndroid</code>，而这里的 <code>RxAndroid</code> 内部就使用 <code>Handler</code> 来实现线程切换。</li>\n</ol>\n<p>下文中，我们就来分别看一下它的这两个功能的作用和原理。</p>\n<h3 id=\"1-1-任务调度\"><a href=\"#1-1-任务调度\" class=\"headerlink\" title=\"1.1 任务调度\"></a>1.1 任务调度</h3><p><strong>使用 <code>Hanlder</code> 可以让一个任务在某个时间点执行或者等待某段时间之后执行</strong>。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 <code>post()</code> 和 <code>sned()</code> 两类方法。<code>post()</code> 类的用来指定某个 <code>Runnable</code> 在<strong>某个时间点执行</strong>，<code>send()</code> 类的用来指定某个 <code>Message</code> 在某个时间点执行。<br>这里的 <strong><code>Message</code></strong> 是 <code>Android</code> 中定义的一个类。它内部有多个字段，比如 <code>what</code>、<code>arg1</code>、<code>arg2</code>、<code>replyTo</code> 和 <code>sendingUid</code> 来帮助我们指定该消息的内容和对象。同时， <code>Message</code> 还实现了 <code>Parcelable</code> 接口，这表明<strong>它可以被用来跨进程传输</strong>。此外，它内部还定义了一个 <code>Message</code> 类型的 <code>next</code> 字段，这表明 <code>Message</code> 可以被用作链表的结点。实际上 <code>MessageQueue</code> 里面只存放了一个 <code>mMessage</code>，即链表的<strong>头结点</strong>。所以，<code>MessageQueue</code> 内部的消息队列，本质上是一个<strong>单链表</strong>，每个链表的结点就是 <code>Message</code>。<br>当调用 <code>post()</code> 类型的方法来调度某个 <code>Runnable</code> 的时候，首先会将其包装成一个 <code>Message</code>，然后再使用 <code>send()</code>类的方法进行任务分发。所以，不论是 <code>post()</code> 类的方法还是 <code>send()</code> 类的方法，最终都会使用 <code>Handler</code>  的 <code>sendMessageAtTime()</code> 方法来将其加入到队列中：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 <code>Handler</code> 进行任务调度是非常简单的。下面的代码就实现了让一个 <code>Runnable</code> 在 <code>500ms</code> 之后执行的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Handler().postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。<br>既然每个 <code>Runnable</code> 被 <code>post()</code> 发送之后还要被包装成 <code>Message</code>，那么 <code>Message</code> 的意义何在呢？<br><code>Runnable</code> 被包装的过程依赖于 <code>Handler</code> 内部的 <code>getPostMessage()</code> 方法。下面是该方法的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Message <span class=\"title\">getPostMessage</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    Message m = Message.obtain();</span><br><span class=\"line\">    m.callback = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见，我们的 <code>Runnable</code> 会被赋值给 <code>Message</code> 的 <code>callback</code>。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要：</p>\n<ol>\n<li>首先，要使用 <code>send()</code> 类型的方法来传递我们的 <code>Message</code> 给 <code>Handler</code>；</li>\n<li>然后，我们的 <code>Handler</code> 要覆写 <code>handleMessage()</code> 方法，并在该方法中获取每个 <code>Message</code> 并根据其内部的信息依次处理。</li>\n</ol>\n<p>下面的一个例子用来演示 <code>send()</code> 类型的方法。首先，我们要定义 <code>Handler</code> 并覆写其 <code>handleMessage()</code> 方法来处理消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> SAY_HELLO = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SAY_HELLO:</span><br><span class=\"line\">                LogUtils.d(<span class=\"string\">\"Hello!\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后，我们向该 Handler 发送消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message message = Message.obtain(handler);</span><br><span class=\"line\">message.what = SAY_HELLO;</span><br><span class=\"line\">message.sendToTarget();</span><br></pre></td></tr></table></figure>\n<p>这样，我们的 <code>Handler</code> 接收到了消息并根据其 <code>what</code> 得知要 <code>SAY_HELLO</code>，于是就打印出了日志信息。除了调用 <code>Message</code> 的 <code>sendToTarget()</code> 方法，我们还可以直接调用 <code>handler</code> 的 <code>sendMessage()</code> 方法（<code>sendToTarget()</code> 内部调用了 <code>handler</code> 的 <code>sendMessage()</code>）。</p>\n<h2 id=\"1-2-线程切换\"><a href=\"#1-2-线程切换\" class=\"headerlink\" title=\"1.2 线程切换\"></a>1.2 线程切换</h2><p>下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在主线程中获取 Handler</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Handler handler = <span class=\"keyword\">new</span> Handler();\t\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新UI，会将消息发送到主线程当中</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        handler.post(() -&gt; getBinding().tv.setText(<span class=\"string\">\"主线程更新UI\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>上面之所以能够在主线程当中更新 UI，主要是因为<strong>我们的 <code>Handler</code> 是在主线程当中进行获取的</strong>。随后，我们调用 <code>handler</code> 的 <code>post()</code> 方法之后，传入的 <code>Runnable</code> 会被包装成 <code>Message</code>，然后加入到主线程对应的消息队列中去，并由主线程对应的 <code>Looper</code> 获取到并执行。所以，就使得该 <code>Runnable</code> 的操作最终在主线程中完成。<br>也许你会觉得先在主线程当中获取到 <code>Handler</code> 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 <code>Looper</code> 的 <code>getMainLooper()</code> 方法来获取主线程对应的 <code>Looper</code>，然后使用它来实例化一个 <code>Handler</code> 并使用该 <code>Handler</code>来处理消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Handler(Looper.getMainLooper())</span><br><span class=\"line\">    .post(() -&gt; getBinding().tv.setText(<span class=\"string\">\"主线程更新UI\"</span>));</span><br></pre></td></tr></table></figure>\n<p>本质上，当我们调用 <code>Handler</code> 的无参构造方法，或者说不指定 <code>Looper</code> 的构造方法的时候，会直接使用当前线程对应的 <code>Looper</code> 来实例化 <code>Handler</code>。每个线程对应的 <code>Looper</code> 存储在该线程的局部变量 <code>ThreadLocal</code> 里。当某个线程的局部变量里面没有 <code>Looper</code> 的时候就会抛出一个<strong>异常</strong>。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。<br><strong>主线程对应的 <code>Looper</code> 会在 <code>ActivityThread</code> 的静态方法 <code>main()</code> 中被创建，它会调用 <code>Looper</code> 的 <code>prepareMainLooper()</code> 静态方法来创建主线程对应的 Looper。</strong>然后会调用 <code>Looper</code> 的 <code>loop()</code> 静态方法来开启 Looper 循环以不断处理消息。这里的 <code>ActivityThread</code> 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。<code>ActivityThread</code> 内部定义了一个内部类 <code>H</code>，它继承自 <code>Handler</code>，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。<br>除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 <code>Looper</code>。下面的代码中，<strong>我们开启了一个线程，并在线程中先调用 <code>Looper</code> 的 <code>prepare()</code> 静态方法，此时 <code>Looper</code> 会为我们当前的线程创建 <code>Looper</code>，</strong>然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    LogUtils.d(<span class=\"string\">\"+++++++++\"</span> + Thread.currentThread());</span><br><span class=\"line\">    Looper.prepare();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Handler().post(() -&gt; LogUtils.d(<span class=\"string\">\"+++++++++\"</span> + Thread.currentThread()));</span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>从以上的内容我们可以看出，<code>Handler</code> 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 <code>ThreadLocal</code> 来对每个线程对应的<code>Looper</code>中的消息队列进行存储。</p>\n<h2 id=\"2、源码解析\"><a href=\"#2、源码解析\" class=\"headerlink\" title=\"2、源码解析\"></a>2、源码解析</h2><p>以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。</p>\n<h3 id=\"2-1-实例化-Handler\"><a href=\"#2-1-实例化-Handler\" class=\"headerlink\" title=\"2.1 实例化 Handler\"></a>2.1 实例化 Handler</h3><p><code>Handler</code> 提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 <code>Looper</code>，另一种在构造方法中不需要指定任何 <code>Looper</code>，在构造方法内部会获取当前线程对应的 <code>Looper</code> 来初始化 Handler。<br>第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    mQueue = looper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种初始化的方式最终会调用下面的方法。这里使用 <code>Looper</code> 的静态方法 <code>myLooper()</code> 来获取当前线程对应的 <code>Looper</code>。如果当前线程不存在任何 Looper 就会抛出一个异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 潜在内存泄漏的检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper</span></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 Looper 的静态方法 <code>myLooper()</code> 会使用线程局部变量 <code>sThreadLocal</code> 来获取之前存储到该线程内部的 Looper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">Looper <span class=\"title\">myLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-Looper-的初始化\"><a href=\"#2-2-Looper-的初始化\" class=\"headerlink\" title=\"2.2 Looper 的初始化\"></a>2.2 Looper 的初始化</h3><p>前面我们也说过 <code>Looper</code> 的创建过程。对于主线程的 <code>Looper</code> 会在 <code>ActivityThread</code> 的 <code>main()</code> 方法中被调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">      Looper.prepareMainLooper();</span><br><span class=\"line\">      <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">      <span class=\"comment\">// 开启 Looper 循环</span></span><br><span class=\"line\">      Looper.loop();</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了 <code>Looper</code> 的静态方法 <code>prepareMainLooper()</code> 来初始化主线程的 Looper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          sMainLooper = myLooper();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其内部先调用了 <code>prepare(boolean)</code> 方法来初始化一个 <code>Looper</code> 并将其放在线程局部变量 <code>sThreadLocal</code> 中，然后判断 <code>sMainLooper</code> 是否之前存在过。这是一种基本的<strong>单例校验</strong>，显然，我们只允许主线程的 Looper 被实例化一次。<br>同样，非主线程的 <code>Looper</code> 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 <code>prepare()</code> 静态方法。它同样调用了  <code>prepare(boolean)</code> 方法来初始化一个 <code>Looper</code> 并将其放在线程局部变量 <code>sThreadLocal</code> 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。</p>\n<p>下面是 <code>prepare()</code> 方法的代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>经过上述分析，我们可以得知，对于<strong>一个线程只能实例化一个 <code>Looper</code></strong>，所以当我们在同一个线程中多次创建 Handler 实例，它们是<strong>共享一个 Looper</strong> 。或者说是一个 Looper 对应多个 Handler 也是可以的。</p>\n<h3 id=\"2-3-MessageQueue-的实例化\"><a href=\"#2-3-MessageQueue-的实例化\" class=\"headerlink\" title=\"2.3 MessageQueue 的实例化\"></a>2.3 MessageQueue 的实例化</h3><p>相比于 <code>Looper</code> 和 <code>Handler</code>，<code>MessageQueue</code> 就显得相对复杂一些。因为内部用到了 <code>JNI</code> 编程。初始化、销毁和入队等事件都用到了 <code>native</code> 的方法。你可以在 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp\" target=\"_blank\" rel=\"noopener\"><code>android_os_MessageQueue</code></a> 查看其源码的定义。<br>每当我们实例化一个 <code>Looper</code> 的时候会调用它的构造方法，并在其中实例化一个 <code>MessageQueue</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实例化 <code>Handler</code> 的小节中可以看出，每次实例化一个 <code>Handler</code> 的时候，会从当前线程对应的 <code>Looper</code> 中取出 <code>MessageQueue</code>。所以，这里我们又可以得出结论:</p>\n<blockquote>\n<p><strong>一个 Handler 对应一个 MessageQueue</strong>。</p>\n</blockquote>\n<p>当我们实例化一个 <code>MessageQueue</code> 的时候会使用它的构造方法。这里会调用 <code>native</code> 层的 <code>nativeInit()</code> 方法来完成 MessageQueue 的初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 native 层，<code>nativeInit()</code> 方法的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> jlong <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!nativeMessageQueue) &#123;</span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面我们可以看出，在该方法中实例化了一个<code>NativeMessageQueue</code> 之后返回了 <strong>mPtr</strong> 作为是 Java 层 <code>MessageQueue</code> 与<code>NativeMessesageQueue</code> 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 <code>MessageQueue</code> 同样使用 <strong>mPtr</strong> 来表示 <code>native</code> 层的消息队列。<code>NativeMessageQueue</code> 在 <code>native</code> 层的部分定义和其构造方法的定义如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class NativeMessageQueue : public MessageQueue, public LooperCallback &#123;</span><br><span class=\"line\"><span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">NativeMessageQueue::NativeMessageQueue() :</span><br><span class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class=\"line\">    mLooper = Looper::getForThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == NULL) &#123;</span><br><span class=\"line\">        mLooper = <span class=\"keyword\">new</span> Looper(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        Looper::setForThread(mLooper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出，<code>NativeMessageQueue</code> 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper （其源码在 <a href=\"https://android.googlesource.com/platform/system/core/+/master/libutils/Looper.cpp\" target=\"_blank\" rel=\"noopener\">Looper</a>）。</p>\n<p>在 Android 的 <code>native</code> 层存在着一个于 <code>Java</code> 层类似的 <code>Looper</code>，<strong>它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信</strong>。当消息队列中有消息存入时，会唤醒 Native 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Native 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。</p>\n<p>既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？</p>\n<blockquote>\n<p>这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长以至于无法处理其他事件的时候才会出现 ANR。<br>上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果之前存在的话就关闭之前的 epoll 实例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollFd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mEpollFd.reset(); <span class=\"comment\">// 关闭旧的epoll实例</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 申请新的 epoll 实例，并且注册 “Wake管道”</span></span><br><span class=\"line\">    mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT));</span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"Could not create epoll instance: %s\"</span>, strerror(errno));</span><br><span class=\"line\">    struct epoll_event eventItem;</span><br><span class=\"line\">    <span class=\"comment\">// 把未使用的数据区域进行置0操作</span></span><br><span class=\"line\">    memset(&amp; eventItem, <span class=\"number\">0</span>, sizeof(epoll_event));</span><br><span class=\"line\">    eventItem.events = EPOLLIN;</span><br><span class=\"line\">    eventItem.data.fd = mWakeEventFd.get();</span><br><span class=\"line\">    <span class=\"comment\">// 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem);</span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(result != <span class=\"number\">0</span>, <span class=\"string\">\"Could not add wake event fd to epoll instance: %s\"</span>, strerror(errno));</span><br><span class=\"line\">    <span class=\"comment\">// 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t i = <span class=\"number\">0</span>; i &lt; mRequests.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> Request&amp; request = mRequests.valueAt(i);</span><br><span class=\"line\">        struct epoll_event eventItem;</span><br><span class=\"line\">        request.initEventItem(&amp;eventItem);</span><br><span class=\"line\">        <span class=\"comment\">// 将 request 队列的事件，分别添加到 epoll 实例</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里涉及了 <a href=\"https://baike.baidu.com/item/epoll/10738144?fr=aladdin\" target=\"_blank\" rel=\"noopener\">epoll</a> 相关的知识。<code>epoll</code> 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，<strong>整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的</strong>，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。<br>上面的代码中使用了 <code>epoll_ctl</code> 方法来将被监听的描述符添加到 <code>epoll</code> 句柄。关于 <code>epoll</code> 的指令，可以参考这篇博文 <a href=\"https://blog.csdn.net/yusiguyuan/article/details/15027821\" target=\"_blank\" rel=\"noopener\">《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》</a>。这部分代码的主要作用是创建一个 <code>epoll</code> 实例并用它来监听 <code>event</code> 触发。</p>\n<h2 id=\"2-4-消息的执行过程\"><a href=\"#2-4-消息的执行过程\" class=\"headerlink\" title=\"2.4 消息的执行过程\"></a>2.4 消息的执行过程</h2><h3 id=\"2-4-1-消息入队的过程\"><a href=\"#2-4-1-消息入队的过程\" class=\"headerlink\" title=\"2.4.1 消息入队的过程\"></a>2.4.1 消息入队的过程</h3><p>在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？<br>首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看出，入队的时候实际上是使用了 <code>MessageQueue</code> 的 <code>enqueueMessage()</code> 方法。所以，我们再来看下该方法的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 无关代码，校验</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。<br>这里的 <code>nativeWake()</code> 方法会最终调用 <code>native</code> 层的 Looper 的 <code>awake()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;</span><br><span class=\"line\">    uint64_t inc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t)));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nWrite != sizeof(uint64_t)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno != EAGAIN) &#123;</span><br><span class=\"line\">            LOG_ALWAYS_FATAL(<span class=\"string\">\"Could not write wake signal to fd %d: %s\"</span>, mWakeEventFd.get(), strerror(errno));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-2-消息执行的过程\"><a href=\"#2-4-2-消息执行的过程\" class=\"headerlink\" title=\"2.4.2 消息执行的过程\"></a>2.4.2 消息执行的过程</h3><p>在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"comment\">// .. 无关代码</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\">    <span class=\"comment\">// .. 无关代码</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 可能会 bolck</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> dispatchEnd;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                Trace.traceEnd(traceTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 <code>MessageQueue</code> 的 <code>next()</code> 方法来取出下一个消息并进行分发。这里我们先不看 <code>next()</code> 方法的定义。我们先把这个方法中涉及的部分分析一下。<br>当获取到了下一个消息之后，会调用它的<code>target</code> 也就是发送该消息的 <code>Handler</code> 的 <code>dispatchMessage()</code> 方法来进行处理。该方法的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看出，如果该消息是通过包装 <code>Runnable</code> 得到的话，会直接调用它的 <code>handleCallback()</code> 方法进行处理。在该方法内部会直接调用 Runnable 的  <code>run()</code> 方法。因为比较见到那，我们就不贴出代码了。<br>然后，会根据 <code>mCallback</code> 是否为空来决定是交给 <code>mCallback</code> 进行处理还是内部的 <code>handleMessage()</code> 方法。这里的 <code>mCallback</code> 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 <code>handleMessage()</code> 方法，我们就再熟悉不过了，它就是我们创建 <code>Handler</code> 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 <code>Handler</code> 中进行处理了。<br>以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 <code>MessageQueue</code> 是如何获取 “下一个” 消息的。</p>\n<h3 id=\"2-4-3-MessageQueue-的消息管理\"><a href=\"#2-4-3-MessageQueue-的消息管理\" class=\"headerlink\" title=\"2.4.3 MessageQueue 的消息管理\"></a>2.4.3 MessageQueue 的消息管理</h3><p>上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 native 的方法，可能会这个函数发生 block</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看出 Java 层的 <code>MessageQueue</code> 的 <code>next()</code> 方法是一个循环。除了获取消息队列之外，还要监听<code>Natvie</code> 层 <code>Looper</code> 的事件触发。通过调用 native 层的 <code>nativePollOnce()</code> 方法来实现。该方法内部又会调用 <code>NativeMessageQueue</code> 的 <code>pollOnce()</code> 方法。而且注意下，在下面的方法中，<code>nativeMessageQueue</code> 是从 Java 层的 <strong>mPtr</strong> 中获取到的。所以我们说，在初始化 <code>MessageQueue</code> 的时候得到的 <strong>mPtr</strong> 起到了桥梁的作用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>NativeMessageQueue</code> 的 <code>pollOnce()</code> 方法中会调用 <code>native</code> 层的 Looper 的 <code>pollOnce()</code>，并最终调用 native 层 Looper 的 <code>pollInner()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 根据下一个消息的事件调整超时时间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = POLL_WAKE;</span><br><span class=\"line\">    mResponses.clear();</span><br><span class=\"line\">    mResponseIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mPolling = <span class=\"keyword\">true</span>; <span class=\"comment\">// 将要空闲</span></span><br><span class=\"line\">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class=\"line\">    <span class=\"comment\">// 待已注册之事件被触发或计时终了</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    mPolling = <span class=\"keyword\">false</span>; <span class=\"comment\">// 不再空闲</span></span><br><span class=\"line\">    mLock.lock(); <span class=\"comment\">// 请求锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollRebuildRequired) &#123;</span><br><span class=\"line\">        mEpollRebuildRequired = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        rebuildEpollLocked(); <span class=\"comment\">// 根据需要重建 epoll</span></span><br><span class=\"line\">        goto Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 进行检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;</span><br><span class=\"line\">            goto Done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result = POLL_ERROR; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">        goto Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        result = POLL_TIMEOUT; <span class=\"comment\">// 超时</span></span><br><span class=\"line\">        goto Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 处理所有消息</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;</span><br><span class=\"line\">        uint32_t epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeEventFd.get()) &#123; <span class=\"comment\">// 唤醒 fd 有反应</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                awoken(); <span class=\"comment\">// 已经唤醒了，则读取并清空管道数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理</span></span><br><span class=\"line\">            ssize_t requestIndex = mRequests.indexOfKey(fd);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class=\"line\">                <span class=\"comment\">// 将消息放进 mResponses 中</span></span><br><span class=\"line\">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\">    <span class=\"comment\">// 触发所有的消息回调，处理 Native 层的Message</span></span><br><span class=\"line\">    mNextMessageUptime = LLONG_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (mMessageEnvelopes.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class=\"line\">            &#123; <span class=\"comment\">// 获取 handler</span></span><br><span class=\"line\">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class=\"line\">                Message message = messageEnvelope.message;</span><br><span class=\"line\">                mMessageEnvelopes.removeAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">                mSendingMessage = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                mLock.unlock();</span><br><span class=\"line\">                handler-&gt;handleMessage(message);</span><br><span class=\"line\">            &#125; <span class=\"comment\">// 释放 handler</span></span><br><span class=\"line\">            mLock.lock();</span><br><span class=\"line\">            mSendingMessage = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            result = POLL_CALLBACK;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队列头部的消息决定了下个唤醒的时间</span></span><br><span class=\"line\">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mLock.unlock(); <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">    <span class=\"comment\">// 触发所有的响应回调</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t i = <span class=\"number\">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class=\"line\">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> fd = response.request.fd;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> events = response.events;</span><br><span class=\"line\">            <span class=\"keyword\">void</span>* data = response.request.data;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callbackResult == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                removeFd(fd, response.request.seq); <span class=\"comment\">// 移除文件描述符</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            response.request.callback.clear();</span><br><span class=\"line\">            result = POLL_CALLBACK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出 Native 层的 <code>pollInner()</code> 方法首先会根据 Java 层传入的 <code>timeoutMillis</code> 调用 <code>epoll_wait</code> 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 <code>enqueueMessage()</code> 方法的最后几行代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">    nativeWake(mPtr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。<br>上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。</p>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><p>在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。</p>\n<h3 id=\"3-1-Handler、MessageQueue-和-Looper-之间的关系\"><a href=\"#3-1-Handler、MessageQueue-和-Looper-之间的关系\" class=\"headerlink\" title=\"3.1 Handler、MessageQueue 和 Looper 之间的关系\"></a>3.1 Handler、MessageQueue 和 Looper 之间的关系</h3><p>首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0ncjal5w5j30ia07x0te.jpg\" alt=\"HandlerMessageQueueLooper\" title=\"\">\n                </div>\n                <div class=\"image-caption\">HandlerMessageQueueLooper</div>\n            </figure></p>\n<p>也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。</p>\n<h3 id=\"3-2-Handler-的消息发送过程\"><a href=\"#3-2-Handler-的消息发送过程\" class=\"headerlink\" title=\"3.2 Handler 的消息发送过程\"></a>3.2 Handler 的消息发送过程</h3><p>然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0nck94sjfj30j405qjsc.jpg\" alt=\"Handler\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Handler</div>\n            </figure>\n<p>根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 <code>Message</code> 类型的数据。但不论哪种类型最终都会调用 Handler 的 <code>sendMessageAtTime()</code> 方法来加入到 <code>MessageQueue</code> 的队列中。区别在于，post 类型的方法需要经过 Handler 的 <code>getPostMessage()</code> 包装成 Message 之后再发送。</p>\n<h3 id=\"3-3-Looper-的执行过程\"><a href=\"#3-3-Looper-的执行过程\" class=\"headerlink\" title=\"3.3 Looper 的执行过程\"></a>3.3 Looper 的执行过程</h3><p>当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 <code>loop()</code> 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0nclv8eauj30jn09ywg2.jpg\" alt=\"Looper\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Looper</div>\n            </figure>\n<p>当我们调用 Looper 的 <code>loop()</code>方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 <code>next()</code> 方法来获取下一个消息的时候，会调用 <code>nativePollOnce()</code> 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android-消息机制：Handler、MessageQueue-和-Looper\"><a href=\"#Android-消息机制：Handler、MessageQueue-和-Looper\" class=\"headerlink\" title=\"Android 消息机制：Handler、MessageQueue 和 Looper\"></a>Android 消息机制：Handler、MessageQueue 和 Looper</h1><p>在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。<br>在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：</p>","more":"<h2 id=\"1、Handler-的作用\"><a href=\"#1、Handler-的作用\" class=\"headerlink\" title=\"1、Handler 的作用\"></a>1、Handler 的作用</h2><p>通常，当我们在非主线程当中做了异步的操作之后使用 <code>Handler</code> 来在主线程当中更新 UI。之所以这么设计无非就是因为 <code>Android</code> 中的 <code>View</code> 不是线程安全的。之所以将 <code>View</code> 设计成非线程安全的，是因为：</p>\n<blockquote>\n<p>1).对 <code>View</code> 进行加锁之后会增加控件使用的复杂度；<br>2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI，</p>\n</blockquote>\n<p><strong>确切来说它有两个作用：</strong></p>\n<ol>\n<li>任务调度：即通过 <code>post()</code> 和 <code>send()</code> 等方法来指定某个任务在某个时间执行；</li>\n<li>线程切换：你也许用过 <code>RxJava</code>，但如果在 <code>Android</code> 中使用的话还要配合 <code>RxAndroid</code>，而这里的 <code>RxAndroid</code> 内部就使用 <code>Handler</code> 来实现线程切换。</li>\n</ol>\n<p>下文中，我们就来分别看一下它的这两个功能的作用和原理。</p>\n<h3 id=\"1-1-任务调度\"><a href=\"#1-1-任务调度\" class=\"headerlink\" title=\"1.1 任务调度\"></a>1.1 任务调度</h3><p><strong>使用 <code>Hanlder</code> 可以让一个任务在某个时间点执行或者等待某段时间之后执行</strong>。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 <code>post()</code> 和 <code>sned()</code> 两类方法。<code>post()</code> 类的用来指定某个 <code>Runnable</code> 在<strong>某个时间点执行</strong>，<code>send()</code> 类的用来指定某个 <code>Message</code> 在某个时间点执行。<br>这里的 <strong><code>Message</code></strong> 是 <code>Android</code> 中定义的一个类。它内部有多个字段，比如 <code>what</code>、<code>arg1</code>、<code>arg2</code>、<code>replyTo</code> 和 <code>sendingUid</code> 来帮助我们指定该消息的内容和对象。同时， <code>Message</code> 还实现了 <code>Parcelable</code> 接口，这表明<strong>它可以被用来跨进程传输</strong>。此外，它内部还定义了一个 <code>Message</code> 类型的 <code>next</code> 字段，这表明 <code>Message</code> 可以被用作链表的结点。实际上 <code>MessageQueue</code> 里面只存放了一个 <code>mMessage</code>，即链表的<strong>头结点</strong>。所以，<code>MessageQueue</code> 内部的消息队列，本质上是一个<strong>单链表</strong>，每个链表的结点就是 <code>Message</code>。<br>当调用 <code>post()</code> 类型的方法来调度某个 <code>Runnable</code> 的时候，首先会将其包装成一个 <code>Message</code>，然后再使用 <code>send()</code>类的方法进行任务分发。所以，不论是 <code>post()</code> 类的方法还是 <code>send()</code> 类的方法，最终都会使用 <code>Handler</code>  的 <code>sendMessageAtTime()</code> 方法来将其加入到队列中：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 <code>Handler</code> 进行任务调度是非常简单的。下面的代码就实现了让一个 <code>Runnable</code> 在 <code>500ms</code> 之后执行的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Handler().postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。<br>既然每个 <code>Runnable</code> 被 <code>post()</code> 发送之后还要被包装成 <code>Message</code>，那么 <code>Message</code> 的意义何在呢？<br><code>Runnable</code> 被包装的过程依赖于 <code>Handler</code> 内部的 <code>getPostMessage()</code> 方法。下面是该方法的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Message <span class=\"title\">getPostMessage</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    Message m = Message.obtain();</span><br><span class=\"line\">    m.callback = r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见，我们的 <code>Runnable</code> 会被赋值给 <code>Message</code> 的 <code>callback</code>。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要：</p>\n<ol>\n<li>首先，要使用 <code>send()</code> 类型的方法来传递我们的 <code>Message</code> 给 <code>Handler</code>；</li>\n<li>然后，我们的 <code>Handler</code> 要覆写 <code>handleMessage()</code> 方法，并在该方法中获取每个 <code>Message</code> 并根据其内部的信息依次处理。</li>\n</ol>\n<p>下面的一个例子用来演示 <code>send()</code> 类型的方法。首先，我们要定义 <code>Handler</code> 并覆写其 <code>handleMessage()</code> 方法来处理消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> SAY_HELLO = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Handler handler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SAY_HELLO:</span><br><span class=\"line\">                LogUtils.d(<span class=\"string\">\"Hello!\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后，我们向该 Handler 发送消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message message = Message.obtain(handler);</span><br><span class=\"line\">message.what = SAY_HELLO;</span><br><span class=\"line\">message.sendToTarget();</span><br></pre></td></tr></table></figure>\n<p>这样，我们的 <code>Handler</code> 接收到了消息并根据其 <code>what</code> 得知要 <code>SAY_HELLO</code>，于是就打印出了日志信息。除了调用 <code>Message</code> 的 <code>sendToTarget()</code> 方法，我们还可以直接调用 <code>handler</code> 的 <code>sendMessage()</code> 方法（<code>sendToTarget()</code> 内部调用了 <code>handler</code> 的 <code>sendMessage()</code>）。</p>\n<h2 id=\"1-2-线程切换\"><a href=\"#1-2-线程切换\" class=\"headerlink\" title=\"1.2 线程切换\"></a>1.2 线程切换</h2><p>下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在主线程中获取 Handler</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Handler handler = <span class=\"keyword\">new</span> Handler();\t\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新UI，会将消息发送到主线程当中</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        handler.post(() -&gt; getBinding().tv.setText(<span class=\"string\">\"主线程更新UI\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>上面之所以能够在主线程当中更新 UI，主要是因为<strong>我们的 <code>Handler</code> 是在主线程当中进行获取的</strong>。随后，我们调用 <code>handler</code> 的 <code>post()</code> 方法之后，传入的 <code>Runnable</code> 会被包装成 <code>Message</code>，然后加入到主线程对应的消息队列中去，并由主线程对应的 <code>Looper</code> 获取到并执行。所以，就使得该 <code>Runnable</code> 的操作最终在主线程中完成。<br>也许你会觉得先在主线程当中获取到 <code>Handler</code> 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 <code>Looper</code> 的 <code>getMainLooper()</code> 方法来获取主线程对应的 <code>Looper</code>，然后使用它来实例化一个 <code>Handler</code> 并使用该 <code>Handler</code>来处理消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Handler(Looper.getMainLooper())</span><br><span class=\"line\">    .post(() -&gt; getBinding().tv.setText(<span class=\"string\">\"主线程更新UI\"</span>));</span><br></pre></td></tr></table></figure>\n<p>本质上，当我们调用 <code>Handler</code> 的无参构造方法，或者说不指定 <code>Looper</code> 的构造方法的时候，会直接使用当前线程对应的 <code>Looper</code> 来实例化 <code>Handler</code>。每个线程对应的 <code>Looper</code> 存储在该线程的局部变量 <code>ThreadLocal</code> 里。当某个线程的局部变量里面没有 <code>Looper</code> 的时候就会抛出一个<strong>异常</strong>。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。<br><strong>主线程对应的 <code>Looper</code> 会在 <code>ActivityThread</code> 的静态方法 <code>main()</code> 中被创建，它会调用 <code>Looper</code> 的 <code>prepareMainLooper()</code> 静态方法来创建主线程对应的 Looper。</strong>然后会调用 <code>Looper</code> 的 <code>loop()</code> 静态方法来开启 Looper 循环以不断处理消息。这里的 <code>ActivityThread</code> 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。<code>ActivityThread</code> 内部定义了一个内部类 <code>H</code>，它继承自 <code>Handler</code>，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。<br>除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 <code>Looper</code>。下面的代码中，<strong>我们开启了一个线程，并在线程中先调用 <code>Looper</code> 的 <code>prepare()</code> 静态方法，此时 <code>Looper</code> 会为我们当前的线程创建 <code>Looper</code>，</strong>然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    LogUtils.d(<span class=\"string\">\"+++++++++\"</span> + Thread.currentThread());</span><br><span class=\"line\">    Looper.prepare();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Handler().post(() -&gt; LogUtils.d(<span class=\"string\">\"+++++++++\"</span> + Thread.currentThread()));</span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>从以上的内容我们可以看出，<code>Handler</code> 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 <code>ThreadLocal</code> 来对每个线程对应的<code>Looper</code>中的消息队列进行存储。</p>\n<h2 id=\"2、源码解析\"><a href=\"#2、源码解析\" class=\"headerlink\" title=\"2、源码解析\"></a>2、源码解析</h2><p>以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。</p>\n<h3 id=\"2-1-实例化-Handler\"><a href=\"#2-1-实例化-Handler\" class=\"headerlink\" title=\"2.1 实例化 Handler\"></a>2.1 实例化 Handler</h3><p><code>Handler</code> 提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 <code>Looper</code>，另一种在构造方法中不需要指定任何 <code>Looper</code>，在构造方法内部会获取当前线程对应的 <code>Looper</code> 来初始化 Handler。<br>第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    mQueue = looper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种初始化的方式最终会调用下面的方法。这里使用 <code>Looper</code> 的静态方法 <code>myLooper()</code> 来获取当前线程对应的 <code>Looper</code>。如果当前线程不存在任何 Looper 就会抛出一个异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 潜在内存泄漏的检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper</span></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 Looper 的静态方法 <code>myLooper()</code> 会使用线程局部变量 <code>sThreadLocal</code> 来获取之前存储到该线程内部的 Looper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">Looper <span class=\"title\">myLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sThreadLocal.get();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-Looper-的初始化\"><a href=\"#2-2-Looper-的初始化\" class=\"headerlink\" title=\"2.2 Looper 的初始化\"></a>2.2 Looper 的初始化</h3><p>前面我们也说过 <code>Looper</code> 的创建过程。对于主线程的 <code>Looper</code> 会在 <code>ActivityThread</code> 的 <code>main()</code> 方法中被调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">      Looper.prepareMainLooper();</span><br><span class=\"line\">      <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">      <span class=\"comment\">// 开启 Looper 循环</span></span><br><span class=\"line\">      Looper.loop();</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了 <code>Looper</code> 的静态方法 <code>prepareMainLooper()</code> 来初始化主线程的 Looper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          sMainLooper = myLooper();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其内部先调用了 <code>prepare(boolean)</code> 方法来初始化一个 <code>Looper</code> 并将其放在线程局部变量 <code>sThreadLocal</code> 中，然后判断 <code>sMainLooper</code> 是否之前存在过。这是一种基本的<strong>单例校验</strong>，显然，我们只允许主线程的 Looper 被实例化一次。<br>同样，非主线程的 <code>Looper</code> 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 <code>prepare()</code> 静态方法。它同样调用了  <code>prepare(boolean)</code> 方法来初始化一个 <code>Looper</code> 并将其放在线程局部变量 <code>sThreadLocal</code> 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。</p>\n<p>下面是 <code>prepare()</code> 方法的代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>经过上述分析，我们可以得知，对于<strong>一个线程只能实例化一个 <code>Looper</code></strong>，所以当我们在同一个线程中多次创建 Handler 实例，它们是<strong>共享一个 Looper</strong> 。或者说是一个 Looper 对应多个 Handler 也是可以的。</p>\n<h3 id=\"2-3-MessageQueue-的实例化\"><a href=\"#2-3-MessageQueue-的实例化\" class=\"headerlink\" title=\"2.3 MessageQueue 的实例化\"></a>2.3 MessageQueue 的实例化</h3><p>相比于 <code>Looper</code> 和 <code>Handler</code>，<code>MessageQueue</code> 就显得相对复杂一些。因为内部用到了 <code>JNI</code> 编程。初始化、销毁和入队等事件都用到了 <code>native</code> 的方法。你可以在 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp\" target=\"_blank\" rel=\"noopener\"><code>android_os_MessageQueue</code></a> 查看其源码的定义。<br>每当我们实例化一个 <code>Looper</code> 的时候会调用它的构造方法，并在其中实例化一个 <code>MessageQueue</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实例化 <code>Handler</code> 的小节中可以看出，每次实例化一个 <code>Handler</code> 的时候，会从当前线程对应的 <code>Looper</code> 中取出 <code>MessageQueue</code>。所以，这里我们又可以得出结论:</p>\n<blockquote>\n<p><strong>一个 Handler 对应一个 MessageQueue</strong>。</p>\n</blockquote>\n<p>当我们实例化一个 <code>MessageQueue</code> 的时候会使用它的构造方法。这里会调用 <code>native</code> 层的 <code>nativeInit()</code> 方法来完成 MessageQueue 的初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 native 层，<code>nativeInit()</code> 方法的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> jlong <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> NativeMessageQueue();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!nativeMessageQueue) &#123;</span><br><span class=\"line\">        jniThrowRuntimeException(env, <span class=\"string\">\"Unable to allocate native queue\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面我们可以看出，在该方法中实例化了一个<code>NativeMessageQueue</code> 之后返回了 <strong>mPtr</strong> 作为是 Java 层 <code>MessageQueue</code> 与<code>NativeMessesageQueue</code> 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 <code>MessageQueue</code> 同样使用 <strong>mPtr</strong> 来表示 <code>native</code> 层的消息队列。<code>NativeMessageQueue</code> 在 <code>native</code> 层的部分定义和其构造方法的定义如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class NativeMessageQueue : public MessageQueue, public LooperCallback &#123;</span><br><span class=\"line\"><span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">NativeMessageQueue::NativeMessageQueue() :</span><br><span class=\"line\">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class=\"line\">    mLooper = Looper::getForThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == NULL) &#123;</span><br><span class=\"line\">        mLooper = <span class=\"keyword\">new</span> Looper(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        Looper::setForThread(mLooper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出，<code>NativeMessageQueue</code> 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper （其源码在 <a href=\"https://android.googlesource.com/platform/system/core/+/master/libutils/Looper.cpp\" target=\"_blank\" rel=\"noopener\">Looper</a>）。</p>\n<p>在 Android 的 <code>native</code> 层存在着一个于 <code>Java</code> 层类似的 <code>Looper</code>，<strong>它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信</strong>。当消息队列中有消息存入时，会唤醒 Native 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Native 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。</p>\n<p>既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？</p>\n<blockquote>\n<p>这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长以至于无法处理其他事件的时候才会出现 ANR。<br>上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果之前存在的话就关闭之前的 epoll 实例</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollFd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        mEpollFd.reset(); <span class=\"comment\">// 关闭旧的epoll实例</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 申请新的 epoll 实例，并且注册 “Wake管道”</span></span><br><span class=\"line\">    mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT));</span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"Could not create epoll instance: %s\"</span>, strerror(errno));</span><br><span class=\"line\">    struct epoll_event eventItem;</span><br><span class=\"line\">    <span class=\"comment\">// 把未使用的数据区域进行置0操作</span></span><br><span class=\"line\">    memset(&amp; eventItem, <span class=\"number\">0</span>, sizeof(epoll_event));</span><br><span class=\"line\">    eventItem.events = EPOLLIN;</span><br><span class=\"line\">    eventItem.data.fd = mWakeEventFd.get();</span><br><span class=\"line\">    <span class=\"comment\">// 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd)</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem);</span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(result != <span class=\"number\">0</span>, <span class=\"string\">\"Could not add wake event fd to epoll instance: %s\"</span>, strerror(errno));</span><br><span class=\"line\">    <span class=\"comment\">// 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t i = <span class=\"number\">0</span>; i &lt; mRequests.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> Request&amp; request = mRequests.valueAt(i);</span><br><span class=\"line\">        struct epoll_event eventItem;</span><br><span class=\"line\">        request.initEventItem(&amp;eventItem);</span><br><span class=\"line\">        <span class=\"comment\">// 将 request 队列的事件，分别添加到 epoll 实例</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里涉及了 <a href=\"https://baike.baidu.com/item/epoll/10738144?fr=aladdin\" target=\"_blank\" rel=\"noopener\">epoll</a> 相关的知识。<code>epoll</code> 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，<strong>整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的</strong>，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。<br>上面的代码中使用了 <code>epoll_ctl</code> 方法来将被监听的描述符添加到 <code>epoll</code> 句柄。关于 <code>epoll</code> 的指令，可以参考这篇博文 <a href=\"https://blog.csdn.net/yusiguyuan/article/details/15027821\" target=\"_blank\" rel=\"noopener\">《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》</a>。这部分代码的主要作用是创建一个 <code>epoll</code> 实例并用它来监听 <code>event</code> 触发。</p>\n<h2 id=\"2-4-消息的执行过程\"><a href=\"#2-4-消息的执行过程\" class=\"headerlink\" title=\"2.4 消息的执行过程\"></a>2.4 消息的执行过程</h2><h3 id=\"2-4-1-消息入队的过程\"><a href=\"#2-4-1-消息入队的过程\" class=\"headerlink\" title=\"2.4.1 消息入队的过程\"></a>2.4.1 消息入队的过程</h3><p>在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？<br>首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看出，入队的时候实际上是使用了 <code>MessageQueue</code> 的 <code>enqueueMessage()</code> 方法。所以，我们再来看下该方法的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 无关代码，校验</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。<br>这里的 <code>nativeWake()</code> 方法会最终调用 <code>native</code> 层的 Looper 的 <code>awake()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> Looper::wake() &#123;</span><br><span class=\"line\">    uint64_t inc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t)));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nWrite != sizeof(uint64_t)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno != EAGAIN) &#123;</span><br><span class=\"line\">            LOG_ALWAYS_FATAL(<span class=\"string\">\"Could not write wake signal to fd %d: %s\"</span>, mWakeEventFd.get(), strerror(errno));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-2-消息执行的过程\"><a href=\"#2-4-2-消息执行的过程\" class=\"headerlink\" title=\"2.4.2 消息执行的过程\"></a>2.4.2 消息执行的过程</h3><p>在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"comment\">// .. 无关代码</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\">    <span class=\"comment\">// .. 无关代码</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// 可能会 bolck</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> dispatchEnd;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                Trace.traceEnd(traceTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 <code>MessageQueue</code> 的 <code>next()</code> 方法来取出下一个消息并进行分发。这里我们先不看 <code>next()</code> 方法的定义。我们先把这个方法中涉及的部分分析一下。<br>当获取到了下一个消息之后，会调用它的<code>target</code> 也就是发送该消息的 <code>Handler</code> 的 <code>dispatchMessage()</code> 方法来进行处理。该方法的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看出，如果该消息是通过包装 <code>Runnable</code> 得到的话，会直接调用它的 <code>handleCallback()</code> 方法进行处理。在该方法内部会直接调用 Runnable 的  <code>run()</code> 方法。因为比较见到那，我们就不贴出代码了。<br>然后，会根据 <code>mCallback</code> 是否为空来决定是交给 <code>mCallback</code> 进行处理还是内部的 <code>handleMessage()</code> 方法。这里的 <code>mCallback</code> 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 <code>handleMessage()</code> 方法，我们就再熟悉不过了，它就是我们创建 <code>Handler</code> 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 <code>Handler</code> 中进行处理了。<br>以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 <code>MessageQueue</code> 是如何获取 “下一个” 消息的。</p>\n<h3 id=\"2-4-3-MessageQueue-的消息管理\"><a href=\"#2-4-3-MessageQueue-的消息管理\" class=\"headerlink\" title=\"2.4.3 MessageQueue 的消息管理\"></a>2.4.3 MessageQueue 的消息管理</h3><p>上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 native 的方法，可能会这个函数发生 block</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\">        <span class=\"comment\">// ... 无关代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看出 Java 层的 <code>MessageQueue</code> 的 <code>next()</code> 方法是一个循环。除了获取消息队列之外，还要监听<code>Natvie</code> 层 <code>Looper</code> 的事件触发。通过调用 native 层的 <code>nativePollOnce()</code> 方法来实现。该方法内部又会调用 <code>NativeMessageQueue</code> 的 <code>pollOnce()</code> 方法。而且注意下，在下面的方法中，<code>nativeMessageQueue</code> 是从 Java 层的 <strong>mPtr</strong> 中获取到的。所以我们说，在初始化 <code>MessageQueue</code> 的时候得到的 <strong>mPtr</strong> 起到了桥梁的作用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>NativeMessageQueue</code> 的 <code>pollOnce()</code> 方法中会调用 <code>native</code> 层的 Looper 的 <code>pollOnce()</code>，并最终调用 native 层 Looper 的 <code>pollInner()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> Looper::pollInner(<span class=\"keyword\">int</span> timeoutMillis) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 根据下一个消息的事件调整超时时间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = POLL_WAKE;</span><br><span class=\"line\">    mResponses.clear();</span><br><span class=\"line\">    mResponseIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mPolling = <span class=\"keyword\">true</span>; <span class=\"comment\">// 将要空闲</span></span><br><span class=\"line\">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class=\"line\">    <span class=\"comment\">// 待已注册之事件被触发或计时终了</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    mPolling = <span class=\"keyword\">false</span>; <span class=\"comment\">// 不再空闲</span></span><br><span class=\"line\">    mLock.lock(); <span class=\"comment\">// 请求锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollRebuildRequired) &#123;</span><br><span class=\"line\">        mEpollRebuildRequired = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        rebuildEpollLocked(); <span class=\"comment\">// 根据需要重建 epoll</span></span><br><span class=\"line\">        goto Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 进行检查</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINTR) &#123;</span><br><span class=\"line\">            goto Done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result = POLL_ERROR; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">        goto Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        result = POLL_TIMEOUT; <span class=\"comment\">// 超时</span></span><br><span class=\"line\">        goto Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 处理所有消息</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd = eventItems[i].data.fd;</span><br><span class=\"line\">        uint32_t epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeEventFd.get()) &#123; <span class=\"comment\">// 唤醒 fd 有反应</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                awoken(); <span class=\"comment\">// 已经唤醒了，则读取并清空管道数据</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理</span></span><br><span class=\"line\">            ssize_t requestIndex = mRequests.indexOfKey(fd);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestIndex &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class=\"line\">                <span class=\"comment\">// 将消息放进 mResponses 中</span></span><br><span class=\"line\">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\">    <span class=\"comment\">// 触发所有的消息回调，处理 Native 层的Message</span></span><br><span class=\"line\">    mNextMessageUptime = LLONG_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (mMessageEnvelopes.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class=\"line\">            &#123; <span class=\"comment\">// 获取 handler</span></span><br><span class=\"line\">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class=\"line\">                Message message = messageEnvelope.message;</span><br><span class=\"line\">                mMessageEnvelopes.removeAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">                mSendingMessage = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                mLock.unlock();</span><br><span class=\"line\">                handler-&gt;handleMessage(message);</span><br><span class=\"line\">            &#125; <span class=\"comment\">// 释放 handler</span></span><br><span class=\"line\">            mLock.lock();</span><br><span class=\"line\">            mSendingMessage = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            result = POLL_CALLBACK;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队列头部的消息决定了下个唤醒的时间</span></span><br><span class=\"line\">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mLock.unlock(); <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">    <span class=\"comment\">// 触发所有的响应回调</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t i = <span class=\"number\">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class=\"line\">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> fd = response.request.fd;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> events = response.events;</span><br><span class=\"line\">            <span class=\"keyword\">void</span>* data = response.request.data;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callbackResult == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                removeFd(fd, response.request.seq); <span class=\"comment\">// 移除文件描述符</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            response.request.callback.clear();</span><br><span class=\"line\">            result = POLL_CALLBACK;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面我们可以看出 Native 层的 <code>pollInner()</code> 方法首先会根据 Java 层传入的 <code>timeoutMillis</code> 调用 <code>epoll_wait</code> 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 <code>enqueueMessage()</code> 方法的最后几行代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">    nativeWake(mPtr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。<br>上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。</p>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><p>在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。</p>\n<h3 id=\"3-1-Handler、MessageQueue-和-Looper-之间的关系\"><a href=\"#3-1-Handler、MessageQueue-和-Looper-之间的关系\" class=\"headerlink\" title=\"3.1 Handler、MessageQueue 和 Looper 之间的关系\"></a>3.1 Handler、MessageQueue 和 Looper 之间的关系</h3><p>首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0ncjal5w5j30ia07x0te.jpg\" alt=\"HandlerMessageQueueLooper\" title=\"\">\n                </div>\n                <div class=\"image-caption\">HandlerMessageQueueLooper</div>\n            </figure></p>\n<p>也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。</p>\n<h3 id=\"3-2-Handler-的消息发送过程\"><a href=\"#3-2-Handler-的消息发送过程\" class=\"headerlink\" title=\"3.2 Handler 的消息发送过程\"></a>3.2 Handler 的消息发送过程</h3><p>然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0nck94sjfj30j405qjsc.jpg\" alt=\"Handler\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Handler</div>\n            </figure>\n<p>根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 <code>Message</code> 类型的数据。但不论哪种类型最终都会调用 Handler 的 <code>sendMessageAtTime()</code> 方法来加入到 <code>MessageQueue</code> 的队列中。区别在于，post 类型的方法需要经过 Handler 的 <code>getPostMessage()</code> 包装成 Message 之后再发送。</p>\n<h3 id=\"3-3-Looper-的执行过程\"><a href=\"#3-3-Looper-的执行过程\" class=\"headerlink\" title=\"3.3 Looper 的执行过程\"></a>3.3 Looper 的执行过程</h3><p>当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 <code>loop()</code> 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0nclv8eauj30jn09ywg2.jpg\" alt=\"Looper\" title=\"\">\n                </div>\n                <div class=\"image-caption\">Looper</div>\n            </figure>\n<p>当我们调用 Looper 的 <code>loop()</code>方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 <code>next()</code> 方法来获取下一个消息的时候，会调用 <code>nativePollOnce()</code> 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。</p>"},{"title":"Android App/Activity 启动流程分析","date":"2019-03-07T07:04:06.000Z","_content":"\n#  Android App/Activity 启动流程分析\n首先我们带着问题来看:\n\n1. 点击了图标之后系统道理做了哪些工作呢？\n2. 应用进程是怎么被启动的呢？\n3. Activity 的生命周期是什么时候被谁调用的呢？\n\n本文将继续基于 **Android Nougat** 的 Frameworks 层源码的解答这些问题。\n\n阅读建议：\n如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。\n## 1.1 调用过程分析\n### 1.1.1 Launcher.onClick\n在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 `onClick` 方法，\n[packages/apps/Launcher3/src/com/android/launcher3/Launcher.java：](https://android.googlesource.com/platform/packages/apps/Launcher3/+/nougat-release/src/com/android/launcher3/Launcher.java?autodive=0%2F)\n\n\n```JAVA\npublic void onClick(View v) {\n    ...\n    Object tag = v.getTag();\n    if (tag instanceof ShortcutInfo) {\n        // 从快捷方式图标启动\n        onClickAppShortcut(v);\n    } else if (tag instanceof FolderInfo) {\n        // 文件夹\n        if (v instanceof FolderIcon) {\n           onClickFolderIcon(v);\n        }\n    } else if (v == mAllAppsButton) {\n        // “所有应用”按钮\n        onClickAllAppsButton(v);\n    } else if (tag instanceof AppInfo) {\n        // 从“所有应用”中启动的应用\n        startAppShortcutOrInfoActivity(v);\n    } else if (tag instanceof LauncherAppWidgetInfo) {\n        // 组件\n        if (v instanceof PendingAppWidgetHostView) {\n            onClickPendingWidget((PendingAppWidgetHostView) v);\n        }\n    }\n}\n\n```\n\n### 1.1.2 Launcher.onClickAppShortcut\n如果是快捷方式图标，则调用 `onClickAppShortcut` 方法进而调用 `startAppShortcutOrInfoActivity` 方法：\n\n\n```JAVA\n@Thunk void startAppShortcutOrInfoActivity(View v) {\n    Object tag = v.getTag();\n    final ShortcutInfo shortcut;\n    final Intent intent;\n    if (tag instanceof ShortcutInfo) {\n        shortcut = (ShortcutInfo) tag;\n        // 去除对应的 Intent 对象\n        intent = shortcut.intent;\n        int[] pos = new int[2];\n        v.getLocationOnScreen(pos);\n        intent.setSourceBounds(new Rect(pos[0], pos[1],\n                pos[0] + v.getWidth(), pos[1] + v.getHeight()));\n\n    } else if (tag instanceof AppInfo) {\n        shortcut = null;\n        intent = ((AppInfo) tag).intent;\n    } else {\n        throw new IllegalArgumentException(\"Input must be a Shortcut or AppInfo\");\n    }\n\n    // 调用 startActivitySafely 方法\n    boolean success = startActivitySafely(v, intent, tag);\n    mStats.recordLaunch(v, intent, shortcut);\n\n    if (success && v instanceof BubbleTextView) {\n        mWaitingForResume = (BubbleTextView) v;\n        mWaitingForResume.setStayPressed(true);\n    }\n}\n\n```\n\n### 1.1.3 Launcher.startActivity\n获取相应 App 的 **Intent** 信息之后，调用 `startActivity` 方法：\n并设置Flags为**Intent.FLAG_ACTIVITY_NEW_TASK**,启动新的任务栈\n\n```JAVA\nprivate boolean startActivity(View v, Intent intent, Object tag) {\n    // 启动新的任务栈\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    try {\n        ...\n        if (user == null || user.equals(UserHandleCompat.myUserHandle())) {\n            StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();\n            try {            \n                StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll()\n                        .penaltyLog().build());\n                // 调用 Activity 的 startActivity 方法\n                startActivity(intent, optsBundle);\n            } finally {\n                StrictMode.setVmPolicy(oldPolicy);\n            }\n        } else {\n            launcherApps.startActivityForProfile(intent.getComponent(), user,\n                    intent.getSourceBounds(), optsBundle);\n        }\n        return true;\n    } catch (SecurityException e) {      \n        ...\n    }\n    return false;\n}\n\n```\n\n1.1.4 Activity.startActivity\n这里最终调用了 `Activity` 中的 `startActivity` 方法，并且设置 Flag 为 **FLAG_ACTIVITY_NEW_TASK**。到此为止，已经跟启动普通的 `Activity` 流程汇合起来了，继续往下分析。\n[frameworks/base/core/java/android/app/Activity.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Activity.java)\n\n\n```JAVA\n@Override\npublic void startActivity(Intent intent, @Nullable Bundle options) {\n    // 第二个参数为 -1 表示不需要回调 onActivityResult 方法\n    if (options != null) {\n        startActivityForResult(intent, -1, options);\n    } else {\n        // Note we want to go through this call for compatibility with\n        // applications that may have overridden the method.\n        startActivityForResult(intent, -1);\n    }\n}\n```\n### 1.1.5 Activity.startActivityForResult\n调用 `Activity` 的 `startActivityForResult` 方法\n\n\n```JAVA\npublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n           @Nullable Bundle options) {\n    // mParent 是当前 Activity 的父类，此时条件成立\n    if (mParent == null) {\n        // 调用 Instrumentation 的 execStartActivity 方法\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this,\n               mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);\n        ...\n    } else {\n        ...\n    }\n}\n```\n\n### 1.1.6 Instrumentation.execStartActivity\n\n[frameworks/base/core/java/android/app/Instrumentation.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Instrumentation.java)\n\n\n```JAVA\npublic ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, Activity target,\n        Intent intent, int requestCode, Bundle options) {\n        ...\n    try {\n        intent.migrateExtraStreamToClipData();\n        intent.prepareToLeaveProcess(who);\n        // 获取 AMS 的代理对象并调用其 startActivity 方法\n        int result = ActivityManagerNative.getDefault()\n            .startActivity(whoThread, who.getBasePackageName(), intent,\n                    intent.resolveTypeIfNeeded(who.getContentResolver()),\n                    token, target != null ? target.mEmbeddedID : null,\n                    requestCode, 0, null, options);\n        checkStartActivityResult(result, intent);\n    } catch (RemoteException e) {\n        throw new RuntimeException(\"Failure from system\", e);\n    }\n    return null;\n}\n```\n\n### 1.1.7 ActivityManagerProxy.startActivity\n\n以上过程是在 `Launcher App `所在的进程中发生的，**由于远程 **`AMS(ActivityManagerService) `跟使用 `Service` 的 `Activity` **不在同一个进程中**，因此他们之间交互需要通过 **Binder IPC 机制**的支持，在这个过程中`Client` 首先获取到 `Server` 端的代理对象，在 `Client` 看来 `ActivityManagerProxy` 对象同样具有 `ActivityManagerService` 本地对象承诺的能力，因此 `Client` 可以调用 `ActivityManagerProxy` 跟 `ActivityManagerService` 对象进行数据交互，**`Binder` 驱动**作为桥梁在他们中间起到中间人的作用。\n同样，`AMS` 是运行在 `system_server` 线程中的，这时 `AMS` 就相当于 AIDL 中的远程 服务端，App 进程要与 AMS 交互，需要通过 **AMS的代理**对象 `ActivityManagerProxy` 来完成，来看 `ActivityManagerNative.getDefault()` 拿到的是什么：\n[frameworks/base/core/java/android/app/ActivityManagerNative.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/ActivityManagerNative.java)\n\n```JAVA\nstatic public IActivityManager getDefault() {\n    return gDefault.get();\n}\n```\n\n`getDefault` 是一个静态变量：\n\n\n```JAVA\nprivate static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n    protected IActivityManager create() {\n        // 向 ServiceManager 查询一个 key 为 \"activity\" 的引用\n        IBinder b = ServiceManager.getService(\"activity\");\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service binder = \" + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service = \" + am);\n        }\n        return am;\n    }\n};\n```\n\n\n`ServiceManager` **是 Binder IPC通信过程的核心**，是上下文的管理者，`Binder` 服务端必须先向 `ServerManager` 注册才能够为客户端提供服务，`Binder` 客户端在与服务端通信之前需要从 `ServerManager` **中查找并获取 `Binder` 服务端的引用**。\n\n这里通过 \"**activity**\" 这个名字向 `ServiceManager` 查询 `AMS` 的引用，获取 `AMS` 的引用后，调用 `asInterface` 方法：\n\n\n```JAVA\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    // 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章\n    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n    // 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回\n    return new ActivityManagerProxy(obj);\n}\n```\n\n因为 `AMS` 与 `Launcher App` 不在同一个进程中，这里返回的 `IBinder` 对象是一个 `Binder` 代理对象，因此这类将其包装成 `ActivityManagerProxy`对象并返回，`ActivityManagerProxy` 是`ActivityManagerNative` 的内部类，查看 `ActivityManagerProxy` 类 ：\n\n```JAVA\nclass ActivityManagerProxy implements IActivityManager\n{\n    public ActivityManagerProxy(IBinder remote)\n    {\n        mRemote = remote;\n    }\n\n    public IBinder asBinder()\n    {\n        return mRemote;\n    }\n\n    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n        ...\n        // 调用号为 START_ACTIVITY_TRANSACTION\n        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n        reply.readException();\n        int result = reply.readInt();\n        reply.recycle();\n        data.recycle();\n        return result;\n    }\n    ...\n    public ComponentName startService(IApplicationThread caller, Intent service,\n            String resolvedType, String callingPackage, int userId) throws RemoteException\n    {\n        ...\n        mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);\n        reply.readException();\n        ComponentName res = ComponentName.readFromParcel(reply);\n        data.recycle();\n        reply.recycle();\n        return res;\n    }\n    ...\n}\n```\n可以看到，`ActivityManagerProxy` 里面将客户端的请求通过 `mRemote.transact`  进行转发，`mRemote` 对象正是 `Binder` 驱动返回来的 **Binder 服务端的 Proxy** 对象，通过 这个`Binder Proxy`，`Binder` 驱动最终将调用处于 `Binder Server` 端 `ActivityManagerNative` 中的 `onTransact` 方法：\n\n\n```JAVA\n@Override\npublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n    // 根据方法调用号 code 决定调用哪个方法\n    switch (code) {\n    case START_ACTIVITY_TRANSACTION:\n    {\n        ...\n        // 调用 startActivity 方法\n        int result = startActivity(app, callingPackage, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);\n        reply.writeNoException();\n        reply.writeInt(result);\n        return true;\n    }\n    ...\n    case START_SERVICE_TRANSACTION: {\n        ...\n        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);\n            reply.writeNoException();\n            ComponentName.writeToParcel(cn, reply);\n            return true;\n        }\n        ...\n    }\n}\n```\n### 1.1.8 ActivityManagerService.startActivity\n`ActivityManagerNative` 是一个抽象类，它的 `startActivity` 为抽象方法，具体的实现在 [frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityManagerService.java) 中：\n\n\n```JAVA\n@Override\npublic final int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {\n    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n            resultWho, requestCode, startFlags, profilerInfo, bOptions,\n            UserHandle.getCallingUserId());\n}\n```\n## 1.2 小结\n你应该可以发现，相对于 `AIDL` 的调用过程，调用方 `Launcher App` 相当于 AIDL 过程中的 `Clinent`端；AMS 相当于远程 Service 的角色，充当 Server 端角色，他们的调用过程总体上都是一样的。\n从 Launcher App 到 AMS 的时序图如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u54pqf70j30sk0gqabi.jpg)\n\n\n# 2. AMS —— zygote\n\n## 2.1 调用过程分析\n### 2.1.1 ActivityManagerService.startActivityAsUser\n接着从 `AMS` 的 `startActivityAsUser` 方法开始分析：\n\n\n```JAVA\n@Override\npublic final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {\n    enforceNotIsolatedCaller(\"startActivity\");\n    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, false, ALLOW_FULL_ONLY, \"startActivity\", null);\n    // TODO: Switch to user app stacks here.\n    // 调用 ActivityStarter 的 startActivityMayWait 方法\n    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,\n            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n            profilerInfo, null, null, bOptions, false, userId, null, null);\n}\n```\n\n### 2.1.2 ActivityStarter.startActivityMayWait\n继续跟进 [frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStarter.java)\n\n\n```JAVA\nfinal int startActivityMayWait(IApplicationThread caller, int callingUid,\n        String callingPackage, Intent intent, String resolvedType,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        IBinder resultTo, String resultWho, int requestCode, int startFlags,\n        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,\n        Bundle bOptions, boolean ignoreTargetSecurity, int userId,\n        IActivityContainer iContainer, TaskRecord inTask) {\n   ...\n   synchronized (mService) {\n        ...\n        // 调用 startActivityLocked 方法\n        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,\n                aInfo, rInfo, voiceSession, voiceInteractor,\n                resultTo, resultWho, requestCode, callingPid,\n                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,\n                options, ignoreTargetSecurity, componentSpecified, outRecord, container,\n                inTask);\n        ...\n        return res;\n    }\n}\n```\n\n### 2.1.3 ActivityStarter.startActivityLocked\n查看 `startActivityLocked` 方法：\n\n\n```JAVA\nfinal int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,\n        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,\n        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,\n        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,\n        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,\n        TaskRecord inTask) {\n    ...\n    // 调用 doPendingActivityLaunchesLocked 方法，传入 false 参数\n    doPendingActivityLaunchesLocked(false);\n    ...\n    return err;\n}\n\n```\n\n### 2.1.4 ActivityStarter.doPendingActivityLaunchesLocked\n查看 `doPendingActivityLaunchesLocked` 方法：\n\n\n```JAVA\nfinal void doPendingActivityLaunchesLocked(boolean doResume) {\n    while (!mPendingActivityLaunches.isEmpty()) {\n        final PendingActivityLaunch pal = mPendingActivityLaunches.remove(0);\n        final boolean resume = doResume && mPendingActivityLaunches.isEmpty();\n        try {\n            // 调用 startActivityUnchecked 方法\n            final int result = startActivityUnchecked(pal.r, pal.sourceRecord, null, null,\n                pal.startFlags, resume, null, null);\n            postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, \n                mSourceRecord, mTargetStack);\n        } catch (Exception e) {\n            Slog.e(TAG, \"Exception during pending activity launch pal=\" + pal, e);\n            pal.sendErrorResult(e.getMessage());\n        }\n    }\n}\n```\n### 2.1.5 ActivityStarter.startActivityUnchecked\n查看 `startActivityUnchecked` 方法：\n\n\n```JAVA\nprivate int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {\n    ...  \n    // 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法\n    mSupervisor.resumeFocusedStackTopActivityLocked();  \n    ... \n    return START_SUCCESS;\n}\n\n```\n\n### 2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked\n\n[frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java)\n\n\n```JAVA\nboolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target,\n            ActivityOptions targetOptions) {\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法\n        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    }\n    return false;\n}\n```\n\n\n### 2.1.7 ActivityStack.resumeTopActivityUncheckedLocked\n查看 `ActivityStack` 的 `resumeTopActivityUncheckedLocked` 方法：\n```java\nboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {\n    ...\n    try {\n        ...\n        // 调用 resumeTopActivityInnerLocked 方法\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    return result;\n}\n```\n\n### 2.1.8 ActivityStack.resumeTopActivityInnerLocked\n查看 `resumeTopActivityInnerLocked` 方法：\n```java\nprivate boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {\n    ...\n    final ActivityRecord next = topRunningActivityLocked();\n    ...\n    if (next.app != null && next.app.thread != null) {\n        ...\n    } else {\n        ...\n        if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Restarting \" + next);\n        // 调用 ActivityStackSupervisor 的 startSpecificActivityLocked 方法\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n    return true;\n}\n```\n### 2.1.9 ActivityStackSupervisor.startSpecificActivityLocked\n回到 `ActivityStackSupervisor` 的 `startSpecificActivityLocked` 方法：\n```java\nvoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {\n    // 当前 Activity 附属的 Application\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n            r.info.applicationInfo.uid, true);\n    r.task.stack.setLaunchTime(r);\n    // 如果 Application 已经运行\n    if (app != null && app.thread != null) {\n        try {\n            if ((r.info.flags&ActivityInfo.FLAG_MULTIPROCESS) == 0\n                    || !\"android\".equals(r.info.packageName)) {\n                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,\n                        mService.mProcessStats);\n            }\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Exception when starting activity \"\n                    + r.intent.getComponent().flattenToShortString(), e);\n        }\n    }\n    // 如果 Application 没有运行,调用AMS,启动新进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n            \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n首先，在方法中获取了当前 `Activity` 附属的 `Application`，如果已经在运行了，说明这个 App 是已经被启动过了的，这时候调用 `realStartActivityLocked` 方法就可以进入下一步的流程了，同一个 App 中不同 `Activity` 的相互启动就是走的这个流程。当 `Application` 没有运行的时候，就需要调用 `AMS` 的 `startProcessLocked` 方法启动一个进程去承载它然后完成后续的工作，顺便铺垫一下，当新进程被启动完成后还会调用回到这个方法，查看 `AMS` 的 `startProcessLocked` 方法：\n### 2.1.10 ActivityManagerService.startProcessLocked\n\n```java\nfinal ProcessRecord startProcessLocked(String processName,\n        ApplicationInfo info, boolean knownToBeDead, int intentFlags,\n        String hostingType, ComponentName hostingName, boolean allowWhileBooting,\n        boolean isolated, boolean keepIfLarge) {\n    return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,\n            hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,\n            null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,\n            null /* crashHandler */);\n}\n```\n### 2.1.11 ActivityManagerService.startProcessLocked\n调用 `startProcessLocked` 方法：\n```java\nfinal ProcessRecord startProcessLocked(String processName, ApplicationInfo info,\n        boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,\n        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,\n        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler){\n    ...\n    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);\n    checkTime(startTime, \"startProcess: done starting proc!\");\n    return (app.pid != 0) ? app : null;\n}\n```\n### 2.1.12 ActivityManagerService.startProcessLocked\n调用 `startProcessLocked` 的重载方法：\n```java\nprivate final void startProcessLocked(ProcessRecord app, String hostingType,\n        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs){\n    ...\n    try {\n        ...\n        // 调用 Process 的 start 方法\n        Process.ProcessStartResult startResult = Process.start(entryPoint,\n                app.processName, uid, uid, gids, debugFlags, mountExternal,\n                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                app.info.dataDir, entryPointArgs);\n        ...\n    } catch (RuntimeException e) {\n        ...\n    }\n}\n```\n### 2.1.13 Process.start\n[frameworks/base/services/core/java/android/os/Process.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/os/Process.java)\n```java\npublic static final ProcessStartResult start(final String processClass,\n                                final String niceName,\n                                int uid, int gid, int[] gids,\n                                int debugFlags, int mountExternal,\n                                int targetSdkVersion,\n                                String seInfo,\n                                String abi,\n                                String instructionSet,\n                                String appDataDir,\n                                String[] zygoteArgs) {\n    try {\n        // 调用 startViaZygote 方法\n        return startViaZygote(processClass, niceName, uid, gid, gids,\n                debugFlags, mountExternal, targetSdkVersion, seInfo,\n                abi, instructionSet, appDataDir, zygoteArgs);\n    } catch (ZygoteStartFailedEx ex) {\n        Log.e(LOG_TAG,\n                \"Starting VM process through Zygote failed\");\n        throw new RuntimeException(\n                \"Starting VM process through Zygote failed\", ex);\n    }\n}\n```\n### 2.1.14 Process.startViaZygote\n查看 `startViaZygote` 方法：\n```java\nprivate static ProcessStartResult startViaZygote(final String processClass,\n                                final String niceName,\n                                final int uid, final int gid,\n                                final int[] gids,\n                                int debugFlags, int mountExternal,\n                                int targetSdkVersion,\n                                String seInfo,\n                                String abi,\n                                String instructionSet,\n                                String appDataDir,\n                                String[] extraArgs)\n                                throws ZygoteStartFailedEx {\n    synchronized(Process.class) {\n        ...\n        // 调用 zygoteSendArgsAndGetResult 方法，传入 openZygoteSocketIfNeeded 的返回值\n        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n    }\n}\n```\n### 2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded\n查看 `zygoteSendArgsAndGetResult` 方法：\n```java\nprivate static ProcessStartResult zygoteSendArgsAndGetResult(\n            ZygoteState zygoteState, ArrayList<String> args)\n            throws ZygoteStartFailedEx {\n    try {\n        ...\n        final BufferedWriter writer = zygoteState.writer;\n        final DataInputStream inputStream = zygoteState.inputStream;\n\n        writer.write(Integer.toString(args.size()));\n        writer.newLine();\n\n        for (int i = 0; i < sz; i++) {\n            String arg = args.get(i);\n            writer.write(arg);\n            writer.newLine();\n        }\n\n        writer.flush();\n\n        // Should there be a timeout on this?\n        ProcessStartResult result = new ProcessStartResult();\n\n        // 等待 socket 服务端（即zygote）返回新创建的进程pid;\n        result.pid = inputStream.readInt();\n        result.usingWrapper = inputStream.readBoolean();\n\n        if (result.pid < 0) {\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n        return result;\n    } catch (IOException ex) {\n        zygoteState.close();\n        throw new ZygoteStartFailedEx(ex);\n    }\n}\n```\n在 `zygoteSendArgsAndGetResult` 中等待 `Socket` 服务端，也就是 `zygote` 进程返回创建新进程的结果，这里 `zygoteState` 参数是由 `openZygoteSocketIfNeeded` 方法返回的，`openZygoteSocketIfNeeded` 方法则负责根据 `abi` 向 `Zygote` 进程发起连接请求：\n```java\nprivate static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n        try {\n            // 向主zygote发起connect()操作\n            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n        } catch (IOException ioe) {\n            throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n        }\n    }\n\n    if (primaryZygoteState.matches(abi)) {\n        return primaryZygoteState;\n    }\n\n    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n        try {\n            // 当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n        } catch (IOException ioe) {\n            throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n        }\n    }\n\n    if (secondaryZygoteState.matches(abi)) {\n        return secondaryZygoteState;\n    }\n\n    throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n}\n```\n## 2.2 小结\n如果是从桌面新启动一个 App 中的 `Activity`，此时是没有进程去承载这个 App 的，因此需要通过 `AMS` 向 `zygote` 继承发起请求去完成这个任务，AMS 运行在 `system_server` 进程中，它通过 `Socket` 向 `zygote` 发起 `fock` 进程的请求，从 `AMS` 开始的调用时序图如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u5m53eloj30t50p7tcl.jpg)\n\n\n\n# 3. zygote —— ActivityThread\n## 3.1 调用过程分析\n### 3.1.1 ZygoteInit.main\n\n`zygote` 进程的其中一项任务就是：\n\n调用 `registerZygoteSocket() `函数建立 `Socket` 通道，使 `zygote` 进程成为 `Socket` 服务端，并通过` runSelectLoop()` 函数等待 `ActivityManagerService` 发送请求创建新的应用程序进程。\n\n`zygote` 终于要再次上场了！接下来从 **ZygoteInit.java** 的 `main` 方法开始回顾一下 `zygote` 进程的工作：\n\n[frameworks/base/core/java/com/android/internal/os/ZygoteInit.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java)\n```java\npublic static void main(String argv[]) {\n    try {\n        ...\n        runSelectLoop(abiList);\n        ....\n    } catch (MethodAndArgsCaller caller) {\n        caller.run();\n    } catch (RuntimeException ex) {\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n### 3.1.2 ZygoteInit.runSelectLoop\n查看 `runSelectLoop` 方法：\n```java\nprivate static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n    ...\n    // 循环读取状态\n    while (true) {\n        ...\n        for (int i = pollFds.length - 1; i >= 0; --i) {\n            // 读取的状态不是客户端连接或者数据请求时，进入下一次循环\n            if ((pollFds[i].revents & POLLIN) == 0) {\n                continue;\n            }\n            if (i == 0) {// i = 0 表示跟客户端 Socket 连接上了\n                ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                peers.add(newPeer);\n                fds.add(newPeer.getFileDesciptor());\n            } else {// i > 0 表示接收到客户端 Socket 发送过来的请求\n                // runOnce 方法创建一个新的应用程序进程\n                boolean done = peers.get(i).runOnce();\n                if (done) {\n                    peers.remove(i);\n                    fds.remove(i);\n                }\n            }\n        }\n    }\n}\n```\n### 3.1.3 ZygoteConnection.runOnce\n查看 [frameworks/base/core/java/com/android/internal/os/](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java)\n**ZygoteConnection.java** 的 `runOnce` 方法：\n```java\nboolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n    String args[];\n    Arguments parsedArgs = null;\n    FileDescriptor[] descriptors;\n\n    try {\n        // 读取 socket 客户端发送过来的参数列表\n        args = readArgumentList();\n        descriptors = mSocket.getAncillaryFileDescriptors();\n    } catch (IOException ex) {\n        // EOF reached.\n        closeSocket();\n        return true;\n    }\n    ...\n    try {\n        // 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式\n        parsedArgs = new Arguments(args);\n        ...\n        // 同样调用 Zygote.java 的 forkAndSpecialize 方法 fock 出子进程\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                parsedArgs.appDataDir);\n    } catch (Exception e) {\n        ...\n    }\n\n    try {\n        if (pid == 0) {\n            // 子进程执行\n            IoUtils.closeQuietly(serverPipeFd);\n            serverPipeFd = null;\n            // 进入子进程流程\n            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n            return true;\n        } else {\n            // 父进程执行\n            IoUtils.closeQuietly(childPipeFd);\n            childPipeFd = null;\n            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n        }\n    } finally {\n        IoUtils.closeQuietly(childPipeFd);\n        IoUtils.closeQuietly(serverPipeFd);\n    }\n}\n```\n### 3.1.4 ZygoteConnection.handleChildProc\n首先解析 `Socket` 客户端传过来的参数，`Zygote.java` 的 `forkAndSpecialize` 返回的 `pid == 0` 的时候表示此时在 `fock` 出来的子进程中执行，继续调用 `handleChildProc` 方法，并将参数继续层层传递：\n```JAVA\nprivate void handleChildProc(Arguments parsedArgs, FileDescriptor[] \n    descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller {\n    /*由于 fock 出来的 system_server 进程会复制 zygote 进程的地址空间，因此它也得到了 zygote\n    进程中的 Socket，这个 Socket 对它来说并无用处，这里将其关闭 \n    */\n    closeSocket();\n    ZygoteInit.closeServerSocket();\n    ...\n    if (parsedArgs.niceName != null) {\n        // 设置进程名\n        Process.setArgV0(parsedArgs.niceName);\n    }\n\n    if (parsedArgs.invokeWith != null) {\n        ...\n    } else {\n        // 调用 RuntimeInit 的 zygoteInit 方法\n        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                parsedArgs.remainingArgs, null);\n    }\n}\n```\n### 3.1.5 RuntimeInit.zygoteInit\n查看 [frameworks/base/core/java/com/android/internal/os/RuntimeInit.java ](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java)的 `zygoteInit` 方法：\n```java\npublic static final void zygoteInit(int targetSdkVersion, String[] argv, \n            ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller {\n    if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n    // 重定向 log 输出\n    redirectLogStreams();\n    // 初始化一些通用的设置\n    commonInit(); \n    /**\n     *通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 的 \n     *onZygoteInit 方法启动 Binder 线程池， 使 system_server 进程可以使用 Binder  *与其他进程通信\n     **/\n    nativeZygoteInit(); \n    applicationInit(targetSdkVersion, argv, classLoader);\n}\n```\n### 3.1.6 RuntimeInit.applicationInit\n继续调用 `applicationInit` 方法：\n```java\nprivate static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    // 提取出参数里面的要启动的类的名字\n    invokeStaticMain(args.startClass, args.startArgs, classLoader);\n}\n```\n### 3.1.7 RuntimeInit.invokeStaticMain\n主要调用了 `invokeStaticMain` 方法：\n```java\nprivate static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n         throws ZygoteInit.MethodAndArgsCaller {\n    Class<?> cl;\n    try {\n        /** className 为通过 Socket 客户端（AMS）传递过来的一系列参数中的其中一个，这里获取到的值为传\"com.android.app.ActivityThread\"，然后通过反射得到 ActivityThread 类 **/\n        cl = Class.forName(className, true, classLoader);\n    } catch (ClassNotFoundException ex) {\n        throw new RuntimeException(\n            \"Missing class when invoking static main \" + className, ex);\n    }\n    Method m;\n    try {\n        // 找到 ActivityThread 类的 main 方法\n        m = cl.getMethod(\"main\", new Class[] { String[].class });\n    } catch (NoSuchMethodException ex) {\n        throw new RuntimeException(\n            \"Missing static main on \" + className, ex);\n    } catch (SecurityException ex) {\n        throw new RuntimeException(\n            \"Problem getting static main on \" + className, ex);\n    }\n    int modifiers = m.getModifiers();\n    if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n        throw new RuntimeException(\n            \"Main method is not public and static on \" + className);\n    }\n    /** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出\n    捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/\n    throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n}\n```\n### 3.1.8 MethodAndArgsCaller.run\n回到 `ZygoteInit` 的 `main` 方法：\n```java\npublic static void main(String argv[]) {\n    ...\n    closeServerSocket();\n    } catch (MethodAndArgsCaller caller) {\n        // 接收到 caller 对象后调用它的 run 方法\n        caller.run();\n    } catch (RuntimeException ex) {\n        Log.e(TAG, \"Zygote died with exception\", ex);\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n跟 `system_server` 进程的启动过程一样，这里同样通过抛出异常的方式来清空调用 `ActivityThread.main `之前的方法栈帧。\n`ZygoteInit` 的 `MethodAndArgsCaller` 类是一个 `Exception` 类，同时也实现了 `Runnable` 接口：\n```java\npublic static class MethodAndArgsCaller extends Exception\n        implements Runnable {\n        \n    private final Method mMethod;\n    private final String[] mArgs;\n        \n    public MethodAndArgsCaller(Method method, String[] args) {\n        mMethod = method;\n        mArgs = args;\n    }\n    public void run() {\n        try {\n            // 调用传递过来的 mMethod\n            mMethod.invoke(null, new Object[] { mArgs });\n        } catch (IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        } catch (InvocationTargetException ex) {\n            ...\n        }\n    }\n}\n```\n### 3.1.9 ActivityThread .main\n最后通过反射调用到 `ActivityThread` 的 `main` 方法：\n```java\npublic static void main(String[] args) {\n    ...\n    Environment.initForCurrentUser();\n    ...\n    Process.setArgV0(\"<pre-initialized>\");\n    // 创建主线程 Looper\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    // attach 到系统进程\n    thread.attach(false);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    // 主线程进入轮询状态\n    Looper.loop();\n\n    // 抛出异常说明轮询出现问题\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n## 3.2 小结\n`zygote` 进程作为 `Socket` 服务端在接收到作为客户端的 `AMS` 发送过来的请求和参数之后，`fock` 出新的进程并根据各种参数进程了初始化的工作，这个过程和 `zygote` 启动 `system_server` 进程的过程如出一辙，时序图如下所示：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u80ukv7ej30q30ivmzb.jpg)\n\n\n# 4. ActivityThread —— Activity\n##4.1 调用过程分析\n### 4.1.1 ActivityThread.attach\n上一小节的最后，`ActivityThread` 的 `main` 通过反射被运行起来了，接着会调用 `ActivityThread` 的 `attach` 方法：\n\n\n```JAVA\nprivate void attach(boolean system) {\n    ...\n    mSystemThread = system;\n    if (!system) {\n        ...\n        // 获取 ActivityManagerProxy 对象\n        final IActivityManager mgr = ActivityManagerNative.getDefault();\n        try {\n            // 通过 Binder 调用 AMS 的 attachApplication 方法\n            mgr.attachApplication(mAppThread);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    } else {\n        ...\n    }\n    ...\n}\n```\n\n这里，我们再一次通过 `Binder IPC` 机制跟 `AMS` 通信，通信模型跟前面` Launcher App `调用 `AMS` 的 `startActivity` 方法一样，getDefault 过程不重复分析，这次是调用了 `AMS` 的 `attachApplication` 方法，注意这里将 `ApplicationThead` 类型的 `mAppThread` 对象作为参数传递了过去，`ApplicationThead` 是 `ActivityThread` 的一个内部类，后面我们会讲到，先查看 `AMP` 的 `attachApplication` 方法：\n### 4.1.2 ActivityManagerProxy.attachApplication\n```java\npublic void attachApplication(IApplicationThread app) throws RemoteException {\n    ...\n    // 调用 asBinder 方法使其能够跨进程传输\n    data.writeStrongBinder(app.asBinder());\n    // 通过 transact 方法将数据交给 Binder 驱动\n    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); \n    reply.readException();\n    data.recycle();\n    reply.recycle();\n}\n```\n### 4.1.3 ActivityManagerNative.onTransact\n```java\npublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n    switch (code) {\n        ...\n        case ATTACH_APPLICATION_TRANSACTION: {\n            data.enforceInterface(IActivityManager.descriptor);\n            // 获取 ApplicationThread 的代理对象，这里返回的是 ApplicationThreadNative(ATN)\n            // 的内部类：ApplicationThreadProxy(ATP) 对象\n            IApplicationThread app = ApplicationThreadNative.asInterface(data.readStrongBinder());\n            if (app != null) {\n                // 委托给 AMS 执行\n                attachApplication(app);\n            }\n            reply.writeNoException();\n            return true;\n        }\n        ...\n    }\n}\n```\n`asInterface` 将 `ActivityThread` 对象**转换**成了 `ApplicationThreadNative` 的 `Binder` 代理对象 `ApplicationThreadProxy`，并作为参数传给 `attachApplication` 方法，其中 `ApplicationThreadProxy` 是 `ApplicationThreadNative` 的**内部类**。\n### 4.1.4 ActivityManagerService.attachApplication\n```java\npublic final void attachApplication(IApplicationThread thread) {\n    synchronized (this) {\n        int callingPid = Binder.getCallingPid();\n        final long origId = Binder.clearCallingIdentity();\n        attachApplicationLocked(thread, callingPid);\n        Binder.restoreCallingIdentity(origId);\n    }\n}\n```\n### 4.1.5 ActivityManagerService.attachApplicationLocked\n```java\nprivate final boolean attachApplicationLocked(IApplicationThread thread, int pid) {\n    ProcessRecord app;\n    ...\n    try {\n        // 绑定死亡通知\n        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);\n        thread.asBinder().linkToDeath(adr, 0);\n        app.deathRecipient = adr;\n    } catch (RemoteException e) {\n        app.resetPackageList(mProcessStats);\n        // 如果 system_server 进程死亡则重新启动进程\n        startProcessLocked(app, \"link fail\", processName); \n        return false;\n    }\n    ...\n    try {\n        ...\n        // 获取应用appInfo\n        ApplicationInfo appInfo = app.instrumentationInfo != null\n                ? app.instrumentationInfo : app.info;\n        ...\n        // 绑定应用\n        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n                isRestrictedBackupMode || !normalMode, app.persistent,\n                new Configuration(mConfiguration), app.compat,\n                getCommonServicesLocked(app.isolated),\n                mCoreSettingsObserver.getCoreSettingsLocked());\n        ...\n    } catch (Exception e) {\n        app.resetPackageList(mProcessStats);\n        app.unlinkDeathRecipient();\n        // bindApplication 失败也要重启进程\n        startProcessLocked(app, \"bind fail\", processName);\n        return false;\n    }\n    // 如果是 Activity: 检查最顶层可见的Activity是否等待在该进程中运行\n    if (normalMode) {\n        try {\n            if (mStackSupervisor.attachApplicationLocked(app)) {\n                didSomething = true;\n            }\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    // 如果是 Service: 寻找所有需要在该进程中运行的服务\n    if (!badApp) {\n        try {\n            didSomething |= mServices.attachApplicationLocked(app, processName);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n\n    // 如果是 BroadcastReceiver: 检查是否在这个进程中有下一个广播接收者\n    if (!badApp && isPendingBroadcastProcessLocked(pid)) {\n        try {\n            didSomething |= sendPendingBroadcastsLocked(app);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    // 检查是否在这个进程中有下一个 backup 代理\n    if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {\n        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);\n        try {\n            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,\n                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),\n                    mBackupTarget.backupMode);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    if (badApp) { \n        // 杀掉 badApp\n        app.kill(\"error during init\", true);\n        handleAppDiedLocked(app, false, true);\n        return false;\n    }\n    if (!didSomething) {\n        // 更新 adj(组件的权值)\n        updateOomAdjLocked(); \n    }\n    return true;\n}\n```\n\n首先，通过 `ApplicationThreadProxy` 使用 `Binder` 向 `ApplicationThreadProxy` 发起 `bindApplication` 请求，然后通过 `normalMode` 字段判断是否为 `Activity`，如果是则执行 `ActivityStackSupervisor` 的 `attachApplicationLocked` 方法。\n#### 4.1.5.1 ActivityThread.java::ApplicationThread.bindApplication\n`thread` 对象类型是 `ApplicationThreadProxy`，通过 `Binder` 驱动调到了 `ApplicationThreadNative` 的方法，`ApplicationThreadNative` 是一个抽象类，它的实现都委托给了 `ApplicationThread`(这跟 AMS 跟 AMN 的关系一样)，ApplicationThread 作为 ActivityThread 的内部类存在，它的 binderApplication 方法如下：\n```java\nActivityThread.java::ApplicationThread：\npublic final void bindApplication(String processName, ApplicationInfo appInfo,\n    List<ProviderInfo> providers, ComponentName instrumentationName, ProfilerInfo profilerInfo,\n    Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,\n    IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean\n    enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration\n    config, CompatibilityInfo compatInfo, Map<String, IBinder> services, Bundle coreSettings) {\n\n    if (services != null) {\n        // 将services缓存起来, 减少binder检索服务的次数\n        ServiceManager.initServiceCache(services);\n    }\n    ...\n    // 发送消息 H.BIND_APPLICATION 给 Handler 对象\n    sendMessage(H.BIND_APPLICATION, data);\n}\n```\n**H** 是 **ActivityThread** 中的一个 **Handler** 对象，用于处理发送过来的各种消息：\n```java\nprivate class H extends Handler {\n    public static final int BIND_APPLICATION        = 110;\n \n    public void handleMessage(Message msg) {\n        ...\n        case BIND_APPLICATION:\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n            AppBindData data = (AppBindData)msg.obj;\n            handleBindApplication(data);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            break;\n        ...\n    }\n}\n```\n调用了 `handleBindApplication` 方法：\n```\nprivate void handleBindApplication(AppBindData data) {\n    // 获取 LoadedApk 对象\n    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);\n    ...\n    // 创建 ContextImpl 上下文\n    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);\n    ...\n    // 创建 Instrumentation 对象\n    if (data.instrumentationName != null) {\n        ...\n    } else {\n        mInstrumentation = new Instrumentation();\n    }\n\n    try {\n        // 调用 LoadedApk 的 makeApplication 方法创建 Application\n        Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n        mInitialApplication = app;\n        ...\n        mInstrumentation.onCreate(data.instrumentationArgs);\n        // 调用 Application.onCreate 方法\n        mInstrumentation.callApplicationOnCreate(app);\n    } finally {\n        StrictMode.setThreadPolicy(savedPolicy);\n    }\n}\n```\n#### 4.1.5.2 ActivityStackSupervisor.attachApplicationLocked\n在 **4.1.4** 小节中通过 **Binder** 向 **ActivityThread** 发起 `bindApplication` 请求后，会根据启动组件的类型去做相应的处理，如果是 `Acitivity`，则会调用 **ActivityStackSupervisor** 的 `attachApplicationLocked` 方法：\n```java\nboolean attachApplicationLocked(ProcessRecord app) throws RemoteException {\n    final String processName = app.processName;\n    boolean didSomething = false;\n    for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {\n        ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;\n        for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {\n            final ActivityStack stack = stacks.get(stackNdx);\n            if (!isFrontStack(stack)) {\n                continue;\n            }\n            // 获取前台stack中栈顶第一个非 finishing 状态的 Activity\n            ActivityRecord hr = stack.topRunningActivityLocked(null);\n            if (hr != null) {\n                if (hr.app == null && app.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {\n                    try {\n                        // 真正的启动 Activity\n                        if (realStartActivityLocked(hr, app, true, true)) {\n                            didSomething = true;\n                        }\n                    } catch (RemoteException e) {\n                        throw e;\n                    }\n                }\n            }\n        }\n    }\n    ...\n    return didSomething;\n}\n##### 4.1.5.2.1 ActivityStackSupervisor.realStartActivityLocked\n\n前面 **2.1.8ActivityStackSupervisor.startSpecificActivityLocked**  小节中分析过，如果当前 `Activity` 依附的 `Application` 已经被启动，则调用 `realStartActivityLocked` 方法，否则创建新的进程，再创建新的进程之后，两个流程的在这里合并起来了：\n```java\nfinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException {\n    ...\n    final ActivityStack stack = task.stack;\n    try {\n        ...\n        app.forceProcessStateUpTo(mService.mTopProcessState);\n        // 通过 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法\n        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n        ...\n    } catch (RemoteException e) {\n        if (r.launchFailed) {\n            // 第二次启动失败，则结束该 Activity\n            mService.appDiedLocked(app);\n            stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                    \"2nd-crash\", false);\n            return false;\n        }\n        // 第一个启动失败，则重启进程\n        app.activities.remove(r);\n        throw e;\n    }\n    ...\n    return true;\n}\n``` \n这里有一次使用 `Binder` 调用 `ApplicationThread` 的 `scheduleLaunchActivity` 方法。\n\n##### 4.1.5.2.2 ApplicationThread.scheduleLaunchActivity\n\n```java\npublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo \n        info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo \n        compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle \n        state, PersistableBundle persistentState, List<ResultInfo> pendingResults, \n        List<ReferrerIntent> pendingNewIntents, boolean notResumed, boolean isForward, \n        ProfilerInfo profilerInfo) {\n    ...\n    updateProcessState(procState, false);\n    ActivityClientRecord r = new ActivityClientRecord();\n    ...\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n }\n```\n\n上面提到过，**H** 是 **ActivityThread** 中一个 **Handler** 类，它接收到 `LAUNCH_ACTIVITY` 消息后会调用 `handleLaunchActivity` 方法。\n##### 4.1.5.2.3 ActivityThread.handleLaunchActivity\n\n```java\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    // 初始化 WMS\n    WindowManagerGlobal.initialize();\n    // 执行 performLaunchActivity 方法\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        Bundle oldState = r.state;\n        // 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                !r.activity.mFinished && !r.startsNotResumed);\n\n        if (!r.activity.mFinished && r.startsNotResumed) {\n            r.activity.mCalled = false;\n            mInstrumentation.callActivityOnPause(r.activity);\n            r.paused = true;\n        }\n    } else {\n        // 停止该 Activity\n        ActivityManagerNative.getDefault()\n            .finishActivity(r.token, Activity.RESULT_CANCELED, null, false);\n    }\n}\n```\n\n##### 4.1.4.2.4 ApplicationThread.performLaunchActivity\n\n```java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n        // Instrumentation 中使用反射创建 Activity\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n        ...\n    } catch (Exception e) {\n        ...\n    }\n\n    try {\n        // 创建 Application 对象并调用 Application 的 onCreate 方法\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n\n        if (activity != null) {\n            ...\n            // attach 到 Window 上\n            activity.attach(appContext, this, getInstrumentation(), r.token,\n                    r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                    r.embeddedID, r.lastNonConfigurationInstances, config,\n                    r.referrer, r.voiceInteractor);\n\n            if (customIntent != null) {\n                activity.mIntent = customIntent;\n            }\n            r.lastNonConfigurationInstances = null;\n            activity.mStartedActivity = false;\n            int theme = r.activityInfo.getThemeResource();\n            if (theme != 0) {\n                // 设置主题\n                activity.setTheme(theme);\n            }\n\n            activity.mCalled = false;\n            if (r.isPersistable()) {\n                // 重新创建的 Activity\n                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            } else {\n                // 第一次创建的 Activity\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            ...\n        }\n        ...\n    }  catch (Exception e) {\n        ...\n    }\n    return activity;\n}\n```\n\n##### 4.1.5.2.5 Instrumentation.callActivityOnCreate\n\n\n```java\npublic void callActivityOnCreate(Activity activity, Bundle icicle,\n            PersistableBundle persistentState) {\n    prePerformCreate(activity);\n    // 调用 Activity 的 performCreate 方法\n    activity.performCreate(icicle, persistentState);\n    postPerformCreate(activity);\n}\n```\n\n##### 4.1.5.2.6 Activity.performCreate\n```java\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n        restoreHasCurrentPermissionRequest(icicle);\n    onCreate(icicle, persistentState);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n终于，onCreate 方法被调用了！！！\n\n## 4.2 小结\n从 `ActivityThread` 到最终 `Activity` 被创建及生命周期被调用，核心过程涉及到了三次** Binder IPC** 过程，分别是：\n    \n    1. ActivityThread 调用 AMS 的 attachApplication 方法\n    \n    2. AMS 调用 ApplicationThread 的 bindApplication 方法\n    \n    3. ActivityStackSupervisor 调用 Application 的 attachApplicationLocked 方法\n\n\n整个过程的时序图如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u8r1k48wj30t30qo43w.jpg)\n\n5. 总结\n纵观整个过程，从 Launcher 到 AMS、从 AMS 再到 Zygote、再从 Zygote 到 ActivityThread，最后在 ActivitThread 中层层调用到 Activity 的生命周期方法，中间涉及到了无数的细节，但总体上脉络还是非常清晰的，各个 Android 版本的 Framework 层代码可以某些过程的实现不太一样，但是整个调用流程大体上也是相同的，借用 [Gityuan](http://gityuan.com/android/) 大神的一张图作为结尾：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u8shvqsuj30qo0k0gt0.jpg)\n\n","source":"_posts/activitystartstep-1551942246673.md","raw":"---\ntitle: Android App/Activity 启动流程分析\ntags: [Activity 启动流程分析]\ncategories: [Android]\ndate: 2019-03-07 15:04:06\n---\n\n#  Android App/Activity 启动流程分析\n首先我们带着问题来看:\n\n1. 点击了图标之后系统道理做了哪些工作呢？\n2. 应用进程是怎么被启动的呢？\n3. Activity 的生命周期是什么时候被谁调用的呢？\n\n本文将继续基于 **Android Nougat** 的 Frameworks 层源码的解答这些问题。\n\n阅读建议：\n如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。\n## 1.1 调用过程分析\n### 1.1.1 Launcher.onClick\n在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 `onClick` 方法，\n[packages/apps/Launcher3/src/com/android/launcher3/Launcher.java：](https://android.googlesource.com/platform/packages/apps/Launcher3/+/nougat-release/src/com/android/launcher3/Launcher.java?autodive=0%2F)\n\n\n```JAVA\npublic void onClick(View v) {\n    ...\n    Object tag = v.getTag();\n    if (tag instanceof ShortcutInfo) {\n        // 从快捷方式图标启动\n        onClickAppShortcut(v);\n    } else if (tag instanceof FolderInfo) {\n        // 文件夹\n        if (v instanceof FolderIcon) {\n           onClickFolderIcon(v);\n        }\n    } else if (v == mAllAppsButton) {\n        // “所有应用”按钮\n        onClickAllAppsButton(v);\n    } else if (tag instanceof AppInfo) {\n        // 从“所有应用”中启动的应用\n        startAppShortcutOrInfoActivity(v);\n    } else if (tag instanceof LauncherAppWidgetInfo) {\n        // 组件\n        if (v instanceof PendingAppWidgetHostView) {\n            onClickPendingWidget((PendingAppWidgetHostView) v);\n        }\n    }\n}\n\n```\n\n### 1.1.2 Launcher.onClickAppShortcut\n如果是快捷方式图标，则调用 `onClickAppShortcut` 方法进而调用 `startAppShortcutOrInfoActivity` 方法：\n\n\n```JAVA\n@Thunk void startAppShortcutOrInfoActivity(View v) {\n    Object tag = v.getTag();\n    final ShortcutInfo shortcut;\n    final Intent intent;\n    if (tag instanceof ShortcutInfo) {\n        shortcut = (ShortcutInfo) tag;\n        // 去除对应的 Intent 对象\n        intent = shortcut.intent;\n        int[] pos = new int[2];\n        v.getLocationOnScreen(pos);\n        intent.setSourceBounds(new Rect(pos[0], pos[1],\n                pos[0] + v.getWidth(), pos[1] + v.getHeight()));\n\n    } else if (tag instanceof AppInfo) {\n        shortcut = null;\n        intent = ((AppInfo) tag).intent;\n    } else {\n        throw new IllegalArgumentException(\"Input must be a Shortcut or AppInfo\");\n    }\n\n    // 调用 startActivitySafely 方法\n    boolean success = startActivitySafely(v, intent, tag);\n    mStats.recordLaunch(v, intent, shortcut);\n\n    if (success && v instanceof BubbleTextView) {\n        mWaitingForResume = (BubbleTextView) v;\n        mWaitingForResume.setStayPressed(true);\n    }\n}\n\n```\n\n### 1.1.3 Launcher.startActivity\n获取相应 App 的 **Intent** 信息之后，调用 `startActivity` 方法：\n并设置Flags为**Intent.FLAG_ACTIVITY_NEW_TASK**,启动新的任务栈\n\n```JAVA\nprivate boolean startActivity(View v, Intent intent, Object tag) {\n    // 启动新的任务栈\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    try {\n        ...\n        if (user == null || user.equals(UserHandleCompat.myUserHandle())) {\n            StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();\n            try {            \n                StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll()\n                        .penaltyLog().build());\n                // 调用 Activity 的 startActivity 方法\n                startActivity(intent, optsBundle);\n            } finally {\n                StrictMode.setVmPolicy(oldPolicy);\n            }\n        } else {\n            launcherApps.startActivityForProfile(intent.getComponent(), user,\n                    intent.getSourceBounds(), optsBundle);\n        }\n        return true;\n    } catch (SecurityException e) {      \n        ...\n    }\n    return false;\n}\n\n```\n\n1.1.4 Activity.startActivity\n这里最终调用了 `Activity` 中的 `startActivity` 方法，并且设置 Flag 为 **FLAG_ACTIVITY_NEW_TASK**。到此为止，已经跟启动普通的 `Activity` 流程汇合起来了，继续往下分析。\n[frameworks/base/core/java/android/app/Activity.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Activity.java)\n\n\n```JAVA\n@Override\npublic void startActivity(Intent intent, @Nullable Bundle options) {\n    // 第二个参数为 -1 表示不需要回调 onActivityResult 方法\n    if (options != null) {\n        startActivityForResult(intent, -1, options);\n    } else {\n        // Note we want to go through this call for compatibility with\n        // applications that may have overridden the method.\n        startActivityForResult(intent, -1);\n    }\n}\n```\n### 1.1.5 Activity.startActivityForResult\n调用 `Activity` 的 `startActivityForResult` 方法\n\n\n```JAVA\npublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n           @Nullable Bundle options) {\n    // mParent 是当前 Activity 的父类，此时条件成立\n    if (mParent == null) {\n        // 调用 Instrumentation 的 execStartActivity 方法\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this,\n               mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);\n        ...\n    } else {\n        ...\n    }\n}\n```\n\n### 1.1.6 Instrumentation.execStartActivity\n\n[frameworks/base/core/java/android/app/Instrumentation.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Instrumentation.java)\n\n\n```JAVA\npublic ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, Activity target,\n        Intent intent, int requestCode, Bundle options) {\n        ...\n    try {\n        intent.migrateExtraStreamToClipData();\n        intent.prepareToLeaveProcess(who);\n        // 获取 AMS 的代理对象并调用其 startActivity 方法\n        int result = ActivityManagerNative.getDefault()\n            .startActivity(whoThread, who.getBasePackageName(), intent,\n                    intent.resolveTypeIfNeeded(who.getContentResolver()),\n                    token, target != null ? target.mEmbeddedID : null,\n                    requestCode, 0, null, options);\n        checkStartActivityResult(result, intent);\n    } catch (RemoteException e) {\n        throw new RuntimeException(\"Failure from system\", e);\n    }\n    return null;\n}\n```\n\n### 1.1.7 ActivityManagerProxy.startActivity\n\n以上过程是在 `Launcher App `所在的进程中发生的，**由于远程 **`AMS(ActivityManagerService) `跟使用 `Service` 的 `Activity` **不在同一个进程中**，因此他们之间交互需要通过 **Binder IPC 机制**的支持，在这个过程中`Client` 首先获取到 `Server` 端的代理对象，在 `Client` 看来 `ActivityManagerProxy` 对象同样具有 `ActivityManagerService` 本地对象承诺的能力，因此 `Client` 可以调用 `ActivityManagerProxy` 跟 `ActivityManagerService` 对象进行数据交互，**`Binder` 驱动**作为桥梁在他们中间起到中间人的作用。\n同样，`AMS` 是运行在 `system_server` 线程中的，这时 `AMS` 就相当于 AIDL 中的远程 服务端，App 进程要与 AMS 交互，需要通过 **AMS的代理**对象 `ActivityManagerProxy` 来完成，来看 `ActivityManagerNative.getDefault()` 拿到的是什么：\n[frameworks/base/core/java/android/app/ActivityManagerNative.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/ActivityManagerNative.java)\n\n```JAVA\nstatic public IActivityManager getDefault() {\n    return gDefault.get();\n}\n```\n\n`getDefault` 是一个静态变量：\n\n\n```JAVA\nprivate static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {\n    protected IActivityManager create() {\n        // 向 ServiceManager 查询一个 key 为 \"activity\" 的引用\n        IBinder b = ServiceManager.getService(\"activity\");\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service binder = \" + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service = \" + am);\n        }\n        return am;\n    }\n};\n```\n\n\n`ServiceManager` **是 Binder IPC通信过程的核心**，是上下文的管理者，`Binder` 服务端必须先向 `ServerManager` 注册才能够为客户端提供服务，`Binder` 客户端在与服务端通信之前需要从 `ServerManager` **中查找并获取 `Binder` 服务端的引用**。\n\n这里通过 \"**activity**\" 这个名字向 `ServiceManager` 查询 `AMS` 的引用，获取 `AMS` 的引用后，调用 `asInterface` 方法：\n\n\n```JAVA\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    // 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章\n    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n    // 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回\n    return new ActivityManagerProxy(obj);\n}\n```\n\n因为 `AMS` 与 `Launcher App` 不在同一个进程中，这里返回的 `IBinder` 对象是一个 `Binder` 代理对象，因此这类将其包装成 `ActivityManagerProxy`对象并返回，`ActivityManagerProxy` 是`ActivityManagerNative` 的内部类，查看 `ActivityManagerProxy` 类 ：\n\n```JAVA\nclass ActivityManagerProxy implements IActivityManager\n{\n    public ActivityManagerProxy(IBinder remote)\n    {\n        mRemote = remote;\n    }\n\n    public IBinder asBinder()\n    {\n        return mRemote;\n    }\n\n    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n        ...\n        // 调用号为 START_ACTIVITY_TRANSACTION\n        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n        reply.readException();\n        int result = reply.readInt();\n        reply.recycle();\n        data.recycle();\n        return result;\n    }\n    ...\n    public ComponentName startService(IApplicationThread caller, Intent service,\n            String resolvedType, String callingPackage, int userId) throws RemoteException\n    {\n        ...\n        mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);\n        reply.readException();\n        ComponentName res = ComponentName.readFromParcel(reply);\n        data.recycle();\n        reply.recycle();\n        return res;\n    }\n    ...\n}\n```\n可以看到，`ActivityManagerProxy` 里面将客户端的请求通过 `mRemote.transact`  进行转发，`mRemote` 对象正是 `Binder` 驱动返回来的 **Binder 服务端的 Proxy** 对象，通过 这个`Binder Proxy`，`Binder` 驱动最终将调用处于 `Binder Server` 端 `ActivityManagerNative` 中的 `onTransact` 方法：\n\n\n```JAVA\n@Override\npublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n    // 根据方法调用号 code 决定调用哪个方法\n    switch (code) {\n    case START_ACTIVITY_TRANSACTION:\n    {\n        ...\n        // 调用 startActivity 方法\n        int result = startActivity(app, callingPackage, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);\n        reply.writeNoException();\n        reply.writeInt(result);\n        return true;\n    }\n    ...\n    case START_SERVICE_TRANSACTION: {\n        ...\n        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);\n            reply.writeNoException();\n            ComponentName.writeToParcel(cn, reply);\n            return true;\n        }\n        ...\n    }\n}\n```\n### 1.1.8 ActivityManagerService.startActivity\n`ActivityManagerNative` 是一个抽象类，它的 `startActivity` 为抽象方法，具体的实现在 [frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityManagerService.java) 中：\n\n\n```JAVA\n@Override\npublic final int startActivity(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {\n    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n            resultWho, requestCode, startFlags, profilerInfo, bOptions,\n            UserHandle.getCallingUserId());\n}\n```\n## 1.2 小结\n你应该可以发现，相对于 `AIDL` 的调用过程，调用方 `Launcher App` 相当于 AIDL 过程中的 `Clinent`端；AMS 相当于远程 Service 的角色，充当 Server 端角色，他们的调用过程总体上都是一样的。\n从 Launcher App 到 AMS 的时序图如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u54pqf70j30sk0gqabi.jpg)\n\n\n# 2. AMS —— zygote\n\n## 2.1 调用过程分析\n### 2.1.1 ActivityManagerService.startActivityAsUser\n接着从 `AMS` 的 `startActivityAsUser` 方法开始分析：\n\n\n```JAVA\n@Override\npublic final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {\n    enforceNotIsolatedCaller(\"startActivity\");\n    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, false, ALLOW_FULL_ONLY, \"startActivity\", null);\n    // TODO: Switch to user app stacks here.\n    // 调用 ActivityStarter 的 startActivityMayWait 方法\n    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,\n            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n            profilerInfo, null, null, bOptions, false, userId, null, null);\n}\n```\n\n### 2.1.2 ActivityStarter.startActivityMayWait\n继续跟进 [frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStarter.java)\n\n\n```JAVA\nfinal int startActivityMayWait(IApplicationThread caller, int callingUid,\n        String callingPackage, Intent intent, String resolvedType,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        IBinder resultTo, String resultWho, int requestCode, int startFlags,\n        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,\n        Bundle bOptions, boolean ignoreTargetSecurity, int userId,\n        IActivityContainer iContainer, TaskRecord inTask) {\n   ...\n   synchronized (mService) {\n        ...\n        // 调用 startActivityLocked 方法\n        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,\n                aInfo, rInfo, voiceSession, voiceInteractor,\n                resultTo, resultWho, requestCode, callingPid,\n                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,\n                options, ignoreTargetSecurity, componentSpecified, outRecord, container,\n                inTask);\n        ...\n        return res;\n    }\n}\n```\n\n### 2.1.3 ActivityStarter.startActivityLocked\n查看 `startActivityLocked` 方法：\n\n\n```JAVA\nfinal int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,\n        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,\n        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,\n        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,\n        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,\n        TaskRecord inTask) {\n    ...\n    // 调用 doPendingActivityLaunchesLocked 方法，传入 false 参数\n    doPendingActivityLaunchesLocked(false);\n    ...\n    return err;\n}\n\n```\n\n### 2.1.4 ActivityStarter.doPendingActivityLaunchesLocked\n查看 `doPendingActivityLaunchesLocked` 方法：\n\n\n```JAVA\nfinal void doPendingActivityLaunchesLocked(boolean doResume) {\n    while (!mPendingActivityLaunches.isEmpty()) {\n        final PendingActivityLaunch pal = mPendingActivityLaunches.remove(0);\n        final boolean resume = doResume && mPendingActivityLaunches.isEmpty();\n        try {\n            // 调用 startActivityUnchecked 方法\n            final int result = startActivityUnchecked(pal.r, pal.sourceRecord, null, null,\n                pal.startFlags, resume, null, null);\n            postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, \n                mSourceRecord, mTargetStack);\n        } catch (Exception e) {\n            Slog.e(TAG, \"Exception during pending activity launch pal=\" + pal, e);\n            pal.sendErrorResult(e.getMessage());\n        }\n    }\n}\n```\n### 2.1.5 ActivityStarter.startActivityUnchecked\n查看 `startActivityUnchecked` 方法：\n\n\n```JAVA\nprivate int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {\n    ...  \n    // 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法\n    mSupervisor.resumeFocusedStackTopActivityLocked();  \n    ... \n    return START_SUCCESS;\n}\n\n```\n\n### 2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked\n\n[frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java)\n\n\n```JAVA\nboolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target,\n            ActivityOptions targetOptions) {\n    if (targetStack != null && isFocusedStack(targetStack)) {\n        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法\n        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    }\n    return false;\n}\n```\n\n\n### 2.1.7 ActivityStack.resumeTopActivityUncheckedLocked\n查看 `ActivityStack` 的 `resumeTopActivityUncheckedLocked` 方法：\n```java\nboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {\n    ...\n    try {\n        ...\n        // 调用 resumeTopActivityInnerLocked 方法\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    return result;\n}\n```\n\n### 2.1.8 ActivityStack.resumeTopActivityInnerLocked\n查看 `resumeTopActivityInnerLocked` 方法：\n```java\nprivate boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {\n    ...\n    final ActivityRecord next = topRunningActivityLocked();\n    ...\n    if (next.app != null && next.app.thread != null) {\n        ...\n    } else {\n        ...\n        if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Restarting \" + next);\n        // 调用 ActivityStackSupervisor 的 startSpecificActivityLocked 方法\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n    return true;\n}\n```\n### 2.1.9 ActivityStackSupervisor.startSpecificActivityLocked\n回到 `ActivityStackSupervisor` 的 `startSpecificActivityLocked` 方法：\n```java\nvoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {\n    // 当前 Activity 附属的 Application\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n            r.info.applicationInfo.uid, true);\n    r.task.stack.setLaunchTime(r);\n    // 如果 Application 已经运行\n    if (app != null && app.thread != null) {\n        try {\n            if ((r.info.flags&ActivityInfo.FLAG_MULTIPROCESS) == 0\n                    || !\"android\".equals(r.info.packageName)) {\n                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,\n                        mService.mProcessStats);\n            }\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Exception when starting activity \"\n                    + r.intent.getComponent().flattenToShortString(), e);\n        }\n    }\n    // 如果 Application 没有运行,调用AMS,启动新进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n            \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n首先，在方法中获取了当前 `Activity` 附属的 `Application`，如果已经在运行了，说明这个 App 是已经被启动过了的，这时候调用 `realStartActivityLocked` 方法就可以进入下一步的流程了，同一个 App 中不同 `Activity` 的相互启动就是走的这个流程。当 `Application` 没有运行的时候，就需要调用 `AMS` 的 `startProcessLocked` 方法启动一个进程去承载它然后完成后续的工作，顺便铺垫一下，当新进程被启动完成后还会调用回到这个方法，查看 `AMS` 的 `startProcessLocked` 方法：\n### 2.1.10 ActivityManagerService.startProcessLocked\n\n```java\nfinal ProcessRecord startProcessLocked(String processName,\n        ApplicationInfo info, boolean knownToBeDead, int intentFlags,\n        String hostingType, ComponentName hostingName, boolean allowWhileBooting,\n        boolean isolated, boolean keepIfLarge) {\n    return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,\n            hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,\n            null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,\n            null /* crashHandler */);\n}\n```\n### 2.1.11 ActivityManagerService.startProcessLocked\n调用 `startProcessLocked` 方法：\n```java\nfinal ProcessRecord startProcessLocked(String processName, ApplicationInfo info,\n        boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,\n        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,\n        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler){\n    ...\n    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);\n    checkTime(startTime, \"startProcess: done starting proc!\");\n    return (app.pid != 0) ? app : null;\n}\n```\n### 2.1.12 ActivityManagerService.startProcessLocked\n调用 `startProcessLocked` 的重载方法：\n```java\nprivate final void startProcessLocked(ProcessRecord app, String hostingType,\n        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs){\n    ...\n    try {\n        ...\n        // 调用 Process 的 start 方法\n        Process.ProcessStartResult startResult = Process.start(entryPoint,\n                app.processName, uid, uid, gids, debugFlags, mountExternal,\n                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                app.info.dataDir, entryPointArgs);\n        ...\n    } catch (RuntimeException e) {\n        ...\n    }\n}\n```\n### 2.1.13 Process.start\n[frameworks/base/services/core/java/android/os/Process.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/os/Process.java)\n```java\npublic static final ProcessStartResult start(final String processClass,\n                                final String niceName,\n                                int uid, int gid, int[] gids,\n                                int debugFlags, int mountExternal,\n                                int targetSdkVersion,\n                                String seInfo,\n                                String abi,\n                                String instructionSet,\n                                String appDataDir,\n                                String[] zygoteArgs) {\n    try {\n        // 调用 startViaZygote 方法\n        return startViaZygote(processClass, niceName, uid, gid, gids,\n                debugFlags, mountExternal, targetSdkVersion, seInfo,\n                abi, instructionSet, appDataDir, zygoteArgs);\n    } catch (ZygoteStartFailedEx ex) {\n        Log.e(LOG_TAG,\n                \"Starting VM process through Zygote failed\");\n        throw new RuntimeException(\n                \"Starting VM process through Zygote failed\", ex);\n    }\n}\n```\n### 2.1.14 Process.startViaZygote\n查看 `startViaZygote` 方法：\n```java\nprivate static ProcessStartResult startViaZygote(final String processClass,\n                                final String niceName,\n                                final int uid, final int gid,\n                                final int[] gids,\n                                int debugFlags, int mountExternal,\n                                int targetSdkVersion,\n                                String seInfo,\n                                String abi,\n                                String instructionSet,\n                                String appDataDir,\n                                String[] extraArgs)\n                                throws ZygoteStartFailedEx {\n    synchronized(Process.class) {\n        ...\n        // 调用 zygoteSendArgsAndGetResult 方法，传入 openZygoteSocketIfNeeded 的返回值\n        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n    }\n}\n```\n### 2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded\n查看 `zygoteSendArgsAndGetResult` 方法：\n```java\nprivate static ProcessStartResult zygoteSendArgsAndGetResult(\n            ZygoteState zygoteState, ArrayList<String> args)\n            throws ZygoteStartFailedEx {\n    try {\n        ...\n        final BufferedWriter writer = zygoteState.writer;\n        final DataInputStream inputStream = zygoteState.inputStream;\n\n        writer.write(Integer.toString(args.size()));\n        writer.newLine();\n\n        for (int i = 0; i < sz; i++) {\n            String arg = args.get(i);\n            writer.write(arg);\n            writer.newLine();\n        }\n\n        writer.flush();\n\n        // Should there be a timeout on this?\n        ProcessStartResult result = new ProcessStartResult();\n\n        // 等待 socket 服务端（即zygote）返回新创建的进程pid;\n        result.pid = inputStream.readInt();\n        result.usingWrapper = inputStream.readBoolean();\n\n        if (result.pid < 0) {\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n        return result;\n    } catch (IOException ex) {\n        zygoteState.close();\n        throw new ZygoteStartFailedEx(ex);\n    }\n}\n```\n在 `zygoteSendArgsAndGetResult` 中等待 `Socket` 服务端，也就是 `zygote` 进程返回创建新进程的结果，这里 `zygoteState` 参数是由 `openZygoteSocketIfNeeded` 方法返回的，`openZygoteSocketIfNeeded` 方法则负责根据 `abi` 向 `Zygote` 进程发起连接请求：\n```java\nprivate static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n        try {\n            // 向主zygote发起connect()操作\n            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n        } catch (IOException ioe) {\n            throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n        }\n    }\n\n    if (primaryZygoteState.matches(abi)) {\n        return primaryZygoteState;\n    }\n\n    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n        try {\n            // 当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n        } catch (IOException ioe) {\n            throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n        }\n    }\n\n    if (secondaryZygoteState.matches(abi)) {\n        return secondaryZygoteState;\n    }\n\n    throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n}\n```\n## 2.2 小结\n如果是从桌面新启动一个 App 中的 `Activity`，此时是没有进程去承载这个 App 的，因此需要通过 `AMS` 向 `zygote` 继承发起请求去完成这个任务，AMS 运行在 `system_server` 进程中，它通过 `Socket` 向 `zygote` 发起 `fock` 进程的请求，从 `AMS` 开始的调用时序图如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u5m53eloj30t50p7tcl.jpg)\n\n\n\n# 3. zygote —— ActivityThread\n## 3.1 调用过程分析\n### 3.1.1 ZygoteInit.main\n\n`zygote` 进程的其中一项任务就是：\n\n调用 `registerZygoteSocket() `函数建立 `Socket` 通道，使 `zygote` 进程成为 `Socket` 服务端，并通过` runSelectLoop()` 函数等待 `ActivityManagerService` 发送请求创建新的应用程序进程。\n\n`zygote` 终于要再次上场了！接下来从 **ZygoteInit.java** 的 `main` 方法开始回顾一下 `zygote` 进程的工作：\n\n[frameworks/base/core/java/com/android/internal/os/ZygoteInit.java：](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java)\n```java\npublic static void main(String argv[]) {\n    try {\n        ...\n        runSelectLoop(abiList);\n        ....\n    } catch (MethodAndArgsCaller caller) {\n        caller.run();\n    } catch (RuntimeException ex) {\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n### 3.1.2 ZygoteInit.runSelectLoop\n查看 `runSelectLoop` 方法：\n```java\nprivate static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n    ...\n    // 循环读取状态\n    while (true) {\n        ...\n        for (int i = pollFds.length - 1; i >= 0; --i) {\n            // 读取的状态不是客户端连接或者数据请求时，进入下一次循环\n            if ((pollFds[i].revents & POLLIN) == 0) {\n                continue;\n            }\n            if (i == 0) {// i = 0 表示跟客户端 Socket 连接上了\n                ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                peers.add(newPeer);\n                fds.add(newPeer.getFileDesciptor());\n            } else {// i > 0 表示接收到客户端 Socket 发送过来的请求\n                // runOnce 方法创建一个新的应用程序进程\n                boolean done = peers.get(i).runOnce();\n                if (done) {\n                    peers.remove(i);\n                    fds.remove(i);\n                }\n            }\n        }\n    }\n}\n```\n### 3.1.3 ZygoteConnection.runOnce\n查看 [frameworks/base/core/java/com/android/internal/os/](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java)\n**ZygoteConnection.java** 的 `runOnce` 方法：\n```java\nboolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n    String args[];\n    Arguments parsedArgs = null;\n    FileDescriptor[] descriptors;\n\n    try {\n        // 读取 socket 客户端发送过来的参数列表\n        args = readArgumentList();\n        descriptors = mSocket.getAncillaryFileDescriptors();\n    } catch (IOException ex) {\n        // EOF reached.\n        closeSocket();\n        return true;\n    }\n    ...\n    try {\n        // 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式\n        parsedArgs = new Arguments(args);\n        ...\n        // 同样调用 Zygote.java 的 forkAndSpecialize 方法 fock 出子进程\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                parsedArgs.appDataDir);\n    } catch (Exception e) {\n        ...\n    }\n\n    try {\n        if (pid == 0) {\n            // 子进程执行\n            IoUtils.closeQuietly(serverPipeFd);\n            serverPipeFd = null;\n            // 进入子进程流程\n            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n            return true;\n        } else {\n            // 父进程执行\n            IoUtils.closeQuietly(childPipeFd);\n            childPipeFd = null;\n            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n        }\n    } finally {\n        IoUtils.closeQuietly(childPipeFd);\n        IoUtils.closeQuietly(serverPipeFd);\n    }\n}\n```\n### 3.1.4 ZygoteConnection.handleChildProc\n首先解析 `Socket` 客户端传过来的参数，`Zygote.java` 的 `forkAndSpecialize` 返回的 `pid == 0` 的时候表示此时在 `fock` 出来的子进程中执行，继续调用 `handleChildProc` 方法，并将参数继续层层传递：\n```JAVA\nprivate void handleChildProc(Arguments parsedArgs, FileDescriptor[] \n    descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller {\n    /*由于 fock 出来的 system_server 进程会复制 zygote 进程的地址空间，因此它也得到了 zygote\n    进程中的 Socket，这个 Socket 对它来说并无用处，这里将其关闭 \n    */\n    closeSocket();\n    ZygoteInit.closeServerSocket();\n    ...\n    if (parsedArgs.niceName != null) {\n        // 设置进程名\n        Process.setArgV0(parsedArgs.niceName);\n    }\n\n    if (parsedArgs.invokeWith != null) {\n        ...\n    } else {\n        // 调用 RuntimeInit 的 zygoteInit 方法\n        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                parsedArgs.remainingArgs, null);\n    }\n}\n```\n### 3.1.5 RuntimeInit.zygoteInit\n查看 [frameworks/base/core/java/com/android/internal/os/RuntimeInit.java ](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java)的 `zygoteInit` 方法：\n```java\npublic static final void zygoteInit(int targetSdkVersion, String[] argv, \n            ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller {\n    if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n    // 重定向 log 输出\n    redirectLogStreams();\n    // 初始化一些通用的设置\n    commonInit(); \n    /**\n     *通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 的 \n     *onZygoteInit 方法启动 Binder 线程池， 使 system_server 进程可以使用 Binder  *与其他进程通信\n     **/\n    nativeZygoteInit(); \n    applicationInit(targetSdkVersion, argv, classLoader);\n}\n```\n### 3.1.6 RuntimeInit.applicationInit\n继续调用 `applicationInit` 方法：\n```java\nprivate static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    // 提取出参数里面的要启动的类的名字\n    invokeStaticMain(args.startClass, args.startArgs, classLoader);\n}\n```\n### 3.1.7 RuntimeInit.invokeStaticMain\n主要调用了 `invokeStaticMain` 方法：\n```java\nprivate static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n         throws ZygoteInit.MethodAndArgsCaller {\n    Class<?> cl;\n    try {\n        /** className 为通过 Socket 客户端（AMS）传递过来的一系列参数中的其中一个，这里获取到的值为传\"com.android.app.ActivityThread\"，然后通过反射得到 ActivityThread 类 **/\n        cl = Class.forName(className, true, classLoader);\n    } catch (ClassNotFoundException ex) {\n        throw new RuntimeException(\n            \"Missing class when invoking static main \" + className, ex);\n    }\n    Method m;\n    try {\n        // 找到 ActivityThread 类的 main 方法\n        m = cl.getMethod(\"main\", new Class[] { String[].class });\n    } catch (NoSuchMethodException ex) {\n        throw new RuntimeException(\n            \"Missing static main on \" + className, ex);\n    } catch (SecurityException ex) {\n        throw new RuntimeException(\n            \"Problem getting static main on \" + className, ex);\n    }\n    int modifiers = m.getModifiers();\n    if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {\n        throw new RuntimeException(\n            \"Main method is not public and static on \" + className);\n    }\n    /** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出\n    捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/\n    throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n}\n```\n### 3.1.8 MethodAndArgsCaller.run\n回到 `ZygoteInit` 的 `main` 方法：\n```java\npublic static void main(String argv[]) {\n    ...\n    closeServerSocket();\n    } catch (MethodAndArgsCaller caller) {\n        // 接收到 caller 对象后调用它的 run 方法\n        caller.run();\n    } catch (RuntimeException ex) {\n        Log.e(TAG, \"Zygote died with exception\", ex);\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n跟 `system_server` 进程的启动过程一样，这里同样通过抛出异常的方式来清空调用 `ActivityThread.main `之前的方法栈帧。\n`ZygoteInit` 的 `MethodAndArgsCaller` 类是一个 `Exception` 类，同时也实现了 `Runnable` 接口：\n```java\npublic static class MethodAndArgsCaller extends Exception\n        implements Runnable {\n        \n    private final Method mMethod;\n    private final String[] mArgs;\n        \n    public MethodAndArgsCaller(Method method, String[] args) {\n        mMethod = method;\n        mArgs = args;\n    }\n    public void run() {\n        try {\n            // 调用传递过来的 mMethod\n            mMethod.invoke(null, new Object[] { mArgs });\n        } catch (IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        } catch (InvocationTargetException ex) {\n            ...\n        }\n    }\n}\n```\n### 3.1.9 ActivityThread .main\n最后通过反射调用到 `ActivityThread` 的 `main` 方法：\n```java\npublic static void main(String[] args) {\n    ...\n    Environment.initForCurrentUser();\n    ...\n    Process.setArgV0(\"<pre-initialized>\");\n    // 创建主线程 Looper\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    // attach 到系统进程\n    thread.attach(false);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    // 主线程进入轮询状态\n    Looper.loop();\n\n    // 抛出异常说明轮询出现问题\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n## 3.2 小结\n`zygote` 进程作为 `Socket` 服务端在接收到作为客户端的 `AMS` 发送过来的请求和参数之后，`fock` 出新的进程并根据各种参数进程了初始化的工作，这个过程和 `zygote` 启动 `system_server` 进程的过程如出一辙，时序图如下所示：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u80ukv7ej30q30ivmzb.jpg)\n\n\n# 4. ActivityThread —— Activity\n##4.1 调用过程分析\n### 4.1.1 ActivityThread.attach\n上一小节的最后，`ActivityThread` 的 `main` 通过反射被运行起来了，接着会调用 `ActivityThread` 的 `attach` 方法：\n\n\n```JAVA\nprivate void attach(boolean system) {\n    ...\n    mSystemThread = system;\n    if (!system) {\n        ...\n        // 获取 ActivityManagerProxy 对象\n        final IActivityManager mgr = ActivityManagerNative.getDefault();\n        try {\n            // 通过 Binder 调用 AMS 的 attachApplication 方法\n            mgr.attachApplication(mAppThread);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    } else {\n        ...\n    }\n    ...\n}\n```\n\n这里，我们再一次通过 `Binder IPC` 机制跟 `AMS` 通信，通信模型跟前面` Launcher App `调用 `AMS` 的 `startActivity` 方法一样，getDefault 过程不重复分析，这次是调用了 `AMS` 的 `attachApplication` 方法，注意这里将 `ApplicationThead` 类型的 `mAppThread` 对象作为参数传递了过去，`ApplicationThead` 是 `ActivityThread` 的一个内部类，后面我们会讲到，先查看 `AMP` 的 `attachApplication` 方法：\n### 4.1.2 ActivityManagerProxy.attachApplication\n```java\npublic void attachApplication(IApplicationThread app) throws RemoteException {\n    ...\n    // 调用 asBinder 方法使其能够跨进程传输\n    data.writeStrongBinder(app.asBinder());\n    // 通过 transact 方法将数据交给 Binder 驱动\n    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); \n    reply.readException();\n    data.recycle();\n    reply.recycle();\n}\n```\n### 4.1.3 ActivityManagerNative.onTransact\n```java\npublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n    switch (code) {\n        ...\n        case ATTACH_APPLICATION_TRANSACTION: {\n            data.enforceInterface(IActivityManager.descriptor);\n            // 获取 ApplicationThread 的代理对象，这里返回的是 ApplicationThreadNative(ATN)\n            // 的内部类：ApplicationThreadProxy(ATP) 对象\n            IApplicationThread app = ApplicationThreadNative.asInterface(data.readStrongBinder());\n            if (app != null) {\n                // 委托给 AMS 执行\n                attachApplication(app);\n            }\n            reply.writeNoException();\n            return true;\n        }\n        ...\n    }\n}\n```\n`asInterface` 将 `ActivityThread` 对象**转换**成了 `ApplicationThreadNative` 的 `Binder` 代理对象 `ApplicationThreadProxy`，并作为参数传给 `attachApplication` 方法，其中 `ApplicationThreadProxy` 是 `ApplicationThreadNative` 的**内部类**。\n### 4.1.4 ActivityManagerService.attachApplication\n```java\npublic final void attachApplication(IApplicationThread thread) {\n    synchronized (this) {\n        int callingPid = Binder.getCallingPid();\n        final long origId = Binder.clearCallingIdentity();\n        attachApplicationLocked(thread, callingPid);\n        Binder.restoreCallingIdentity(origId);\n    }\n}\n```\n### 4.1.5 ActivityManagerService.attachApplicationLocked\n```java\nprivate final boolean attachApplicationLocked(IApplicationThread thread, int pid) {\n    ProcessRecord app;\n    ...\n    try {\n        // 绑定死亡通知\n        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);\n        thread.asBinder().linkToDeath(adr, 0);\n        app.deathRecipient = adr;\n    } catch (RemoteException e) {\n        app.resetPackageList(mProcessStats);\n        // 如果 system_server 进程死亡则重新启动进程\n        startProcessLocked(app, \"link fail\", processName); \n        return false;\n    }\n    ...\n    try {\n        ...\n        // 获取应用appInfo\n        ApplicationInfo appInfo = app.instrumentationInfo != null\n                ? app.instrumentationInfo : app.info;\n        ...\n        // 绑定应用\n        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n                isRestrictedBackupMode || !normalMode, app.persistent,\n                new Configuration(mConfiguration), app.compat,\n                getCommonServicesLocked(app.isolated),\n                mCoreSettingsObserver.getCoreSettingsLocked());\n        ...\n    } catch (Exception e) {\n        app.resetPackageList(mProcessStats);\n        app.unlinkDeathRecipient();\n        // bindApplication 失败也要重启进程\n        startProcessLocked(app, \"bind fail\", processName);\n        return false;\n    }\n    // 如果是 Activity: 检查最顶层可见的Activity是否等待在该进程中运行\n    if (normalMode) {\n        try {\n            if (mStackSupervisor.attachApplicationLocked(app)) {\n                didSomething = true;\n            }\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    // 如果是 Service: 寻找所有需要在该进程中运行的服务\n    if (!badApp) {\n        try {\n            didSomething |= mServices.attachApplicationLocked(app, processName);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n\n    // 如果是 BroadcastReceiver: 检查是否在这个进程中有下一个广播接收者\n    if (!badApp && isPendingBroadcastProcessLocked(pid)) {\n        try {\n            didSomething |= sendPendingBroadcastsLocked(app);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    // 检查是否在这个进程中有下一个 backup 代理\n    if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {\n        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);\n        try {\n            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,\n                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),\n                    mBackupTarget.backupMode);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    if (badApp) { \n        // 杀掉 badApp\n        app.kill(\"error during init\", true);\n        handleAppDiedLocked(app, false, true);\n        return false;\n    }\n    if (!didSomething) {\n        // 更新 adj(组件的权值)\n        updateOomAdjLocked(); \n    }\n    return true;\n}\n```\n\n首先，通过 `ApplicationThreadProxy` 使用 `Binder` 向 `ApplicationThreadProxy` 发起 `bindApplication` 请求，然后通过 `normalMode` 字段判断是否为 `Activity`，如果是则执行 `ActivityStackSupervisor` 的 `attachApplicationLocked` 方法。\n#### 4.1.5.1 ActivityThread.java::ApplicationThread.bindApplication\n`thread` 对象类型是 `ApplicationThreadProxy`，通过 `Binder` 驱动调到了 `ApplicationThreadNative` 的方法，`ApplicationThreadNative` 是一个抽象类，它的实现都委托给了 `ApplicationThread`(这跟 AMS 跟 AMN 的关系一样)，ApplicationThread 作为 ActivityThread 的内部类存在，它的 binderApplication 方法如下：\n```java\nActivityThread.java::ApplicationThread：\npublic final void bindApplication(String processName, ApplicationInfo appInfo,\n    List<ProviderInfo> providers, ComponentName instrumentationName, ProfilerInfo profilerInfo,\n    Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,\n    IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean\n    enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration\n    config, CompatibilityInfo compatInfo, Map<String, IBinder> services, Bundle coreSettings) {\n\n    if (services != null) {\n        // 将services缓存起来, 减少binder检索服务的次数\n        ServiceManager.initServiceCache(services);\n    }\n    ...\n    // 发送消息 H.BIND_APPLICATION 给 Handler 对象\n    sendMessage(H.BIND_APPLICATION, data);\n}\n```\n**H** 是 **ActivityThread** 中的一个 **Handler** 对象，用于处理发送过来的各种消息：\n```java\nprivate class H extends Handler {\n    public static final int BIND_APPLICATION        = 110;\n \n    public void handleMessage(Message msg) {\n        ...\n        case BIND_APPLICATION:\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n            AppBindData data = (AppBindData)msg.obj;\n            handleBindApplication(data);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            break;\n        ...\n    }\n}\n```\n调用了 `handleBindApplication` 方法：\n```\nprivate void handleBindApplication(AppBindData data) {\n    // 获取 LoadedApk 对象\n    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);\n    ...\n    // 创建 ContextImpl 上下文\n    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);\n    ...\n    // 创建 Instrumentation 对象\n    if (data.instrumentationName != null) {\n        ...\n    } else {\n        mInstrumentation = new Instrumentation();\n    }\n\n    try {\n        // 调用 LoadedApk 的 makeApplication 方法创建 Application\n        Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n        mInitialApplication = app;\n        ...\n        mInstrumentation.onCreate(data.instrumentationArgs);\n        // 调用 Application.onCreate 方法\n        mInstrumentation.callApplicationOnCreate(app);\n    } finally {\n        StrictMode.setThreadPolicy(savedPolicy);\n    }\n}\n```\n#### 4.1.5.2 ActivityStackSupervisor.attachApplicationLocked\n在 **4.1.4** 小节中通过 **Binder** 向 **ActivityThread** 发起 `bindApplication` 请求后，会根据启动组件的类型去做相应的处理，如果是 `Acitivity`，则会调用 **ActivityStackSupervisor** 的 `attachApplicationLocked` 方法：\n```java\nboolean attachApplicationLocked(ProcessRecord app) throws RemoteException {\n    final String processName = app.processName;\n    boolean didSomething = false;\n    for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {\n        ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;\n        for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {\n            final ActivityStack stack = stacks.get(stackNdx);\n            if (!isFrontStack(stack)) {\n                continue;\n            }\n            // 获取前台stack中栈顶第一个非 finishing 状态的 Activity\n            ActivityRecord hr = stack.topRunningActivityLocked(null);\n            if (hr != null) {\n                if (hr.app == null && app.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {\n                    try {\n                        // 真正的启动 Activity\n                        if (realStartActivityLocked(hr, app, true, true)) {\n                            didSomething = true;\n                        }\n                    } catch (RemoteException e) {\n                        throw e;\n                    }\n                }\n            }\n        }\n    }\n    ...\n    return didSomething;\n}\n##### 4.1.5.2.1 ActivityStackSupervisor.realStartActivityLocked\n\n前面 **2.1.8ActivityStackSupervisor.startSpecificActivityLocked**  小节中分析过，如果当前 `Activity` 依附的 `Application` 已经被启动，则调用 `realStartActivityLocked` 方法，否则创建新的进程，再创建新的进程之后，两个流程的在这里合并起来了：\n```java\nfinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException {\n    ...\n    final ActivityStack stack = task.stack;\n    try {\n        ...\n        app.forceProcessStateUpTo(mService.mTopProcessState);\n        // 通过 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法\n        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n        ...\n    } catch (RemoteException e) {\n        if (r.launchFailed) {\n            // 第二次启动失败，则结束该 Activity\n            mService.appDiedLocked(app);\n            stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                    \"2nd-crash\", false);\n            return false;\n        }\n        // 第一个启动失败，则重启进程\n        app.activities.remove(r);\n        throw e;\n    }\n    ...\n    return true;\n}\n``` \n这里有一次使用 `Binder` 调用 `ApplicationThread` 的 `scheduleLaunchActivity` 方法。\n\n##### 4.1.5.2.2 ApplicationThread.scheduleLaunchActivity\n\n```java\npublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo \n        info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo \n        compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle \n        state, PersistableBundle persistentState, List<ResultInfo> pendingResults, \n        List<ReferrerIntent> pendingNewIntents, boolean notResumed, boolean isForward, \n        ProfilerInfo profilerInfo) {\n    ...\n    updateProcessState(procState, false);\n    ActivityClientRecord r = new ActivityClientRecord();\n    ...\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n }\n```\n\n上面提到过，**H** 是 **ActivityThread** 中一个 **Handler** 类，它接收到 `LAUNCH_ACTIVITY` 消息后会调用 `handleLaunchActivity` 方法。\n##### 4.1.5.2.3 ActivityThread.handleLaunchActivity\n\n```java\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    // 初始化 WMS\n    WindowManagerGlobal.initialize();\n    // 执行 performLaunchActivity 方法\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        Bundle oldState = r.state;\n        // 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                !r.activity.mFinished && !r.startsNotResumed);\n\n        if (!r.activity.mFinished && r.startsNotResumed) {\n            r.activity.mCalled = false;\n            mInstrumentation.callActivityOnPause(r.activity);\n            r.paused = true;\n        }\n    } else {\n        // 停止该 Activity\n        ActivityManagerNative.getDefault()\n            .finishActivity(r.token, Activity.RESULT_CANCELED, null, false);\n    }\n}\n```\n\n##### 4.1.4.2.4 ApplicationThread.performLaunchActivity\n\n```java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n        // Instrumentation 中使用反射创建 Activity\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n        ...\n    } catch (Exception e) {\n        ...\n    }\n\n    try {\n        // 创建 Application 对象并调用 Application 的 onCreate 方法\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n\n        if (activity != null) {\n            ...\n            // attach 到 Window 上\n            activity.attach(appContext, this, getInstrumentation(), r.token,\n                    r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                    r.embeddedID, r.lastNonConfigurationInstances, config,\n                    r.referrer, r.voiceInteractor);\n\n            if (customIntent != null) {\n                activity.mIntent = customIntent;\n            }\n            r.lastNonConfigurationInstances = null;\n            activity.mStartedActivity = false;\n            int theme = r.activityInfo.getThemeResource();\n            if (theme != 0) {\n                // 设置主题\n                activity.setTheme(theme);\n            }\n\n            activity.mCalled = false;\n            if (r.isPersistable()) {\n                // 重新创建的 Activity\n                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            } else {\n                // 第一次创建的 Activity\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            ...\n        }\n        ...\n    }  catch (Exception e) {\n        ...\n    }\n    return activity;\n}\n```\n\n##### 4.1.5.2.5 Instrumentation.callActivityOnCreate\n\n\n```java\npublic void callActivityOnCreate(Activity activity, Bundle icicle,\n            PersistableBundle persistentState) {\n    prePerformCreate(activity);\n    // 调用 Activity 的 performCreate 方法\n    activity.performCreate(icicle, persistentState);\n    postPerformCreate(activity);\n}\n```\n\n##### 4.1.5.2.6 Activity.performCreate\n```java\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n        restoreHasCurrentPermissionRequest(icicle);\n    onCreate(icicle, persistentState);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n终于，onCreate 方法被调用了！！！\n\n## 4.2 小结\n从 `ActivityThread` 到最终 `Activity` 被创建及生命周期被调用，核心过程涉及到了三次** Binder IPC** 过程，分别是：\n    \n    1. ActivityThread 调用 AMS 的 attachApplication 方法\n    \n    2. AMS 调用 ApplicationThread 的 bindApplication 方法\n    \n    3. ActivityStackSupervisor 调用 Application 的 attachApplicationLocked 方法\n\n\n整个过程的时序图如下：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u8r1k48wj30t30qo43w.jpg)\n\n5. 总结\n纵观整个过程，从 Launcher 到 AMS、从 AMS 再到 Zygote、再从 Zygote 到 ActivityThread，最后在 ActivitThread 中层层调用到 Activity 的生命周期方法，中间涉及到了无数的细节，但总体上脉络还是非常清晰的，各个 Android 版本的 Framework 层代码可以某些过程的实现不太一样，但是整个调用流程大体上也是相同的，借用 [Gityuan](http://gityuan.com/android/) 大神的一张图作为结尾：\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0u8shvqsuj30qo0k0gt0.jpg)\n\n","slug":"activitystartstep-1551942246673","published":1,"updated":"2019-03-08T09:26:29.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjszuvyuz000zqk9yobb3qdkv","content":"<h1 id=\"Android-App-Activity-启动流程分析\"><a href=\"#Android-App-Activity-启动流程分析\" class=\"headerlink\" title=\"Android App/Activity 启动流程分析\"></a>Android App/Activity 启动流程分析</h1><p>首先我们带着问题来看:</p>\n<ol>\n<li>点击了图标之后系统道理做了哪些工作呢？</li>\n<li>应用进程是怎么被启动的呢？</li>\n<li>Activity 的生命周期是什么时候被谁调用的呢？</li>\n</ol>\n<p>本文将继续基于 <strong>Android Nougat</strong> 的 Frameworks 层源码的解答这些问题。</p>\n<p>阅读建议：<br>如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。</p>\n<h2 id=\"1-1-调用过程分析\"><a href=\"#1-1-调用过程分析\" class=\"headerlink\" title=\"1.1 调用过程分析\"></a>1.1 调用过程分析</h2><h3 id=\"1-1-1-Launcher-onClick\"><a href=\"#1-1-1-Launcher-onClick\" class=\"headerlink\" title=\"1.1.1 Launcher.onClick\"></a>1.1.1 Launcher.onClick</h3><p>在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 <code>onClick</code> 方法，<br><a href=\"https://android.googlesource.com/platform/packages/apps/Launcher3/+/nougat-release/src/com/android/launcher3/Launcher.java?autodive=0%2F\" target=\"_blank\" rel=\"noopener\">packages/apps/Launcher3/src/com/android/launcher3/Launcher.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Object tag = v.getTag();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> ShortcutInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从快捷方式图标启动</span></span><br><span class=\"line\">        onClickAppShortcut(v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> FolderInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 文件夹</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v <span class=\"keyword\">instanceof</span> FolderIcon) &#123;</span><br><span class=\"line\">           onClickFolderIcon(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (v == mAllAppsButton) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// “所有应用”按钮</span></span><br><span class=\"line\">        onClickAllAppsButton(v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> AppInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从“所有应用”中启动的应用</span></span><br><span class=\"line\">        startAppShortcutOrInfoActivity(v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> LauncherAppWidgetInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 组件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v <span class=\"keyword\">instanceof</span> PendingAppWidgetHostView) &#123;</span><br><span class=\"line\">            onClickPendingWidget((PendingAppWidgetHostView) v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-2-Launcher-onClickAppShortcut\"><a href=\"#1-1-2-Launcher-onClickAppShortcut\" class=\"headerlink\" title=\"1.1.2 Launcher.onClickAppShortcut\"></a>1.1.2 Launcher.onClickAppShortcut</h3><p>如果是快捷方式图标，则调用 <code>onClickAppShortcut</code> 方法进而调用 <code>startAppShortcutOrInfoActivity</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Thunk</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startAppShortcutOrInfoActivity</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Object tag = v.getTag();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ShortcutInfo shortcut;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Intent intent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> ShortcutInfo) &#123;</span><br><span class=\"line\">        shortcut = (ShortcutInfo) tag;</span><br><span class=\"line\">        <span class=\"comment\">// 去除对应的 Intent 对象</span></span><br><span class=\"line\">        intent = shortcut.intent;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] pos = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        v.getLocationOnScreen(pos);</span><br><span class=\"line\">        intent.setSourceBounds(<span class=\"keyword\">new</span> Rect(pos[<span class=\"number\">0</span>], pos[<span class=\"number\">1</span>],</span><br><span class=\"line\">                pos[<span class=\"number\">0</span>] + v.getWidth(), pos[<span class=\"number\">1</span>] + v.getHeight()));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> AppInfo) &#123;</span><br><span class=\"line\">        shortcut = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        intent = ((AppInfo) tag).intent;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Input must be a Shortcut or AppInfo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 startActivitySafely 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> success = startActivitySafely(v, intent, tag);</span><br><span class=\"line\">    mStats.recordLaunch(v, intent, shortcut);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success &amp;&amp; v <span class=\"keyword\">instanceof</span> BubbleTextView) &#123;</span><br><span class=\"line\">        mWaitingForResume = (BubbleTextView) v;</span><br><span class=\"line\">        mWaitingForResume.setStayPressed(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-3-Launcher-startActivity\"><a href=\"#1-1-3-Launcher-startActivity\" class=\"headerlink\" title=\"1.1.3 Launcher.startActivity\"></a>1.1.3 Launcher.startActivity</h3><p>获取相应 App 的 <strong>Intent</strong> 信息之后，调用 <code>startActivity</code> 方法：<br>并设置Flags为<strong>Intent.FLAG_ACTIVITY_NEW_TASK</strong>,启动新的任务栈</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startActivity</span><span class=\"params\">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动新的任务栈</span></span><br><span class=\"line\">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span> || user.equals(UserHandleCompat.myUserHandle())) &#123;</span><br><span class=\"line\">            StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;            </span><br><span class=\"line\">                StrictMode.setVmPolicy(<span class=\"keyword\">new</span> StrictMode.VmPolicy.Builder().detectAll()</span><br><span class=\"line\">                        .penaltyLog().build());</span><br><span class=\"line\">                <span class=\"comment\">// 调用 Activity 的 startActivity 方法</span></span><br><span class=\"line\">                startActivity(intent, optsBundle);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                StrictMode.setVmPolicy(oldPolicy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            launcherApps.startActivityForProfile(intent.getComponent(), user,</span><br><span class=\"line\">                    intent.getSourceBounds(), optsBundle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;      </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1.1.4 Activity.startActivity<br>这里最终调用了 <code>Activity</code> 中的 <code>startActivity</code> 方法，并且设置 Flag 为 <strong>FLAG_ACTIVITY_NEW_TASK</strong>。到此为止，已经跟启动普通的 <code>Activity</code> 流程汇合起来了，继续往下分析。<br><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Activity.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/android/app/Activity.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第二个参数为 -1 表示不需要回调 onActivityResult 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Note we want to go through this call for compatibility with</span></span><br><span class=\"line\">        <span class=\"comment\">// applications that may have overridden the method.</span></span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-5-Activity-startActivityForResult\"><a href=\"#1-1-5-Activity-startActivityForResult\" class=\"headerlink\" title=\"1.1.5 Activity.startActivityForResult\"></a>1.1.5 Activity.startActivityForResult</h3><p>调用 <code>Activity</code> 的 <code>startActivityForResult</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(@RequiresPermission Intent intent, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @Nullable Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// mParent 是当前 Activity 的父类，此时条件成立</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Instrumentation 的 execStartActivity 方法</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(<span class=\"keyword\">this</span>,</span><br><span class=\"line\">               mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>, intent, requestCode, options);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-6-Instrumentation-execStartActivity\"><a href=\"#1-1-6-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"1.1.6 Instrumentation.execStartActivity\"></a>1.1.6 Instrumentation.execStartActivity</h3><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Instrumentation.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/android/app/Instrumentation.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, <span class=\"keyword\">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        intent.migrateExtraStreamToClipData();</span><br><span class=\"line\">        intent.prepareToLeaveProcess(who);</span><br><span class=\"line\">        <span class=\"comment\">// 获取 AMS 的代理对象并调用其 startActivity 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</span><br><span class=\"line\">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class=\"line\">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class=\"line\">                    token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                    requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</span><br><span class=\"line\">        checkStartActivityResult(result, intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-7-ActivityManagerProxy-startActivity\"><a href=\"#1-1-7-ActivityManagerProxy-startActivity\" class=\"headerlink\" title=\"1.1.7 ActivityManagerProxy.startActivity\"></a>1.1.7 ActivityManagerProxy.startActivity</h3><p>以上过程是在 <code>Launcher App</code>所在的进程中发生的，<strong>由于远程 </strong><code>AMS(ActivityManagerService)</code>跟使用 <code>Service</code> 的 <code>Activity</code> <strong>不在同一个进程中</strong>，因此他们之间交互需要通过 <strong>Binder IPC 机制</strong>的支持，在这个过程中<code>Client</code> 首先获取到 <code>Server</code> 端的代理对象，在 <code>Client</code> 看来 <code>ActivityManagerProxy</code> 对象同样具有 <code>ActivityManagerService</code> 本地对象承诺的能力，因此 <code>Client</code> 可以调用 <code>ActivityManagerProxy</code> 跟 <code>ActivityManagerService</code> 对象进行数据交互，<strong><code>Binder</code> 驱动</strong>作为桥梁在他们中间起到中间人的作用。<br>同样，<code>AMS</code> 是运行在 <code>system_server</code> 线程中的，这时 <code>AMS</code> 就相当于 AIDL 中的远程 服务端，App 进程要与 AMS 交互，需要通过 <strong>AMS的代理</strong>对象 <code>ActivityManagerProxy</code> 来完成，来看 <code>ActivityManagerNative.getDefault()</code> 拿到的是什么：<br><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/ActivityManagerNative.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/android/app/ActivityManagerNative.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>getDefault</code> 是一个静态变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 向 ServiceManager 查询一个 key 为 \"activity\" 的引用</span></span><br><span class=\"line\">        IBinder b = ServiceManager.getService(<span class=\"string\">\"activity\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">\"ActivityManager\"</span>, <span class=\"string\">\"default service binder = \"</span> + b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        IActivityManager am = asInterface(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">\"ActivityManager\"</span>, <span class=\"string\">\"default service = \"</span> + am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> am;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>ServiceManager</code> <strong>是 Binder IPC通信过程的核心</strong>，是上下文的管理者，<code>Binder</code> 服务端必须先向 <code>ServerManager</code> 注册才能够为客户端提供服务，<code>Binder</code> 客户端在与服务端通信之前需要从 <code>ServerManager</code> <strong>中查找并获取 <code>Binder</code> 服务端的引用</strong>。</p>\n<p>这里通过 “<strong>activity</strong>“ 这个名字向 <code>ServiceManager</code> 查询 <code>AMS</code> 的引用，获取 <code>AMS</code> 的引用后，调用 <code>asInterface</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">asInterface</span><span class=\"params\">(IBinder obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章</span></span><br><span class=\"line\">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivityManagerProxy(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 <code>AMS</code> 与 <code>Launcher App</code> 不在同一个进程中，这里返回的 <code>IBinder</code> 对象是一个 <code>Binder</code> 代理对象，因此这类将其包装成 <code>ActivityManagerProxy</code>对象并返回，<code>ActivityManagerProxy</code> 是<code>ActivityManagerNative</code> 的内部类，查看 <code>ActivityManagerProxy</code> 类 ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityManagerProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IActivityManager</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ActivityManagerProxy</span><span class=\"params\">(IBinder remote)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        mRemote = remote;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">asBinder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mRemote;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用号为 START_ACTIVITY_TRANSACTION</span></span><br><span class=\"line\">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class=\"number\">0</span>);</span><br><span class=\"line\">        reply.readException();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = reply.readInt();</span><br><span class=\"line\">        reply.recycle();</span><br><span class=\"line\">        data.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ComponentName <span class=\"title\">startService</span><span class=\"params\">(IApplicationThread caller, Intent service,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String resolvedType, String callingPackage, <span class=\"keyword\">int</span> userId)</span> <span class=\"keyword\">throws</span> RemoteException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mRemote.transact(START_SERVICE_TRANSACTION, data, reply, <span class=\"number\">0</span>);</span><br><span class=\"line\">        reply.readException();</span><br><span class=\"line\">        ComponentName res = ComponentName.readFromParcel(reply);</span><br><span class=\"line\">        data.recycle();</span><br><span class=\"line\">        reply.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>ActivityManagerProxy</code> 里面将客户端的请求通过 <code>mRemote.transact</code>  进行转发，<code>mRemote</code> 对象正是 <code>Binder</code> 驱动返回来的 <strong>Binder 服务端的 Proxy</strong> 对象，通过 这个<code>Binder Proxy</code>，<code>Binder</code> 驱动最终将调用处于 <code>Binder Server</code> 端 <code>ActivityManagerNative</code> 中的 <code>onTransact</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTransact</span><span class=\"params\">(<span class=\"keyword\">int</span> code, Parcel data, Parcel reply, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据方法调用号 code 决定调用哪个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (code) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 startActivity 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class=\"line\">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class=\"line\">        reply.writeNoException();</span><br><span class=\"line\">        reply.writeInt(result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> START_SERVICE_TRANSACTION: &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);</span><br><span class=\"line\">            reply.writeNoException();</span><br><span class=\"line\">            ComponentName.writeToParcel(cn, reply);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-8-ActivityManagerService-startActivity\"><a href=\"#1-1-8-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"1.1.8 ActivityManagerService.startActivity\"></a>1.1.8 ActivityManagerService.startActivity</h3><p><code>ActivityManagerNative</code> 是一个抽象类，它的 <code>startActivity</code> 为抽象方法，具体的实现在 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityManagerService.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</a> 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class=\"line\">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class=\"line\">            UserHandle.getCallingUserId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-小结\"><a href=\"#1-2-小结\" class=\"headerlink\" title=\"1.2 小结\"></a>1.2 小结</h2><p>你应该可以发现，相对于 <code>AIDL</code> 的调用过程，调用方 <code>Launcher App</code> 相当于 AIDL 过程中的 <code>Clinent</code>端；AMS 相当于远程 Service 的角色，充当 Server 端角色，他们的调用过程总体上都是一样的。<br>从 Launcher App 到 AMS 的时序图如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u54pqf70j30sk0gqabi.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"2-AMS-——-zygote\"><a href=\"#2-AMS-——-zygote\" class=\"headerlink\" title=\"2. AMS —— zygote\"></a>2. AMS —— zygote</h1><h2 id=\"2-1-调用过程分析\"><a href=\"#2-1-调用过程分析\" class=\"headerlink\" title=\"2.1 调用过程分析\"></a>2.1 调用过程分析</h2><h3 id=\"2-1-1-ActivityManagerService-startActivityAsUser\"><a href=\"#2-1-1-ActivityManagerService-startActivityAsUser\" class=\"headerlink\" title=\"2.1.1 ActivityManagerService.startActivityAsUser\"></a>2.1.1 ActivityManagerService.startActivityAsUser</h3><p>接着从 <code>AMS</code> 的 <code>startActivityAsUser</code> 方法开始分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class=\"keyword\">int</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</span><br><span class=\"line\">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class=\"line\">                userId, <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 ActivityStarter 的 startActivityMayWait 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</span><br><span class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, bOptions, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2-ActivityStarter-startActivityMayWait\"><a href=\"#2-1-2-ActivityStarter-startActivityMayWait\" class=\"headerlink\" title=\"2.1.2 ActivityStarter.startActivityMayWait\"></a>2.1.2 ActivityStarter.startActivityMayWait</h3><p>继续跟进 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStarter.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">(IApplicationThread caller, <span class=\"keyword\">int</span> callingUid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> startFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Bundle bOptions, <span class=\"keyword\">boolean</span> ignoreTargetSecurity, <span class=\"keyword\">int</span> userId,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IActivityContainer iContainer, TaskRecord inTask)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (mService) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 startActivityLocked 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class=\"line\">                aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class=\"line\">                resultTo, resultWho, requestCode, callingPid,</span><br><span class=\"line\">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class=\"line\">                options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class=\"line\">                inTask);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3-ActivityStarter-startActivityLocked\"><a href=\"#2-1-3-ActivityStarter-startActivityLocked\" class=\"headerlink\" title=\"2.1.3 ActivityStarter.startActivityLocked\"></a>2.1.3 ActivityStarter.startActivityLocked</h3><p>查看 <code>startActivityLocked</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> callingPid, <span class=\"keyword\">int</span> callingUid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, <span class=\"keyword\">int</span> realCallingPid, <span class=\"keyword\">int</span> realCallingUid, <span class=\"keyword\">int</span> startFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ActivityOptions options, <span class=\"keyword\">boolean</span> ignoreTargetSecurity, <span class=\"keyword\">boolean</span> componentSpecified,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        TaskRecord inTask)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 调用 doPendingActivityLaunchesLocked 方法，传入 false 参数</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-4-ActivityStarter-doPendingActivityLaunchesLocked\"><a href=\"#2-1-4-ActivityStarter-doPendingActivityLaunchesLocked\" class=\"headerlink\" title=\"2.1.4 ActivityStarter.doPendingActivityLaunchesLocked\"></a>2.1.4 ActivityStarter.doPendingActivityLaunchesLocked</h3><p>查看 <code>doPendingActivityLaunchesLocked</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doPendingActivityLaunchesLocked</span><span class=\"params\">(<span class=\"keyword\">boolean</span> doResume)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PendingActivityLaunch pal = mPendingActivityLaunches.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用 startActivityUnchecked 方法</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> result = startActivityUnchecked(pal.r, pal.sourceRecord, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                pal.startFlags, resume, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, </span><br><span class=\"line\">                mSourceRecord, mTargetStack);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            Slog.e(TAG, <span class=\"string\">\"Exception during pending activity launch pal=\"</span> + pal, e);</span><br><span class=\"line\">            pal.sendErrorResult(e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-5-ActivityStarter-startActivityUnchecked\"><a href=\"#2-1-5-ActivityStarter-startActivityUnchecked\" class=\"headerlink\" title=\"2.1.5 ActivityStarter.startActivityUnchecked\"></a>2.1.5 ActivityStarter.startActivityUnchecked</h3><p>查看 <code>startActivityUnchecked</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">(<span class=\"keyword\">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, <span class=\"keyword\">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class=\"line\">    ...  </span><br><span class=\"line\">    <span class=\"comment\">// 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法</span></span><br><span class=\"line\">    mSupervisor.resumeFocusedStackTopActivityLocked();  </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-6-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked\"><a href=\"#2-1-6-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked\" class=\"headerlink\" title=\"2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked\"></a>2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</h3><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">(ActivityStack targetStack, ActivityRecord target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法</span></span><br><span class=\"line\">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-7-ActivityStack-resumeTopActivityUncheckedLocked\"><a href=\"#2-1-7-ActivityStack-resumeTopActivityUncheckedLocked\" class=\"headerlink\" title=\"2.1.7 ActivityStack.resumeTopActivityUncheckedLocked\"></a>2.1.7 ActivityStack.resumeTopActivityUncheckedLocked</h3><p>查看 <code>ActivityStack</code> 的 <code>resumeTopActivityUncheckedLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 resumeTopActivityInnerLocked 方法</span></span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-8-ActivityStack-resumeTopActivityInnerLocked\"><a href=\"#2-1-8-ActivityStack-resumeTopActivityInnerLocked\" class=\"headerlink\" title=\"2.1.8 ActivityStack.resumeTopActivityInnerLocked\"></a>2.1.8 ActivityStack.resumeTopActivityInnerLocked</h3><p>查看 <code>resumeTopActivityInnerLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class=\"string\">\"resumeTopActivityLocked: Restarting \"</span> + next);</span><br><span class=\"line\">        <span class=\"comment\">// 调用 ActivityStackSupervisor 的 startSpecificActivityLocked 方法</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-9-ActivityStackSupervisor-startSpecificActivityLocked\"><a href=\"#2-1-9-ActivityStackSupervisor-startSpecificActivityLocked\" class=\"headerlink\" title=\"2.1.9 ActivityStackSupervisor.startSpecificActivityLocked\"></a>2.1.9 ActivityStackSupervisor.startSpecificActivityLocked</h3><p>回到 <code>ActivityStackSupervisor</code> 的 <code>startSpecificActivityLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">(ActivityRecord r, <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前 Activity 附属的 Application</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">            r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    r.task.stack.setLaunchTime(r);</span><br><span class=\"line\">    <span class=\"comment\">// 如果 Application 已经运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class=\"number\">0</span></span><br><span class=\"line\">                    || !<span class=\"string\">\"android\"</span>.equals(r.info.packageName)) &#123;</span><br><span class=\"line\">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class=\"line\">                        mService.mProcessStats);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            Slog.w(TAG, <span class=\"string\">\"Exception when starting activity \"</span></span><br><span class=\"line\">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 Application 没有运行,调用AMS,启动新进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先，在方法中获取了当前 <code>Activity</code> 附属的 <code>Application</code>，如果已经在运行了，说明这个 App 是已经被启动过了的，这时候调用 <code>realStartActivityLocked</code> 方法就可以进入下一步的流程了，同一个 App 中不同 <code>Activity</code> 的相互启动就是走的这个流程。当 <code>Application</code> 没有运行的时候，就需要调用 <code>AMS</code> 的 <code>startProcessLocked</code> 方法启动一个进程去承载它然后完成后续的工作，顺便铺垫一下，当新进程被启动完成后还会调用回到这个方法，查看 <code>AMS</code> 的 <code>startProcessLocked</code> 方法：</p>\n<h3 id=\"2-1-10-ActivityManagerService-startProcessLocked\"><a href=\"#2-1-10-ActivityManagerService-startProcessLocked\" class=\"headerlink\" title=\"2.1.10 ActivityManagerService.startProcessLocked\"></a>2.1.10 ActivityManagerService.startProcessLocked</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ProcessRecord <span class=\"title\">startProcessLocked</span><span class=\"params\">(String processName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ApplicationInfo info, <span class=\"keyword\">boolean</span> knownToBeDead, <span class=\"keyword\">int</span> intentFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String hostingType, ComponentName hostingName, <span class=\"keyword\">boolean</span> allowWhileBooting,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> isolated, <span class=\"keyword\">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class=\"line\">            hostingName, allowWhileBooting, isolated, <span class=\"number\">0</span> <span class=\"comment\">/* isolatedUid */</span>, keepIfLarge,</span><br><span class=\"line\">            <span class=\"keyword\">null</span> <span class=\"comment\">/* ABI override */</span>, <span class=\"keyword\">null</span> <span class=\"comment\">/* entryPoint */</span>, <span class=\"keyword\">null</span> <span class=\"comment\">/* entryPointArgs */</span>,</span><br><span class=\"line\">            <span class=\"keyword\">null</span> <span class=\"comment\">/* crashHandler */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-11-ActivityManagerService-startProcessLocked\"><a href=\"#2-1-11-ActivityManagerService-startProcessLocked\" class=\"headerlink\" title=\"2.1.11 ActivityManagerService.startProcessLocked\"></a>2.1.11 ActivityManagerService.startProcessLocked</h3><p>调用 <code>startProcessLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ProcessRecord <span class=\"title\">startProcessLocked</span><span class=\"params\">(String processName, ApplicationInfo info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> knownToBeDead, <span class=\"keyword\">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> allowWhileBooting, <span class=\"keyword\">boolean</span> isolated, <span class=\"keyword\">int</span> isolatedUid, <span class=\"keyword\">boolean</span> keepIfLarge,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class=\"line\">    checkTime(startTime, <span class=\"string\">\"startProcess: done starting proc!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (app.pid != <span class=\"number\">0</span>) ? app : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-12-ActivityManagerService-startProcessLocked\"><a href=\"#2-1-12-ActivityManagerService-startProcessLocked\" class=\"headerlink\" title=\"2.1.12 ActivityManagerService.startProcessLocked\"></a>2.1.12 ActivityManagerService.startProcessLocked</h3><p>调用 <code>startProcessLocked</code> 的重载方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startProcessLocked</span><span class=\"params\">(ProcessRecord app, String hostingType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Process 的 start 方法</span></span><br><span class=\"line\">        Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class=\"line\">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class=\"line\">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                app.info.dataDir, entryPointArgs);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-13-Process-start\"><a href=\"#2-1-13-Process-start\" class=\"headerlink\" title=\"2.1.13 Process.start\"></a>2.1.13 Process.start</h3><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/os/Process.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/android/os/Process.java：</a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> debugFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 startViaZygote 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class=\"line\">        Log.e(LOG_TAG,</span><br><span class=\"line\">                <span class=\"string\">\"Starting VM process through Zygote failed\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"string\">\"Starting VM process through Zygote failed\"</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-14-Process-startViaZygote\"><a href=\"#2-1-14-Process-startViaZygote\" class=\"headerlink\" title=\"2.1.14 Process.startViaZygote\"></a>2.1.14 Process.startViaZygote</h3><p>查看 <code>startViaZygote</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ProcessStartResult <span class=\"title\">startViaZygote</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> uid, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> gid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> debugFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String[] extraArgs)</span></span></span><br><span class=\"line\"><span class=\"function\">                                <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Process.class) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 zygoteSendArgsAndGetResult 方法，传入 openZygoteSocketIfNeeded 的返回值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-15-Process-zygoteSendArgsAndGetResult、Process-openZygoteSocketIfNeeded\"><a href=\"#2-1-15-Process-zygoteSendArgsAndGetResult、Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded\"></a>2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded</h3><p>查看 <code>zygoteSendArgsAndGetResult</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ProcessStartResult <span class=\"title\">zygoteSendArgsAndGetResult</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.write(Integer.toString(args.size()));</span><br><span class=\"line\">        writer.newLine();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++) &#123;</span><br><span class=\"line\">            String arg = args.get(i);</span><br><span class=\"line\">            writer.write(arg);</span><br><span class=\"line\">            writer.newLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.flush();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Should there be a timeout on this?</span></span><br><span class=\"line\">        ProcessStartResult result = <span class=\"keyword\">new</span> ProcessStartResult();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待 socket 服务端（即zygote）返回新创建的进程pid;</span></span><br><span class=\"line\">        result.pid = inputStream.readInt();</span><br><span class=\"line\">        result.usingWrapper = inputStream.readBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.pid &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"fork() failed\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">        zygoteState.close();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>zygoteSendArgsAndGetResult</code> 中等待 <code>Socket</code> 服务端，也就是 <code>zygote</code> 进程返回创建新进程的结果，这里 <code>zygoteState</code> 参数是由 <code>openZygoteSocketIfNeeded</code> 方法返回的，<code>openZygoteSocketIfNeeded</code> 方法则负责根据 <code>abi</code> 向 <code>Zygote</code> 进程发起连接请求：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ZygoteState <span class=\"title\">openZygoteSocketIfNeeded</span><span class=\"params\">(String abi)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState == <span class=\"keyword\">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向主zygote发起connect()操作</span></span><br><span class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to primary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> primaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState == <span class=\"keyword\">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作</span></span><br><span class=\"line\">            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to secondary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> secondaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Unsupported zygote ABI: \"</span> + abi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-小结\"><a href=\"#2-2-小结\" class=\"headerlink\" title=\"2.2 小结\"></a>2.2 小结</h2><p>如果是从桌面新启动一个 App 中的 <code>Activity</code>，此时是没有进程去承载这个 App 的，因此需要通过 <code>AMS</code> 向 <code>zygote</code> 继承发起请求去完成这个任务，AMS 运行在 <code>system_server</code> 进程中，它通过 <code>Socket</code> 向 <code>zygote</code> 发起 <code>fock</code> 进程的请求，从 <code>AMS</code> 开始的调用时序图如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u5m53eloj30t50p7tcl.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"3-zygote-——-ActivityThread\"><a href=\"#3-zygote-——-ActivityThread\" class=\"headerlink\" title=\"3. zygote —— ActivityThread\"></a>3. zygote —— ActivityThread</h1><h2 id=\"3-1-调用过程分析\"><a href=\"#3-1-调用过程分析\" class=\"headerlink\" title=\"3.1 调用过程分析\"></a>3.1 调用过程分析</h2><h3 id=\"3-1-1-ZygoteInit-main\"><a href=\"#3-1-1-ZygoteInit-main\" class=\"headerlink\" title=\"3.1.1 ZygoteInit.main\"></a>3.1.1 ZygoteInit.main</h3><p><code>zygote</code> 进程的其中一项任务就是：</p>\n<p>调用 <code>registerZygoteSocket()</code>函数建立 <code>Socket</code> 通道，使 <code>zygote</code> 进程成为 <code>Socket</code> 服务端，并通过<code>runSelectLoop()</code> 函数等待 <code>ActivityManagerService</code> 发送请求创建新的应用程序进程。</p>\n<p><code>zygote</code> 终于要再次上场了！接下来从 <strong>ZygoteInit.java</strong> 的 <code>main</code> 方法开始回顾一下 <code>zygote</code> 进程的工作：</p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/com/android/internal/os/ZygoteInit.java：</a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        runSelectLoop(abiList);</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class=\"line\">        caller.run();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">        closeServerSocket();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-2-ZygoteInit-runSelectLoop\"><a href=\"#3-1-2-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"3.1.2 ZygoteInit.runSelectLoop\"></a>3.1.2 ZygoteInit.runSelectLoop</h3><p>查看 <code>runSelectLoop</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runSelectLoop</span><span class=\"params\">(String abiList)</span> <span class=\"keyword\">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 循环读取状态</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = pollFds.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 读取的状态不是客户端连接或者数据请求时，进入下一次循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// i = 0 表示跟客户端 Socket 连接上了</span></span><br><span class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class=\"line\">                peers.add(newPeer);</span><br><span class=\"line\">                fds.add(newPeer.getFileDesciptor());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// i &gt; 0 表示接收到客户端 Socket 发送过来的请求</span></span><br><span class=\"line\">                <span class=\"comment\">// runOnce 方法创建一个新的应用程序进程</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> done = peers.get(i).runOnce();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">                    peers.remove(i);</span><br><span class=\"line\">                    fds.remove(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-3-ZygoteConnection-runOnce\"><a href=\"#3-1-3-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"3.1.3 ZygoteConnection.runOnce\"></a>3.1.3 ZygoteConnection.runOnce</h3><p>查看 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/com/android/internal/os/</a><br><strong>ZygoteConnection.java</strong> 的 <code>runOnce</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">runOnce</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    String args[];</span><br><span class=\"line\">    Arguments parsedArgs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    FileDescriptor[] descriptors;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取 socket 客户端发送过来的参数列表</span></span><br><span class=\"line\">        args = readArgumentList();</span><br><span class=\"line\">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// EOF reached.</span></span><br><span class=\"line\">        closeSocket();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式</span></span><br><span class=\"line\">        parsedArgs = <span class=\"keyword\">new</span> Arguments(args);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 同样调用 Zygote.java 的 forkAndSpecialize 方法 fock 出子进程</span></span><br><span class=\"line\">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class=\"line\">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class=\"line\">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class=\"line\">                parsedArgs.appDataDir);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 子进程执行</span></span><br><span class=\"line\">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">            serverPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 进入子进程流程</span></span><br><span class=\"line\">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 父进程执行</span></span><br><span class=\"line\">            IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">            childPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-4-ZygoteConnection-handleChildProc\"><a href=\"#3-1-4-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"3.1.4 ZygoteConnection.handleChildProc\"></a>3.1.4 ZygoteConnection.handleChildProc</h3><p>首先解析 <code>Socket</code> 客户端传过来的参数，<code>Zygote.java</code> 的 <code>forkAndSpecialize</code> 返回的 <code>pid == 0</code> 的时候表示此时在 <code>fock</code> 出来的子进程中执行，继续调用 <code>handleChildProc</code> 方法，并将参数继续层层传递：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleChildProc</span><span class=\"params\">(Arguments parsedArgs, FileDescriptor[] </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span> <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*由于 fock 出来的 system_server 进程会复制 zygote 进程的地址空间，因此它也得到了 zygote</span></span><br><span class=\"line\"><span class=\"comment\">    进程中的 Socket，这个 Socket 对它来说并无用处，这里将其关闭 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    closeSocket();</span><br><span class=\"line\">    ZygoteInit.closeServerSocket();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsedArgs.niceName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置进程名</span></span><br><span class=\"line\">        Process.setArgV0(parsedArgs.niceName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsedArgs.invokeWith != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 RuntimeInit 的 zygoteInit 方法</span></span><br><span class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class=\"line\">                parsedArgs.remainingArgs, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-5-RuntimeInit-zygoteInit\"><a href=\"#3-1-5-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"3.1.5 RuntimeInit.zygoteInit\"></a>3.1.5 RuntimeInit.zygoteInit</h3><p>查看 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/com/android/internal/os/RuntimeInit.java </a>的 <code>zygoteInit</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">zygoteInit</span><span class=\"params\">(<span class=\"keyword\">int</span> targetSdkVersion, String[] argv, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ClassLoader classLoader)</span> <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Slog.d(TAG, <span class=\"string\">\"RuntimeInit: Starting application from zygote\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">\"RuntimeInit\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 重定向 log 输出</span></span><br><span class=\"line\">    redirectLogStreams();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化一些通用的设置</span></span><br><span class=\"line\">    commonInit(); </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 的 </span></span><br><span class=\"line\"><span class=\"comment\">     *onZygoteInit 方法启动 Binder 线程池， 使 system_server 进程可以使用 Binder  *与其他进程通信</span></span><br><span class=\"line\"><span class=\"comment\">     **/</span></span><br><span class=\"line\">    nativeZygoteInit(); </span><br><span class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-6-RuntimeInit-applicationInit\"><a href=\"#3-1-6-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"3.1.6 RuntimeInit.applicationInit\"></a>3.1.6 RuntimeInit.applicationInit</h3><p>继续调用 <code>applicationInit</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">applicationInit</span><span class=\"params\">(<span class=\"keyword\">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 提取出参数里面的要启动的类的名字</span></span><br><span class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-7-RuntimeInit-invokeStaticMain\"><a href=\"#3-1-7-RuntimeInit-invokeStaticMain\" class=\"headerlink\" title=\"3.1.7 RuntimeInit.invokeStaticMain\"></a>3.1.7 RuntimeInit.invokeStaticMain</h3><p>主要调用了 <code>invokeStaticMain</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeStaticMain</span><span class=\"params\">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; cl;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/** className 为通过 Socket 客户端（AMS）传递过来的一系列参数中的其中一个，这里获取到的值为传\"com.android.app.ActivityThread\"，然后通过反射得到 ActivityThread 类 **/</span></span><br><span class=\"line\">        cl = Class.forName(className, <span class=\"keyword\">true</span>, classLoader);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Missing class when invoking static main \"</span> + className, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Method m;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找到 ActivityThread 类的 main 方法</span></span><br><span class=\"line\">        m = cl.getMethod(<span class=\"string\">\"main\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String[].class &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Missing static main on \"</span> + className, ex);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Problem getting static main on \"</span> + className, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> modifiers = m.getModifiers();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Main method is not public and static on \"</span> + className);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出</span></span><br><span class=\"line\"><span class=\"comment\">    捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-8-MethodAndArgsCaller-run\"><a href=\"#3-1-8-MethodAndArgsCaller-run\" class=\"headerlink\" title=\"3.1.8 MethodAndArgsCaller.run\"></a>3.1.8 MethodAndArgsCaller.run</h3><p>回到 <code>ZygoteInit</code> 的 <code>main</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    closeServerSocket();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 接收到 caller 对象后调用它的 run 方法</span></span><br><span class=\"line\">        caller.run();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"Zygote died with exception\"</span>, ex);</span><br><span class=\"line\">        closeServerSocket();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟 <code>system_server</code> 进程的启动过程一样，这里同样通过抛出异常的方式来清空调用 <code>ActivityThread.main</code>之前的方法栈帧。<br><code>ZygoteInit</code> 的 <code>MethodAndArgsCaller</code> 类是一个 <code>Exception</code> 类，同时也实现了 <code>Runnable</code> 接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodAndArgsCaller</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method mMethod;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String[] mArgs;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MethodAndArgsCaller</span><span class=\"params\">(Method method, String[] args)</span> </span>&#123;</span><br><span class=\"line\">        mMethod = method;</span><br><span class=\"line\">        mArgs = args;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用传递过来的 mMethod</span></span><br><span class=\"line\">            mMethod.invoke(<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[] &#123; mArgs &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(ex);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException ex) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-9-ActivityThread-main\"><a href=\"#3-1-9-ActivityThread-main\" class=\"headerlink\" title=\"3.1.9 ActivityThread .main\"></a>3.1.9 ActivityThread .main</h3><p>最后通过反射调用到 <code>ActivityThread</code> 的 <code>main</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Environment.initForCurrentUser();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Process.setArgV0(<span class=\"string\">\"&lt;pre-initialized&gt;\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建主线程 Looper</span></span><br><span class=\"line\">    Looper.prepareMainLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">    ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</span><br><span class=\"line\">    <span class=\"comment\">// attach 到系统进程</span></span><br><span class=\"line\">    thread.attach(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        sMainThreadHandler = thread.getHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程进入轮询状态</span></span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 抛出异常说明轮询出现问题</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-2-小结\"><a href=\"#3-2-小结\" class=\"headerlink\" title=\"3.2 小结\"></a>3.2 小结</h2><p><code>zygote</code> 进程作为 <code>Socket</code> 服务端在接收到作为客户端的 <code>AMS</code> 发送过来的请求和参数之后，<code>fock</code> 出新的进程并根据各种参数进程了初始化的工作，这个过程和 <code>zygote</code> 启动 <code>system_server</code> 进程的过程如出一辙，时序图如下所示：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u80ukv7ej30q30ivmzb.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<h1 id=\"4-ActivityThread-——-Activity\"><a href=\"#4-ActivityThread-——-Activity\" class=\"headerlink\" title=\"4. ActivityThread —— Activity\"></a>4. ActivityThread —— Activity</h1><p>##4.1 调用过程分析</p>\n<h3 id=\"4-1-1-ActivityThread-attach\"><a href=\"#4-1-1-ActivityThread-attach\" class=\"headerlink\" title=\"4.1.1 ActivityThread.attach\"></a>4.1.1 ActivityThread.attach</h3><p>上一小节的最后，<code>ActivityThread</code> 的 <code>main</code> 通过反射被运行起来了，接着会调用 <code>ActivityThread</code> 的 <code>attach</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(<span class=\"keyword\">boolean</span> system)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mSystemThread = system;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!system) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 获取 ActivityManagerProxy 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过 Binder 调用 AMS 的 attachApplication 方法</span></span><br><span class=\"line\">            mgr.attachApplication(mAppThread);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，我们再一次通过 <code>Binder IPC</code> 机制跟 <code>AMS</code> 通信，通信模型跟前面<code>Launcher App</code>调用 <code>AMS</code> 的 <code>startActivity</code> 方法一样，getDefault 过程不重复分析，这次是调用了 <code>AMS</code> 的 <code>attachApplication</code> 方法，注意这里将 <code>ApplicationThead</code> 类型的 <code>mAppThread</code> 对象作为参数传递了过去，<code>ApplicationThead</code> 是 <code>ActivityThread</code> 的一个内部类，后面我们会讲到，先查看 <code>AMP</code> 的 <code>attachApplication</code> 方法：</p>\n<h3 id=\"4-1-2-ActivityManagerProxy-attachApplication\"><a href=\"#4-1-2-ActivityManagerProxy-attachApplication\" class=\"headerlink\" title=\"4.1.2 ActivityManagerProxy.attachApplication\"></a>4.1.2 ActivityManagerProxy.attachApplication</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attachApplication</span><span class=\"params\">(IApplicationThread app)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 调用 asBinder 方法使其能够跨进程传输</span></span><br><span class=\"line\">    data.writeStrongBinder(app.asBinder());</span><br><span class=\"line\">    <span class=\"comment\">// 通过 transact 方法将数据交给 Binder 驱动</span></span><br><span class=\"line\">    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, <span class=\"number\">0</span>); </span><br><span class=\"line\">    reply.readException();</span><br><span class=\"line\">    data.recycle();</span><br><span class=\"line\">    reply.recycle();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-3-ActivityManagerNative-onTransact\"><a href=\"#4-1-3-ActivityManagerNative-onTransact\" class=\"headerlink\" title=\"4.1.3 ActivityManagerNative.onTransact\"></a>4.1.3 ActivityManagerNative.onTransact</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTransact</span><span class=\"params\">(<span class=\"keyword\">int</span> code, Parcel data, Parcel reply, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (code) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ATTACH_APPLICATION_TRANSACTION: &#123;</span><br><span class=\"line\">            data.enforceInterface(IActivityManager.descriptor);</span><br><span class=\"line\">            <span class=\"comment\">// 获取 ApplicationThread 的代理对象，这里返回的是 ApplicationThreadNative(ATN)</span></span><br><span class=\"line\">            <span class=\"comment\">// 的内部类：ApplicationThreadProxy(ATP) 对象</span></span><br><span class=\"line\">            IApplicationThread app = ApplicationThreadNative.asInterface(data.readStrongBinder());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 委托给 AMS 执行</span></span><br><span class=\"line\">                attachApplication(app);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            reply.writeNoException();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>asInterface</code> 将 <code>ActivityThread</code> 对象<strong>转换</strong>成了 <code>ApplicationThreadNative</code> 的 <code>Binder</code> 代理对象 <code>ApplicationThreadProxy</code>，并作为参数传给 <code>attachApplication</code> 方法，其中 <code>ApplicationThreadProxy</code> 是 <code>ApplicationThreadNative</code> 的<strong>内部类</strong>。</p>\n<h3 id=\"4-1-4-ActivityManagerService-attachApplication\"><a href=\"#4-1-4-ActivityManagerService-attachApplication\" class=\"headerlink\" title=\"4.1.4 ActivityManagerService.attachApplication\"></a>4.1.4 ActivityManagerService.attachApplication</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attachApplication</span><span class=\"params\">(IApplicationThread thread)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> callingPid = Binder.getCallingPid();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> origId = Binder.clearCallingIdentity();</span><br><span class=\"line\">        attachApplicationLocked(thread, callingPid);</span><br><span class=\"line\">        Binder.restoreCallingIdentity(origId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-5-ActivityManagerService-attachApplicationLocked\"><a href=\"#4-1-5-ActivityManagerService-attachApplicationLocked\" class=\"headerlink\" title=\"4.1.5 ActivityManagerService.attachApplicationLocked\"></a>4.1.5 ActivityManagerService.attachApplicationLocked</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(IApplicationThread thread, <span class=\"keyword\">int</span> pid)</span> </span>&#123;</span><br><span class=\"line\">    ProcessRecord app;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 绑定死亡通知</span></span><br><span class=\"line\">        AppDeathRecipient adr = <span class=\"keyword\">new</span> AppDeathRecipient(app, pid, thread);</span><br><span class=\"line\">        thread.asBinder().linkToDeath(adr, <span class=\"number\">0</span>);</span><br><span class=\"line\">        app.deathRecipient = adr;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        app.resetPackageList(mProcessStats);</span><br><span class=\"line\">        <span class=\"comment\">// 如果 system_server 进程死亡则重新启动进程</span></span><br><span class=\"line\">        startProcessLocked(app, <span class=\"string\">\"link fail\"</span>, processName); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 获取应用appInfo</span></span><br><span class=\"line\">        ApplicationInfo appInfo = app.instrumentationInfo != <span class=\"keyword\">null</span></span><br><span class=\"line\">                ? app.instrumentationInfo : app.info;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 绑定应用</span></span><br><span class=\"line\">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class=\"line\">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class=\"line\">                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</span><br><span class=\"line\">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Configuration(mConfiguration), app.compat,</span><br><span class=\"line\">                getCommonServicesLocked(app.isolated),</span><br><span class=\"line\">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        app.resetPackageList(mProcessStats);</span><br><span class=\"line\">        app.unlinkDeathRecipient();</span><br><span class=\"line\">        <span class=\"comment\">// bindApplication 失败也要重启进程</span></span><br><span class=\"line\">        startProcessLocked(app, <span class=\"string\">\"bind fail\"</span>, processName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 Activity: 检查最顶层可见的Activity是否等待在该进程中运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (normalMode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class=\"line\">                didSomething = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 Service: 寻找所有需要在该进程中运行的服务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!badApp) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果是 BroadcastReceiver: 检查是否在这个进程中有下一个广播接收者</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否在这个进程中有下一个 backup 代理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!badApp &amp;&amp; mBackupTarget != <span class=\"keyword\">null</span> &amp;&amp; mBackupTarget.appInfo.uid == app.uid) &#123;</span><br><span class=\"line\">        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class=\"line\">                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class=\"line\">                    mBackupTarget.backupMode);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (badApp) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 杀掉 badApp</span></span><br><span class=\"line\">        app.kill(<span class=\"string\">\"error during init\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        handleAppDiedLocked(app, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!didSomething) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新 adj(组件的权值)</span></span><br><span class=\"line\">        updateOomAdjLocked(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，通过 <code>ApplicationThreadProxy</code> 使用 <code>Binder</code> 向 <code>ApplicationThreadProxy</code> 发起 <code>bindApplication</code> 请求，然后通过 <code>normalMode</code> 字段判断是否为 <code>Activity</code>，如果是则执行 <code>ActivityStackSupervisor</code> 的 <code>attachApplicationLocked</code> 方法。</p>\n<h4 id=\"4-1-5-1-ActivityThread-java-ApplicationThread-bindApplication\"><a href=\"#4-1-5-1-ActivityThread-java-ApplicationThread-bindApplication\" class=\"headerlink\" title=\"4.1.5.1 ActivityThread.java::ApplicationThread.bindApplication\"></a>4.1.5.1 ActivityThread.java::ApplicationThread.bindApplication</h4><p><code>thread</code> 对象类型是 <code>ApplicationThreadProxy</code>，通过 <code>Binder</code> 驱动调到了 <code>ApplicationThreadNative</code> 的方法，<code>ApplicationThreadNative</code> 是一个抽象类，它的实现都委托给了 <code>ApplicationThread</code>(这跟 AMS 跟 AMN 的关系一样)，ApplicationThread 作为 ActivityThread 的内部类存在，它的 binderApplication 方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActivityThread.java::ApplicationThread：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bindApplication</span><span class=\"params\">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    IUiAutomationConnection instrumentationUiConnection, <span class=\"keyword\">int</span> debugMode, <span class=\"keyword\">boolean</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    enableOpenGlTrace, <span class=\"keyword\">boolean</span> isRestrictedBackupMode, <span class=\"keyword\">boolean</span> persistent, Configuration</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (services != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将services缓存起来, 减少binder检索服务的次数</span></span><br><span class=\"line\">        ServiceManager.initServiceCache(services);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 发送消息 H.BIND_APPLICATION 给 Handler 对象</span></span><br><span class=\"line\">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>H</strong> 是 <strong>ActivityThread</strong> 中的一个 <strong>Handler</strong> 对象，用于处理发送过来的各种消息：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BIND_APPLICATION        = <span class=\"number\">110</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> BIND_APPLICATION:</span><br><span class=\"line\">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">\"bindApplication\"</span>);</span><br><span class=\"line\">            AppBindData data = (AppBindData)msg.obj;</span><br><span class=\"line\">            handleBindApplication(data);</span><br><span class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了 <code>handleBindApplication</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void handleBindApplication(AppBindData data) &#123;</span><br><span class=\"line\">    // 获取 LoadedApk 对象</span><br><span class=\"line\">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // 创建 ContextImpl 上下文</span><br><span class=\"line\">    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // 创建 Instrumentation 对象</span><br><span class=\"line\">    if (data.instrumentationName != null) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        mInstrumentation = new Instrumentation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 调用 LoadedApk 的 makeApplication 方法创建 Application</span><br><span class=\"line\">        Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class=\"line\">        mInitialApplication = app;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class=\"line\">        // 调用 Application.onCreate 方法</span><br><span class=\"line\">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        StrictMode.setThreadPolicy(savedPolicy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-1-5-2-ActivityStackSupervisor-attachApplicationLocked\"><a href=\"#4-1-5-2-ActivityStackSupervisor-attachApplicationLocked\" class=\"headerlink\" title=\"4.1.5.2 ActivityStackSupervisor.attachApplicationLocked\"></a>4.1.5.2 ActivityStackSupervisor.attachApplicationLocked</h4><p>在 <strong>4.1.4</strong> 小节中通过 <strong>Binder</strong> 向 <strong>ActivityThread</strong> 发起 <code>bindApplication</code> 请求后，会根据启动组件的类型去做相应的处理，如果是 <code>Acitivity</code>，则会调用 <strong>ActivityStackSupervisor</strong> 的 <code>attachApplicationLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(ProcessRecord app)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String processName = app.processName;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> displayNdx = mActivityDisplays.size() - <span class=\"number\">1</span>; displayNdx &gt;= <span class=\"number\">0</span>; --displayNdx) &#123;</span><br><span class=\"line\">        ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> stackNdx = stacks.size() - <span class=\"number\">1</span>; stackNdx &gt;= <span class=\"number\">0</span>; --stackNdx) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ActivityStack stack = stacks.get(stackNdx);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isFrontStack(stack)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 获取前台stack中栈顶第一个非 finishing 状态的 Activity</span></span><br><span class=\"line\">            ActivityRecord hr = stack.topRunningActivityLocked(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hr.app == <span class=\"keyword\">null</span> &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 真正的启动 Activity</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (realStartActivityLocked(hr, app, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">                            didSomething = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> didSomething;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">##### 4.1.5.2.1 ActivityStackSupervisor.realStartActivityLocked</span><br><span class=\"line\"></span><br><span class=\"line\">前面 **<span class=\"number\">2.1</span>.8ActivityStackSupervisor.startSpecificActivityLocked**  小节中分析过，如果当前 `Activity` 依附的 `Application` 已经被启动，则调用 `realStartActivityLocked` 方法，否则创建新的进程，再创建新的进程之后，两个流程的在这里合并起来了：</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">(ActivityRecord r, ProcessRecord app, <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = task.stack;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class=\"line\">        <span class=\"comment\">// 通过 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法</span></span><br><span class=\"line\">        app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</span><br><span class=\"line\">                System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class=\"line\">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class=\"line\">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.launchFailed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第二次启动失败，则结束该 Activity</span></span><br><span class=\"line\">            mService.appDiedLocked(app);</span><br><span class=\"line\">            stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 第一个启动失败，则重启进程</span></span><br><span class=\"line\">        app.activities.remove(r);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">这里有一次使用 `Binder` 调用 `ApplicationThread` 的 `scheduleLaunchActivity` 方法。</span><br><span class=\"line\"></span><br><span class=\"line\">##### 4.1.5.2.2 ApplicationThread.scheduleLaunchActivity</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">(Intent intent, IBinder token, <span class=\"keyword\">int</span> ident, ActivityInfo </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        compatInfo, String referrer, IVoiceInteractor voiceInteractor, <span class=\"keyword\">int</span> procState, Bundle </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        List&lt;ReferrerIntent&gt; pendingNewIntents, <span class=\"keyword\">boolean</span> notResumed, <span class=\"keyword\">boolean</span> isForward, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    updateProcessState(procState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面提到过，<strong>H</strong> 是 <strong>ActivityThread</strong> 中一个 <strong>Handler</strong> 类，它接收到 <code>LAUNCH_ACTIVITY</code> 消息后会调用 <code>handleLaunchActivity</code> 方法。</p>\n<h5 id=\"4-1-5-2-3-ActivityThread-handleLaunchActivity\"><a href=\"#4-1-5-2-3-ActivityThread-handleLaunchActivity\" class=\"headerlink\" title=\"4.1.5.2.3 ActivityThread.handleLaunchActivity\"></a>4.1.5.2.3 ActivityThread.handleLaunchActivity</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 WMS</span></span><br><span class=\"line\">    WindowManagerGlobal.initialize();</span><br><span class=\"line\">    <span class=\"comment\">// 执行 performLaunchActivity 方法</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        r.createdConfig = <span class=\"keyword\">new</span> Configuration(mConfiguration);</span><br><span class=\"line\">        Bundle oldState = r.state;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class=\"line\">            r.activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            mInstrumentation.callActivityOnPause(r.activity);</span><br><span class=\"line\">            r.paused = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 停止该 Activity</span></span><br><span class=\"line\">        ActivityManagerNative.getDefault()</span><br><span class=\"line\">            .finishActivity(r.token, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-1-4-2-4-ApplicationThread-performLaunchActivity\"><a href=\"#4-1-4-2-4-ApplicationThread-performLaunchActivity\" class=\"headerlink\" title=\"4.1.4.2.4 ApplicationThread.performLaunchActivity\"></a>4.1.4.2.4 ApplicationThread.performLaunchActivity</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// Instrumentation 中使用反射创建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 对象并调用 Application 的 onCreate 方法</span></span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"comment\">// attach 到 Window 上</span></span><br><span class=\"line\">            activity.attach(appContext, <span class=\"keyword\">this</span>, getInstrumentation(), r.token,</span><br><span class=\"line\">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class=\"line\">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class=\"line\">                    r.referrer, r.voiceInteractor);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (customIntent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                activity.mIntent = customIntent;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.lastNonConfigurationInstances = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            activity.mStartedActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置主题</span></span><br><span class=\"line\">                activity.setTheme(theme);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重新创建的 Activity</span></span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第一次创建的 Activity</span></span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;  <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-1-5-2-5-Instrumentation-callActivityOnCreate\"><a href=\"#4-1-5-2-5-Instrumentation-callActivityOnCreate\" class=\"headerlink\" title=\"4.1.5.2.5 Instrumentation.callActivityOnCreate\"></a>4.1.5.2.5 Instrumentation.callActivityOnCreate</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PersistableBundle persistentState)</span> </span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Activity 的 performCreate 方法</span></span><br><span class=\"line\">    activity.performCreate(icicle, persistentState);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-1-5-2-6-Activity-performCreate\"><a href=\"#4-1-5-2-6-Activity-performCreate\" class=\"headerlink\" title=\"4.1.5.2.6 Activity.performCreate\"></a>4.1.5.2.6 Activity.performCreate</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class=\"line\">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    onCreate(icicle, persistentState);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>终于，onCreate 方法被调用了！！！</p>\n<h2 id=\"4-2-小结\"><a href=\"#4-2-小结\" class=\"headerlink\" title=\"4.2 小结\"></a>4.2 小结</h2><p>从 <code>ActivityThread</code> 到最终 <code>Activity</code> 被创建及生命周期被调用，核心过程涉及到了三次<strong> Binder IPC</strong> 过程，分别是：</p>\n<pre><code>1. ActivityThread 调用 AMS 的 attachApplication 方法\n\n2. AMS 调用 ApplicationThread 的 bindApplication 方法\n\n3. ActivityStackSupervisor 调用 Application 的 attachApplicationLocked 方法\n</code></pre><p>整个过程的时序图如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u8r1k48wj30t30qo43w.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<ol start=\"5\">\n<li>总结<br>纵观整个过程，从 Launcher 到 AMS、从 AMS 再到 Zygote、再从 Zygote 到 ActivityThread，最后在 ActivitThread 中层层调用到 Activity 的生命周期方法，中间涉及到了无数的细节，但总体上脉络还是非常清晰的，各个 Android 版本的 Framework 层代码可以某些过程的实现不太一样，但是整个调用流程大体上也是相同的，借用 <a href=\"http://gityuan.com/android/\" target=\"_blank\" rel=\"noopener\">Gityuan</a> 大神的一张图作为结尾：</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u8shvqsuj30qo0k0gt0.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-App-Activity-启动流程分析\"><a href=\"#Android-App-Activity-启动流程分析\" class=\"headerlink\" title=\"Android App/Activity 启动流程分析\"></a>Android App/Activity 启动流程分析</h1><p>首先我们带着问题来看:</p>\n<ol>\n<li>点击了图标之后系统道理做了哪些工作呢？</li>\n<li>应用进程是怎么被启动的呢？</li>\n<li>Activity 的生命周期是什么时候被谁调用的呢？</li>\n</ol>\n<p>本文将继续基于 <strong>Android Nougat</strong> 的 Frameworks 层源码的解答这些问题。</p>\n<p>阅读建议：<br>如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。</p>\n<h2 id=\"1-1-调用过程分析\"><a href=\"#1-1-调用过程分析\" class=\"headerlink\" title=\"1.1 调用过程分析\"></a>1.1 调用过程分析</h2><h3 id=\"1-1-1-Launcher-onClick\"><a href=\"#1-1-1-Launcher-onClick\" class=\"headerlink\" title=\"1.1.1 Launcher.onClick\"></a>1.1.1 Launcher.onClick</h3><p>在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 <code>onClick</code> 方法，<br><a href=\"https://android.googlesource.com/platform/packages/apps/Launcher3/+/nougat-release/src/com/android/launcher3/Launcher.java?autodive=0%2F\" target=\"_blank\" rel=\"noopener\">packages/apps/Launcher3/src/com/android/launcher3/Launcher.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Object tag = v.getTag();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> ShortcutInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从快捷方式图标启动</span></span><br><span class=\"line\">        onClickAppShortcut(v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> FolderInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 文件夹</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v <span class=\"keyword\">instanceof</span> FolderIcon) &#123;</span><br><span class=\"line\">           onClickFolderIcon(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (v == mAllAppsButton) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// “所有应用”按钮</span></span><br><span class=\"line\">        onClickAllAppsButton(v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> AppInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从“所有应用”中启动的应用</span></span><br><span class=\"line\">        startAppShortcutOrInfoActivity(v);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> LauncherAppWidgetInfo) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 组件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v <span class=\"keyword\">instanceof</span> PendingAppWidgetHostView) &#123;</span><br><span class=\"line\">            onClickPendingWidget((PendingAppWidgetHostView) v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-2-Launcher-onClickAppShortcut\"><a href=\"#1-1-2-Launcher-onClickAppShortcut\" class=\"headerlink\" title=\"1.1.2 Launcher.onClickAppShortcut\"></a>1.1.2 Launcher.onClickAppShortcut</h3><p>如果是快捷方式图标，则调用 <code>onClickAppShortcut</code> 方法进而调用 <code>startAppShortcutOrInfoActivity</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Thunk</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startAppShortcutOrInfoActivity</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    Object tag = v.getTag();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ShortcutInfo shortcut;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Intent intent;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> ShortcutInfo) &#123;</span><br><span class=\"line\">        shortcut = (ShortcutInfo) tag;</span><br><span class=\"line\">        <span class=\"comment\">// 去除对应的 Intent 对象</span></span><br><span class=\"line\">        intent = shortcut.intent;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] pos = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        v.getLocationOnScreen(pos);</span><br><span class=\"line\">        intent.setSourceBounds(<span class=\"keyword\">new</span> Rect(pos[<span class=\"number\">0</span>], pos[<span class=\"number\">1</span>],</span><br><span class=\"line\">                pos[<span class=\"number\">0</span>] + v.getWidth(), pos[<span class=\"number\">1</span>] + v.getHeight()));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tag <span class=\"keyword\">instanceof</span> AppInfo) &#123;</span><br><span class=\"line\">        shortcut = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        intent = ((AppInfo) tag).intent;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Input must be a Shortcut or AppInfo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 startActivitySafely 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> success = startActivitySafely(v, intent, tag);</span><br><span class=\"line\">    mStats.recordLaunch(v, intent, shortcut);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success &amp;&amp; v <span class=\"keyword\">instanceof</span> BubbleTextView) &#123;</span><br><span class=\"line\">        mWaitingForResume = (BubbleTextView) v;</span><br><span class=\"line\">        mWaitingForResume.setStayPressed(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-3-Launcher-startActivity\"><a href=\"#1-1-3-Launcher-startActivity\" class=\"headerlink\" title=\"1.1.3 Launcher.startActivity\"></a>1.1.3 Launcher.startActivity</h3><p>获取相应 App 的 <strong>Intent</strong> 信息之后，调用 <code>startActivity</code> 方法：<br>并设置Flags为<strong>Intent.FLAG_ACTIVITY_NEW_TASK</strong>,启动新的任务栈</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startActivity</span><span class=\"params\">(View v, Intent intent, Object tag)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动新的任务栈</span></span><br><span class=\"line\">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span> || user.equals(UserHandleCompat.myUserHandle())) &#123;</span><br><span class=\"line\">            StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;            </span><br><span class=\"line\">                StrictMode.setVmPolicy(<span class=\"keyword\">new</span> StrictMode.VmPolicy.Builder().detectAll()</span><br><span class=\"line\">                        .penaltyLog().build());</span><br><span class=\"line\">                <span class=\"comment\">// 调用 Activity 的 startActivity 方法</span></span><br><span class=\"line\">                startActivity(intent, optsBundle);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                StrictMode.setVmPolicy(oldPolicy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            launcherApps.startActivityForProfile(intent.getComponent(), user,</span><br><span class=\"line\">                    intent.getSourceBounds(), optsBundle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;      </span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1.1.4 Activity.startActivity<br>这里最终调用了 <code>Activity</code> 中的 <code>startActivity</code> 方法，并且设置 Flag 为 <strong>FLAG_ACTIVITY_NEW_TASK</strong>。到此为止，已经跟启动普通的 <code>Activity</code> 流程汇合起来了，继续往下分析。<br><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Activity.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/android/app/Activity.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第二个参数为 -1 表示不需要回调 onActivityResult 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Note we want to go through this call for compatibility with</span></span><br><span class=\"line\">        <span class=\"comment\">// applications that may have overridden the method.</span></span><br><span class=\"line\">        startActivityForResult(intent, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-5-Activity-startActivityForResult\"><a href=\"#1-1-5-Activity-startActivityForResult\" class=\"headerlink\" title=\"1.1.5 Activity.startActivityForResult\"></a>1.1.5 Activity.startActivityForResult</h3><p>调用 <code>Activity</code> 的 <code>startActivityForResult</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(@RequiresPermission Intent intent, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @Nullable Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// mParent 是当前 Activity 的父类，此时条件成立</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Instrumentation 的 execStartActivity 方法</span></span><br><span class=\"line\">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(<span class=\"keyword\">this</span>,</span><br><span class=\"line\">               mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>, intent, requestCode, options);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-6-Instrumentation-execStartActivity\"><a href=\"#1-1-6-Instrumentation-execStartActivity\" class=\"headerlink\" title=\"1.1.6 Instrumentation.execStartActivity\"></a>1.1.6 Instrumentation.execStartActivity</h3><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/Instrumentation.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/android/app/Instrumentation.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ActivityResult <span class=\"title\">execStartActivity</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, <span class=\"keyword\">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        intent.migrateExtraStreamToClipData();</span><br><span class=\"line\">        intent.prepareToLeaveProcess(who);</span><br><span class=\"line\">        <span class=\"comment\">// 获取 AMS 的代理对象并调用其 startActivity 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = ActivityManagerNative.getDefault()</span><br><span class=\"line\">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class=\"line\">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class=\"line\">                    token, target != <span class=\"keyword\">null</span> ? target.mEmbeddedID : <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                    requestCode, <span class=\"number\">0</span>, <span class=\"keyword\">null</span>, options);</span><br><span class=\"line\">        checkStartActivityResult(result, intent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Failure from system\"</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-7-ActivityManagerProxy-startActivity\"><a href=\"#1-1-7-ActivityManagerProxy-startActivity\" class=\"headerlink\" title=\"1.1.7 ActivityManagerProxy.startActivity\"></a>1.1.7 ActivityManagerProxy.startActivity</h3><p>以上过程是在 <code>Launcher App</code>所在的进程中发生的，<strong>由于远程 </strong><code>AMS(ActivityManagerService)</code>跟使用 <code>Service</code> 的 <code>Activity</code> <strong>不在同一个进程中</strong>，因此他们之间交互需要通过 <strong>Binder IPC 机制</strong>的支持，在这个过程中<code>Client</code> 首先获取到 <code>Server</code> 端的代理对象，在 <code>Client</code> 看来 <code>ActivityManagerProxy</code> 对象同样具有 <code>ActivityManagerService</code> 本地对象承诺的能力，因此 <code>Client</code> 可以调用 <code>ActivityManagerProxy</code> 跟 <code>ActivityManagerService</code> 对象进行数据交互，<strong><code>Binder</code> 驱动</strong>作为桥梁在他们中间起到中间人的作用。<br>同样，<code>AMS</code> 是运行在 <code>system_server</code> 线程中的，这时 <code>AMS</code> 就相当于 AIDL 中的远程 服务端，App 进程要与 AMS 交互，需要通过 <strong>AMS的代理</strong>对象 <code>ActivityManagerProxy</code> 来完成，来看 <code>ActivityManagerNative.getDefault()</code> 拿到的是什么：<br><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/app/ActivityManagerNative.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/android/app/ActivityManagerNative.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">getDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefault.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>getDefault</code> 是一个静态变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class=\"keyword\">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> IActivityManager <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 向 ServiceManager 查询一个 key 为 \"activity\" 的引用</span></span><br><span class=\"line\">        IBinder b = ServiceManager.getService(<span class=\"string\">\"activity\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">\"ActivityManager\"</span>, <span class=\"string\">\"default service binder = \"</span> + b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        IActivityManager am = asInterface(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">false</span>) &#123;</span><br><span class=\"line\">            Log.v(<span class=\"string\">\"ActivityManager\"</span>, <span class=\"string\">\"default service = \"</span> + am);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> am;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>ServiceManager</code> <strong>是 Binder IPC通信过程的核心</strong>，是上下文的管理者，<code>Binder</code> 服务端必须先向 <code>ServerManager</code> 注册才能够为客户端提供服务，<code>Binder</code> 客户端在与服务端通信之前需要从 <code>ServerManager</code> <strong>中查找并获取 <code>Binder</code> 服务端的引用</strong>。</p>\n<p>这里通过 “<strong>activity</strong>“ 这个名字向 <code>ServiceManager</code> 查询 <code>AMS</code> 的引用，获取 <code>AMS</code> 的引用后，调用 <code>asInterface</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">public</span> IActivityManager <span class=\"title\">asInterface</span><span class=\"params\">(IBinder obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章</span></span><br><span class=\"line\">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActivityManagerProxy(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 <code>AMS</code> 与 <code>Launcher App</code> 不在同一个进程中，这里返回的 <code>IBinder</code> 对象是一个 <code>Binder</code> 代理对象，因此这类将其包装成 <code>ActivityManagerProxy</code>对象并返回，<code>ActivityManagerProxy</code> 是<code>ActivityManagerNative</code> 的内部类，查看 <code>ActivityManagerProxy</code> 类 ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityManagerProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IActivityManager</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ActivityManagerProxy</span><span class=\"params\">(IBinder remote)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        mRemote = remote;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">asBinder</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mRemote;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用号为 START_ACTIVITY_TRANSACTION</span></span><br><span class=\"line\">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class=\"number\">0</span>);</span><br><span class=\"line\">        reply.readException();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = reply.readInt();</span><br><span class=\"line\">        reply.recycle();</span><br><span class=\"line\">        data.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ComponentName <span class=\"title\">startService</span><span class=\"params\">(IApplicationThread caller, Intent service,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String resolvedType, String callingPackage, <span class=\"keyword\">int</span> userId)</span> <span class=\"keyword\">throws</span> RemoteException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mRemote.transact(START_SERVICE_TRANSACTION, data, reply, <span class=\"number\">0</span>);</span><br><span class=\"line\">        reply.readException();</span><br><span class=\"line\">        ComponentName res = ComponentName.readFromParcel(reply);</span><br><span class=\"line\">        data.recycle();</span><br><span class=\"line\">        reply.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>ActivityManagerProxy</code> 里面将客户端的请求通过 <code>mRemote.transact</code>  进行转发，<code>mRemote</code> 对象正是 <code>Binder</code> 驱动返回来的 <strong>Binder 服务端的 Proxy</strong> 对象，通过 这个<code>Binder Proxy</code>，<code>Binder</code> 驱动最终将调用处于 <code>Binder Server</code> 端 <code>ActivityManagerNative</code> 中的 <code>onTransact</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTransact</span><span class=\"params\">(<span class=\"keyword\">int</span> code, Parcel data, Parcel reply, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据方法调用号 code 决定调用哪个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (code) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 startActivity 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class=\"line\">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class=\"line\">        reply.writeNoException();</span><br><span class=\"line\">        reply.writeInt(result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">case</span> START_SERVICE_TRANSACTION: &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);</span><br><span class=\"line\">            reply.writeNoException();</span><br><span class=\"line\">            ComponentName.writeToParcel(cn, reply);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-8-ActivityManagerService-startActivity\"><a href=\"#1-1-8-ActivityManagerService-startActivity\" class=\"headerlink\" title=\"1.1.8 ActivityManagerService.startActivity\"></a>1.1.8 ActivityManagerService.startActivity</h3><p><code>ActivityManagerNative</code> 是一个抽象类，它的 <code>startActivity</code> 为抽象方法，具体的实现在 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityManagerService.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</a> 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class=\"line\">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class=\"line\">            UserHandle.getCallingUserId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-小结\"><a href=\"#1-2-小结\" class=\"headerlink\" title=\"1.2 小结\"></a>1.2 小结</h2><p>你应该可以发现，相对于 <code>AIDL</code> 的调用过程，调用方 <code>Launcher App</code> 相当于 AIDL 过程中的 <code>Clinent</code>端；AMS 相当于远程 Service 的角色，充当 Server 端角色，他们的调用过程总体上都是一样的。<br>从 Launcher App 到 AMS 的时序图如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u54pqf70j30sk0gqabi.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"2-AMS-——-zygote\"><a href=\"#2-AMS-——-zygote\" class=\"headerlink\" title=\"2. AMS —— zygote\"></a>2. AMS —— zygote</h1><h2 id=\"2-1-调用过程分析\"><a href=\"#2-1-调用过程分析\" class=\"headerlink\" title=\"2.1 调用过程分析\"></a>2.1 调用过程分析</h2><h3 id=\"2-1-1-ActivityManagerService-startActivityAsUser\"><a href=\"#2-1-1-ActivityManagerService-startActivityAsUser\" class=\"headerlink\" title=\"2.1.1 ActivityManagerService.startActivityAsUser\"></a>2.1.1 ActivityManagerService.startActivityAsUser</h3><p>接着从 <code>AMS</code> 的 <code>startActivityAsUser</code> 方法开始分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class=\"keyword\">int</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</span><br><span class=\"line\">    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class=\"line\">                userId, <span class=\"keyword\">false</span>, ALLOW_FULL_ONLY, <span class=\"string\">\"startActivity\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></span><br><span class=\"line\">    <span class=\"comment\">// 调用 ActivityStarter 的 startActivityMayWait 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStarter.startActivityMayWait(caller, -<span class=\"number\">1</span>, callingPackage, intent,</span><br><span class=\"line\">            resolvedType, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class=\"line\">            profilerInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, bOptions, <span class=\"keyword\">false</span>, userId, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2-ActivityStarter-startActivityMayWait\"><a href=\"#2-1-2-ActivityStarter-startActivityMayWait\" class=\"headerlink\" title=\"2.1.2 ActivityStarter.startActivityMayWait\"></a>2.1.2 ActivityStarter.startActivityMayWait</h3><p>继续跟进 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStarter.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">(IApplicationThread caller, <span class=\"keyword\">int</span> callingUid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> startFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Bundle bOptions, <span class=\"keyword\">boolean</span> ignoreTargetSecurity, <span class=\"keyword\">int</span> userId,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IActivityContainer iContainer, TaskRecord inTask)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (mService) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 startActivityLocked 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class=\"line\">                aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class=\"line\">                resultTo, resultWho, requestCode, callingPid,</span><br><span class=\"line\">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class=\"line\">                options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class=\"line\">                inTask);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3-ActivityStarter-startActivityLocked\"><a href=\"#2-1-3-ActivityStarter-startActivityLocked\" class=\"headerlink\" title=\"2.1.3 ActivityStarter.startActivityLocked\"></a>2.1.3 ActivityStarter.startActivityLocked</h3><p>查看 <code>startActivityLocked</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityLocked</span><span class=\"params\">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> callingPid, <span class=\"keyword\">int</span> callingUid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, <span class=\"keyword\">int</span> realCallingPid, <span class=\"keyword\">int</span> realCallingUid, <span class=\"keyword\">int</span> startFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ActivityOptions options, <span class=\"keyword\">boolean</span> ignoreTargetSecurity, <span class=\"keyword\">boolean</span> componentSpecified,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        TaskRecord inTask)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 调用 doPendingActivityLaunchesLocked 方法，传入 false 参数</span></span><br><span class=\"line\">    doPendingActivityLaunchesLocked(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-4-ActivityStarter-doPendingActivityLaunchesLocked\"><a href=\"#2-1-4-ActivityStarter-doPendingActivityLaunchesLocked\" class=\"headerlink\" title=\"2.1.4 ActivityStarter.doPendingActivityLaunchesLocked\"></a>2.1.4 ActivityStarter.doPendingActivityLaunchesLocked</h3><p>查看 <code>doPendingActivityLaunchesLocked</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doPendingActivityLaunchesLocked</span><span class=\"params\">(<span class=\"keyword\">boolean</span> doResume)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PendingActivityLaunch pal = mPendingActivityLaunches.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用 startActivityUnchecked 方法</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> result = startActivityUnchecked(pal.r, pal.sourceRecord, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                pal.startFlags, resume, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, </span><br><span class=\"line\">                mSourceRecord, mTargetStack);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            Slog.e(TAG, <span class=\"string\">\"Exception during pending activity launch pal=\"</span> + pal, e);</span><br><span class=\"line\">            pal.sendErrorResult(e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-5-ActivityStarter-startActivityUnchecked\"><a href=\"#2-1-5-ActivityStarter-startActivityUnchecked\" class=\"headerlink\" title=\"2.1.5 ActivityStarter.startActivityUnchecked\"></a>2.1.5 ActivityStarter.startActivityUnchecked</h3><p>查看 <code>startActivityUnchecked</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityUnchecked</span><span class=\"params\">(<span class=\"keyword\">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, <span class=\"keyword\">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class=\"line\">    ...  </span><br><span class=\"line\">    <span class=\"comment\">// 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法</span></span><br><span class=\"line\">    mSupervisor.resumeFocusedStackTopActivityLocked();  </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    <span class=\"keyword\">return</span> START_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-6-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked\"><a href=\"#2-1-6-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked\" class=\"headerlink\" title=\"2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked\"></a>2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</h3><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java：</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeFocusedStackTopActivityLocked</span><span class=\"params\">(ActivityStack targetStack, ActivityRecord target,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetStack != <span class=\"keyword\">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span> || r.state != RESUMED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法</span></span><br><span class=\"line\">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-7-ActivityStack-resumeTopActivityUncheckedLocked\"><a href=\"#2-1-7-ActivityStack-resumeTopActivityUncheckedLocked\" class=\"headerlink\" title=\"2.1.7 ActivityStack.resumeTopActivityUncheckedLocked\"></a>2.1.7 ActivityStack.resumeTopActivityUncheckedLocked</h3><p>查看 <code>ActivityStack</code> 的 <code>resumeTopActivityUncheckedLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityUncheckedLocked</span><span class=\"params\">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 resumeTopActivityInnerLocked 方法</span></span><br><span class=\"line\">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mStackSupervisor.inResumeTopActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-8-ActivityStack-resumeTopActivityInnerLocked\"><a href=\"#2-1-8-ActivityStack-resumeTopActivityInnerLocked\" class=\"headerlink\" title=\"2.1.8 ActivityStack.resumeTopActivityInnerLocked\"></a>2.1.8 ActivityStack.resumeTopActivityInnerLocked</h3><p>查看 <code>resumeTopActivityInnerLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityRecord next = topRunningActivityLocked();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next.app != <span class=\"keyword\">null</span> &amp;&amp; next.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class=\"string\">\"resumeTopActivityLocked: Restarting \"</span> + next);</span><br><span class=\"line\">        <span class=\"comment\">// 调用 ActivityStackSupervisor 的 startSpecificActivityLocked 方法</span></span><br><span class=\"line\">        mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-9-ActivityStackSupervisor-startSpecificActivityLocked\"><a href=\"#2-1-9-ActivityStackSupervisor-startSpecificActivityLocked\" class=\"headerlink\" title=\"2.1.9 ActivityStackSupervisor.startSpecificActivityLocked\"></a>2.1.9 ActivityStackSupervisor.startSpecificActivityLocked</h3><p>回到 <code>ActivityStackSupervisor</code> 的 <code>startSpecificActivityLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">(ActivityRecord r, <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前 Activity 附属的 Application</span></span><br><span class=\"line\">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">            r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    r.task.stack.setLaunchTime(r);</span><br><span class=\"line\">    <span class=\"comment\">// 如果 Application 已经运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class=\"number\">0</span></span><br><span class=\"line\">                    || !<span class=\"string\">\"android\"</span>.equals(r.info.packageName)) &#123;</span><br><span class=\"line\">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class=\"line\">                        mService.mProcessStats);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            Slog.w(TAG, <span class=\"string\">\"Exception when starting activity \"</span></span><br><span class=\"line\">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 Application 没有运行,调用AMS,启动新进程</span></span><br><span class=\"line\">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先，在方法中获取了当前 <code>Activity</code> 附属的 <code>Application</code>，如果已经在运行了，说明这个 App 是已经被启动过了的，这时候调用 <code>realStartActivityLocked</code> 方法就可以进入下一步的流程了，同一个 App 中不同 <code>Activity</code> 的相互启动就是走的这个流程。当 <code>Application</code> 没有运行的时候，就需要调用 <code>AMS</code> 的 <code>startProcessLocked</code> 方法启动一个进程去承载它然后完成后续的工作，顺便铺垫一下，当新进程被启动完成后还会调用回到这个方法，查看 <code>AMS</code> 的 <code>startProcessLocked</code> 方法：</p>\n<h3 id=\"2-1-10-ActivityManagerService-startProcessLocked\"><a href=\"#2-1-10-ActivityManagerService-startProcessLocked\" class=\"headerlink\" title=\"2.1.10 ActivityManagerService.startProcessLocked\"></a>2.1.10 ActivityManagerService.startProcessLocked</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ProcessRecord <span class=\"title\">startProcessLocked</span><span class=\"params\">(String processName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ApplicationInfo info, <span class=\"keyword\">boolean</span> knownToBeDead, <span class=\"keyword\">int</span> intentFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String hostingType, ComponentName hostingName, <span class=\"keyword\">boolean</span> allowWhileBooting,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> isolated, <span class=\"keyword\">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class=\"line\">            hostingName, allowWhileBooting, isolated, <span class=\"number\">0</span> <span class=\"comment\">/* isolatedUid */</span>, keepIfLarge,</span><br><span class=\"line\">            <span class=\"keyword\">null</span> <span class=\"comment\">/* ABI override */</span>, <span class=\"keyword\">null</span> <span class=\"comment\">/* entryPoint */</span>, <span class=\"keyword\">null</span> <span class=\"comment\">/* entryPointArgs */</span>,</span><br><span class=\"line\">            <span class=\"keyword\">null</span> <span class=\"comment\">/* crashHandler */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-11-ActivityManagerService-startProcessLocked\"><a href=\"#2-1-11-ActivityManagerService-startProcessLocked\" class=\"headerlink\" title=\"2.1.11 ActivityManagerService.startProcessLocked\"></a>2.1.11 ActivityManagerService.startProcessLocked</h3><p>调用 <code>startProcessLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> ProcessRecord <span class=\"title\">startProcessLocked</span><span class=\"params\">(String processName, ApplicationInfo info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> knownToBeDead, <span class=\"keyword\">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> allowWhileBooting, <span class=\"keyword\">boolean</span> isolated, <span class=\"keyword\">int</span> isolatedUid, <span class=\"keyword\">boolean</span> keepIfLarge,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class=\"line\">    checkTime(startTime, <span class=\"string\">\"startProcess: done starting proc!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (app.pid != <span class=\"number\">0</span>) ? app : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-12-ActivityManagerService-startProcessLocked\"><a href=\"#2-1-12-ActivityManagerService-startProcessLocked\" class=\"headerlink\" title=\"2.1.12 ActivityManagerService.startProcessLocked\"></a>2.1.12 ActivityManagerService.startProcessLocked</h3><p>调用 <code>startProcessLocked</code> 的重载方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">startProcessLocked</span><span class=\"params\">(ProcessRecord app, String hostingType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Process 的 start 方法</span></span><br><span class=\"line\">        Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class=\"line\">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class=\"line\">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                app.info.dataDir, entryPointArgs);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-13-Process-start\"><a href=\"#2-1-13-Process-start\" class=\"headerlink\" title=\"2.1.13 Process.start\"></a>2.1.13 Process.start</h3><p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/android/os/Process.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/services/core/java/android/os/Process.java：</a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> debugFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 startViaZygote 方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class=\"line\">        Log.e(LOG_TAG,</span><br><span class=\"line\">                <span class=\"string\">\"Starting VM process through Zygote failed\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"string\">\"Starting VM process through Zygote failed\"</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-14-Process-startViaZygote\"><a href=\"#2-1-14-Process-startViaZygote\" class=\"headerlink\" title=\"2.1.14 Process.startViaZygote\"></a>2.1.14 Process.startViaZygote</h3><p>查看 <code>startViaZygote</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ProcessStartResult <span class=\"title\">startViaZygote</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> uid, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> gid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> debugFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                String[] extraArgs)</span></span></span><br><span class=\"line\"><span class=\"function\">                                <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Process.class) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 调用 zygoteSendArgsAndGetResult 方法，传入 openZygoteSocketIfNeeded 的返回值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-1-15-Process-zygoteSendArgsAndGetResult、Process-openZygoteSocketIfNeeded\"><a href=\"#2-1-15-Process-zygoteSendArgsAndGetResult、Process-openZygoteSocketIfNeeded\" class=\"headerlink\" title=\"2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded\"></a>2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded</h3><p>查看 <code>zygoteSendArgsAndGetResult</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ProcessStartResult <span class=\"title\">zygoteSendArgsAndGetResult</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.write(Integer.toString(args.size()));</span><br><span class=\"line\">        writer.newLine();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++) &#123;</span><br><span class=\"line\">            String arg = args.get(i);</span><br><span class=\"line\">            writer.write(arg);</span><br><span class=\"line\">            writer.newLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.flush();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Should there be a timeout on this?</span></span><br><span class=\"line\">        ProcessStartResult result = <span class=\"keyword\">new</span> ProcessStartResult();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待 socket 服务端（即zygote）返回新创建的进程pid;</span></span><br><span class=\"line\">        result.pid = inputStream.readInt();</span><br><span class=\"line\">        result.usingWrapper = inputStream.readBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.pid &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"fork() failed\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">        zygoteState.close();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>zygoteSendArgsAndGetResult</code> 中等待 <code>Socket</code> 服务端，也就是 <code>zygote</code> 进程返回创建新进程的结果，这里 <code>zygoteState</code> 参数是由 <code>openZygoteSocketIfNeeded</code> 方法返回的，<code>openZygoteSocketIfNeeded</code> 方法则负责根据 <code>abi</code> 向 <code>Zygote</code> 进程发起连接请求：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ZygoteState <span class=\"title\">openZygoteSocketIfNeeded</span><span class=\"params\">(String abi)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState == <span class=\"keyword\">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向主zygote发起connect()操作</span></span><br><span class=\"line\">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to primary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> primaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState == <span class=\"keyword\">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作</span></span><br><span class=\"line\">            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to secondary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> secondaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Unsupported zygote ABI: \"</span> + abi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-小结\"><a href=\"#2-2-小结\" class=\"headerlink\" title=\"2.2 小结\"></a>2.2 小结</h2><p>如果是从桌面新启动一个 App 中的 <code>Activity</code>，此时是没有进程去承载这个 App 的，因此需要通过 <code>AMS</code> 向 <code>zygote</code> 继承发起请求去完成这个任务，AMS 运行在 <code>system_server</code> 进程中，它通过 <code>Socket</code> 向 <code>zygote</code> 发起 <code>fock</code> 进程的请求，从 <code>AMS</code> 开始的调用时序图如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u5m53eloj30t50p7tcl.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"3-zygote-——-ActivityThread\"><a href=\"#3-zygote-——-ActivityThread\" class=\"headerlink\" title=\"3. zygote —— ActivityThread\"></a>3. zygote —— ActivityThread</h1><h2 id=\"3-1-调用过程分析\"><a href=\"#3-1-调用过程分析\" class=\"headerlink\" title=\"3.1 调用过程分析\"></a>3.1 调用过程分析</h2><h3 id=\"3-1-1-ZygoteInit-main\"><a href=\"#3-1-1-ZygoteInit-main\" class=\"headerlink\" title=\"3.1.1 ZygoteInit.main\"></a>3.1.1 ZygoteInit.main</h3><p><code>zygote</code> 进程的其中一项任务就是：</p>\n<p>调用 <code>registerZygoteSocket()</code>函数建立 <code>Socket</code> 通道，使 <code>zygote</code> 进程成为 <code>Socket</code> 服务端，并通过<code>runSelectLoop()</code> 函数等待 <code>ActivityManagerService</code> 发送请求创建新的应用程序进程。</p>\n<p><code>zygote</code> 终于要再次上场了！接下来从 <strong>ZygoteInit.java</strong> 的 <code>main</code> 方法开始回顾一下 <code>zygote</code> 进程的工作：</p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/com/android/internal/os/ZygoteInit.java：</a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        runSelectLoop(abiList);</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class=\"line\">        caller.run();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">        closeServerSocket();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-2-ZygoteInit-runSelectLoop\"><a href=\"#3-1-2-ZygoteInit-runSelectLoop\" class=\"headerlink\" title=\"3.1.2 ZygoteInit.runSelectLoop\"></a>3.1.2 ZygoteInit.runSelectLoop</h3><p>查看 <code>runSelectLoop</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runSelectLoop</span><span class=\"params\">(String abiList)</span> <span class=\"keyword\">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 循环读取状态</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = pollFds.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 读取的状态不是客户端连接或者数据请求时，进入下一次循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// i = 0 表示跟客户端 Socket 连接上了</span></span><br><span class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class=\"line\">                peers.add(newPeer);</span><br><span class=\"line\">                fds.add(newPeer.getFileDesciptor());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// i &gt; 0 表示接收到客户端 Socket 发送过来的请求</span></span><br><span class=\"line\">                <span class=\"comment\">// runOnce 方法创建一个新的应用程序进程</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> done = peers.get(i).runOnce();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">                    peers.remove(i);</span><br><span class=\"line\">                    fds.remove(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-3-ZygoteConnection-runOnce\"><a href=\"#3-1-3-ZygoteConnection-runOnce\" class=\"headerlink\" title=\"3.1.3 ZygoteConnection.runOnce\"></a>3.1.3 ZygoteConnection.runOnce</h3><p>查看 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/com/android/internal/os/</a><br><strong>ZygoteConnection.java</strong> 的 <code>runOnce</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">runOnce</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    String args[];</span><br><span class=\"line\">    Arguments parsedArgs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    FileDescriptor[] descriptors;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取 socket 客户端发送过来的参数列表</span></span><br><span class=\"line\">        args = readArgumentList();</span><br><span class=\"line\">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// EOF reached.</span></span><br><span class=\"line\">        closeSocket();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式</span></span><br><span class=\"line\">        parsedArgs = <span class=\"keyword\">new</span> Arguments(args);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 同样调用 Zygote.java 的 forkAndSpecialize 方法 fock 出子进程</span></span><br><span class=\"line\">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class=\"line\">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class=\"line\">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class=\"line\">                parsedArgs.appDataDir);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 子进程执行</span></span><br><span class=\"line\">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">            serverPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 进入子进程流程</span></span><br><span class=\"line\">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 父进程执行</span></span><br><span class=\"line\">            IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">            childPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-4-ZygoteConnection-handleChildProc\"><a href=\"#3-1-4-ZygoteConnection-handleChildProc\" class=\"headerlink\" title=\"3.1.4 ZygoteConnection.handleChildProc\"></a>3.1.4 ZygoteConnection.handleChildProc</h3><p>首先解析 <code>Socket</code> 客户端传过来的参数，<code>Zygote.java</code> 的 <code>forkAndSpecialize</code> 返回的 <code>pid == 0</code> 的时候表示此时在 <code>fock</code> 出来的子进程中执行，继续调用 <code>handleChildProc</code> 方法，并将参数继续层层传递：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleChildProc</span><span class=\"params\">(Arguments parsedArgs, FileDescriptor[] </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span> <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*由于 fock 出来的 system_server 进程会复制 zygote 进程的地址空间，因此它也得到了 zygote</span></span><br><span class=\"line\"><span class=\"comment\">    进程中的 Socket，这个 Socket 对它来说并无用处，这里将其关闭 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    closeSocket();</span><br><span class=\"line\">    ZygoteInit.closeServerSocket();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsedArgs.niceName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置进程名</span></span><br><span class=\"line\">        Process.setArgV0(parsedArgs.niceName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsedArgs.invokeWith != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 RuntimeInit 的 zygoteInit 方法</span></span><br><span class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class=\"line\">                parsedArgs.remainingArgs, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-5-RuntimeInit-zygoteInit\"><a href=\"#3-1-5-RuntimeInit-zygoteInit\" class=\"headerlink\" title=\"3.1.5 RuntimeInit.zygoteInit\"></a>3.1.5 RuntimeInit.zygoteInit</h3><p>查看 <a href=\"https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java\" target=\"_blank\" rel=\"noopener\">frameworks/base/core/java/com/android/internal/os/RuntimeInit.java </a>的 <code>zygoteInit</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">zygoteInit</span><span class=\"params\">(<span class=\"keyword\">int</span> targetSdkVersion, String[] argv, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ClassLoader classLoader)</span> <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) Slog.d(TAG, <span class=\"string\">\"RuntimeInit: Starting application from zygote\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">\"RuntimeInit\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 重定向 log 输出</span></span><br><span class=\"line\">    redirectLogStreams();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化一些通用的设置</span></span><br><span class=\"line\">    commonInit(); </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 的 </span></span><br><span class=\"line\"><span class=\"comment\">     *onZygoteInit 方法启动 Binder 线程池， 使 system_server 进程可以使用 Binder  *与其他进程通信</span></span><br><span class=\"line\"><span class=\"comment\">     **/</span></span><br><span class=\"line\">    nativeZygoteInit(); </span><br><span class=\"line\">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-6-RuntimeInit-applicationInit\"><a href=\"#3-1-6-RuntimeInit-applicationInit\" class=\"headerlink\" title=\"3.1.6 RuntimeInit.applicationInit\"></a>3.1.6 RuntimeInit.applicationInit</h3><p>继续调用 <code>applicationInit</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">applicationInit</span><span class=\"params\">(<span class=\"keyword\">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 提取出参数里面的要启动的类的名字</span></span><br><span class=\"line\">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-7-RuntimeInit-invokeStaticMain\"><a href=\"#3-1-7-RuntimeInit-invokeStaticMain\" class=\"headerlink\" title=\"3.1.7 RuntimeInit.invokeStaticMain\"></a>3.1.7 RuntimeInit.invokeStaticMain</h3><p>主要调用了 <code>invokeStaticMain</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeStaticMain</span><span class=\"params\">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"keyword\">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; cl;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/** className 为通过 Socket 客户端（AMS）传递过来的一系列参数中的其中一个，这里获取到的值为传\"com.android.app.ActivityThread\"，然后通过反射得到 ActivityThread 类 **/</span></span><br><span class=\"line\">        cl = Class.forName(className, <span class=\"keyword\">true</span>, classLoader);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Missing class when invoking static main \"</span> + className, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Method m;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找到 ActivityThread 类的 main 方法</span></span><br><span class=\"line\">        m = cl.getMethod(<span class=\"string\">\"main\"</span>, <span class=\"keyword\">new</span> Class[] &#123; String[].class &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Missing static main on \"</span> + className, ex);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Problem getting static main on \"</span> + className, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> modifiers = m.getModifiers();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">\"Main method is not public and static on \"</span> + className);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出</span></span><br><span class=\"line\"><span class=\"comment\">    捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-8-MethodAndArgsCaller-run\"><a href=\"#3-1-8-MethodAndArgsCaller-run\" class=\"headerlink\" title=\"3.1.8 MethodAndArgsCaller.run\"></a>3.1.8 MethodAndArgsCaller.run</h3><p>回到 <code>ZygoteInit</code> 的 <code>main</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    closeServerSocket();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 接收到 caller 对象后调用它的 run 方法</span></span><br><span class=\"line\">        caller.run();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">\"Zygote died with exception\"</span>, ex);</span><br><span class=\"line\">        closeServerSocket();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>跟 <code>system_server</code> 进程的启动过程一样，这里同样通过抛出异常的方式来清空调用 <code>ActivityThread.main</code>之前的方法栈帧。<br><code>ZygoteInit</code> 的 <code>MethodAndArgsCaller</code> 类是一个 <code>Exception</code> 类，同时也实现了 <code>Runnable</code> 接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodAndArgsCaller</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method mMethod;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String[] mArgs;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MethodAndArgsCaller</span><span class=\"params\">(Method method, String[] args)</span> </span>&#123;</span><br><span class=\"line\">        mMethod = method;</span><br><span class=\"line\">        mArgs = args;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用传递过来的 mMethod</span></span><br><span class=\"line\">            mMethod.invoke(<span class=\"keyword\">null</span>, <span class=\"keyword\">new</span> Object[] &#123; mArgs &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(ex);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException ex) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-1-9-ActivityThread-main\"><a href=\"#3-1-9-ActivityThread-main\" class=\"headerlink\" title=\"3.1.9 ActivityThread .main\"></a>3.1.9 ActivityThread .main</h3><p>最后通过反射调用到 <code>ActivityThread</code> 的 <code>main</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Environment.initForCurrentUser();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Process.setArgV0(<span class=\"string\">\"&lt;pre-initialized&gt;\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建主线程 Looper</span></span><br><span class=\"line\">    Looper.prepareMainLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">    ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</span><br><span class=\"line\">    <span class=\"comment\">// attach 到系统进程</span></span><br><span class=\"line\">    thread.attach(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sMainThreadHandler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        sMainThreadHandler = thread.getHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程进入轮询状态</span></span><br><span class=\"line\">    Looper.loop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 抛出异常说明轮询出现问题</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Main thread loop unexpectedly exited\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-2-小结\"><a href=\"#3-2-小结\" class=\"headerlink\" title=\"3.2 小结\"></a>3.2 小结</h2><p><code>zygote</code> 进程作为 <code>Socket</code> 服务端在接收到作为客户端的 <code>AMS</code> 发送过来的请求和参数之后，<code>fock</code> 出新的进程并根据各种参数进程了初始化的工作，这个过程和 <code>zygote</code> 启动 <code>system_server</code> 进程的过程如出一辙，时序图如下所示：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u80ukv7ej30q30ivmzb.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<h1 id=\"4-ActivityThread-——-Activity\"><a href=\"#4-ActivityThread-——-Activity\" class=\"headerlink\" title=\"4. ActivityThread —— Activity\"></a>4. ActivityThread —— Activity</h1><p>##4.1 调用过程分析</p>\n<h3 id=\"4-1-1-ActivityThread-attach\"><a href=\"#4-1-1-ActivityThread-attach\" class=\"headerlink\" title=\"4.1.1 ActivityThread.attach\"></a>4.1.1 ActivityThread.attach</h3><p>上一小节的最后，<code>ActivityThread</code> 的 <code>main</code> 通过反射被运行起来了，接着会调用 <code>ActivityThread</code> 的 <code>attach</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(<span class=\"keyword\">boolean</span> system)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mSystemThread = system;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!system) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 获取 ActivityManagerProxy 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过 Binder 调用 AMS 的 attachApplication 方法</span></span><br><span class=\"line\">            mgr.attachApplication(mAppThread);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，我们再一次通过 <code>Binder IPC</code> 机制跟 <code>AMS</code> 通信，通信模型跟前面<code>Launcher App</code>调用 <code>AMS</code> 的 <code>startActivity</code> 方法一样，getDefault 过程不重复分析，这次是调用了 <code>AMS</code> 的 <code>attachApplication</code> 方法，注意这里将 <code>ApplicationThead</code> 类型的 <code>mAppThread</code> 对象作为参数传递了过去，<code>ApplicationThead</code> 是 <code>ActivityThread</code> 的一个内部类，后面我们会讲到，先查看 <code>AMP</code> 的 <code>attachApplication</code> 方法：</p>\n<h3 id=\"4-1-2-ActivityManagerProxy-attachApplication\"><a href=\"#4-1-2-ActivityManagerProxy-attachApplication\" class=\"headerlink\" title=\"4.1.2 ActivityManagerProxy.attachApplication\"></a>4.1.2 ActivityManagerProxy.attachApplication</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attachApplication</span><span class=\"params\">(IApplicationThread app)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 调用 asBinder 方法使其能够跨进程传输</span></span><br><span class=\"line\">    data.writeStrongBinder(app.asBinder());</span><br><span class=\"line\">    <span class=\"comment\">// 通过 transact 方法将数据交给 Binder 驱动</span></span><br><span class=\"line\">    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, <span class=\"number\">0</span>); </span><br><span class=\"line\">    reply.readException();</span><br><span class=\"line\">    data.recycle();</span><br><span class=\"line\">    reply.recycle();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-3-ActivityManagerNative-onTransact\"><a href=\"#4-1-3-ActivityManagerNative-onTransact\" class=\"headerlink\" title=\"4.1.3 ActivityManagerNative.onTransact\"></a>4.1.3 ActivityManagerNative.onTransact</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTransact</span><span class=\"params\">(<span class=\"keyword\">int</span> code, Parcel data, Parcel reply, <span class=\"keyword\">int</span> flags)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (code) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ATTACH_APPLICATION_TRANSACTION: &#123;</span><br><span class=\"line\">            data.enforceInterface(IActivityManager.descriptor);</span><br><span class=\"line\">            <span class=\"comment\">// 获取 ApplicationThread 的代理对象，这里返回的是 ApplicationThreadNative(ATN)</span></span><br><span class=\"line\">            <span class=\"comment\">// 的内部类：ApplicationThreadProxy(ATP) 对象</span></span><br><span class=\"line\">            IApplicationThread app = ApplicationThreadNative.asInterface(data.readStrongBinder());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 委托给 AMS 执行</span></span><br><span class=\"line\">                attachApplication(app);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            reply.writeNoException();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>asInterface</code> 将 <code>ActivityThread</code> 对象<strong>转换</strong>成了 <code>ApplicationThreadNative</code> 的 <code>Binder</code> 代理对象 <code>ApplicationThreadProxy</code>，并作为参数传给 <code>attachApplication</code> 方法，其中 <code>ApplicationThreadProxy</code> 是 <code>ApplicationThreadNative</code> 的<strong>内部类</strong>。</p>\n<h3 id=\"4-1-4-ActivityManagerService-attachApplication\"><a href=\"#4-1-4-ActivityManagerService-attachApplication\" class=\"headerlink\" title=\"4.1.4 ActivityManagerService.attachApplication\"></a>4.1.4 ActivityManagerService.attachApplication</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attachApplication</span><span class=\"params\">(IApplicationThread thread)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> callingPid = Binder.getCallingPid();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> origId = Binder.clearCallingIdentity();</span><br><span class=\"line\">        attachApplicationLocked(thread, callingPid);</span><br><span class=\"line\">        Binder.restoreCallingIdentity(origId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-5-ActivityManagerService-attachApplicationLocked\"><a href=\"#4-1-5-ActivityManagerService-attachApplicationLocked\" class=\"headerlink\" title=\"4.1.5 ActivityManagerService.attachApplicationLocked\"></a>4.1.5 ActivityManagerService.attachApplicationLocked</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(IApplicationThread thread, <span class=\"keyword\">int</span> pid)</span> </span>&#123;</span><br><span class=\"line\">    ProcessRecord app;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 绑定死亡通知</span></span><br><span class=\"line\">        AppDeathRecipient adr = <span class=\"keyword\">new</span> AppDeathRecipient(app, pid, thread);</span><br><span class=\"line\">        thread.asBinder().linkToDeath(adr, <span class=\"number\">0</span>);</span><br><span class=\"line\">        app.deathRecipient = adr;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        app.resetPackageList(mProcessStats);</span><br><span class=\"line\">        <span class=\"comment\">// 如果 system_server 进程死亡则重新启动进程</span></span><br><span class=\"line\">        startProcessLocked(app, <span class=\"string\">\"link fail\"</span>, processName); </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 获取应用appInfo</span></span><br><span class=\"line\">        ApplicationInfo appInfo = app.instrumentationInfo != <span class=\"keyword\">null</span></span><br><span class=\"line\">                ? app.instrumentationInfo : app.info;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 绑定应用</span></span><br><span class=\"line\">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class=\"line\">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class=\"line\">                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</span><br><span class=\"line\">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Configuration(mConfiguration), app.compat,</span><br><span class=\"line\">                getCommonServicesLocked(app.isolated),</span><br><span class=\"line\">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        app.resetPackageList(mProcessStats);</span><br><span class=\"line\">        app.unlinkDeathRecipient();</span><br><span class=\"line\">        <span class=\"comment\">// bindApplication 失败也要重启进程</span></span><br><span class=\"line\">        startProcessLocked(app, <span class=\"string\">\"bind fail\"</span>, processName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 Activity: 检查最顶层可见的Activity是否等待在该进程中运行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (normalMode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class=\"line\">                didSomething = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是 Service: 寻找所有需要在该进程中运行的服务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!badApp) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果是 BroadcastReceiver: 检查是否在这个进程中有下一个广播接收者</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否在这个进程中有下一个 backup 代理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!badApp &amp;&amp; mBackupTarget != <span class=\"keyword\">null</span> &amp;&amp; mBackupTarget.appInfo.uid == app.uid) &#123;</span><br><span class=\"line\">        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class=\"line\">                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class=\"line\">                    mBackupTarget.backupMode);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (badApp) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 杀掉 badApp</span></span><br><span class=\"line\">        app.kill(<span class=\"string\">\"error during init\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        handleAppDiedLocked(app, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!didSomething) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新 adj(组件的权值)</span></span><br><span class=\"line\">        updateOomAdjLocked(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，通过 <code>ApplicationThreadProxy</code> 使用 <code>Binder</code> 向 <code>ApplicationThreadProxy</code> 发起 <code>bindApplication</code> 请求，然后通过 <code>normalMode</code> 字段判断是否为 <code>Activity</code>，如果是则执行 <code>ActivityStackSupervisor</code> 的 <code>attachApplicationLocked</code> 方法。</p>\n<h4 id=\"4-1-5-1-ActivityThread-java-ApplicationThread-bindApplication\"><a href=\"#4-1-5-1-ActivityThread-java-ApplicationThread-bindApplication\" class=\"headerlink\" title=\"4.1.5.1 ActivityThread.java::ApplicationThread.bindApplication\"></a>4.1.5.1 ActivityThread.java::ApplicationThread.bindApplication</h4><p><code>thread</code> 对象类型是 <code>ApplicationThreadProxy</code>，通过 <code>Binder</code> 驱动调到了 <code>ApplicationThreadNative</code> 的方法，<code>ApplicationThreadNative</code> 是一个抽象类，它的实现都委托给了 <code>ApplicationThread</code>(这跟 AMS 跟 AMN 的关系一样)，ApplicationThread 作为 ActivityThread 的内部类存在，它的 binderApplication 方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActivityThread.java::ApplicationThread：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bindApplication</span><span class=\"params\">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    IUiAutomationConnection instrumentationUiConnection, <span class=\"keyword\">int</span> debugMode, <span class=\"keyword\">boolean</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    enableOpenGlTrace, <span class=\"keyword\">boolean</span> isRestrictedBackupMode, <span class=\"keyword\">boolean</span> persistent, Configuration</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (services != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将services缓存起来, 减少binder检索服务的次数</span></span><br><span class=\"line\">        ServiceManager.initServiceCache(services);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 发送消息 H.BIND_APPLICATION 给 Handler 对象</span></span><br><span class=\"line\">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>H</strong> 是 <strong>ActivityThread</strong> 中的一个 <strong>Handler</strong> 对象，用于处理发送过来的各种消息：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BIND_APPLICATION        = <span class=\"number\">110</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> BIND_APPLICATION:</span><br><span class=\"line\">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">\"bindApplication\"</span>);</span><br><span class=\"line\">            AppBindData data = (AppBindData)msg.obj;</span><br><span class=\"line\">            handleBindApplication(data);</span><br><span class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了 <code>handleBindApplication</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void handleBindApplication(AppBindData data) &#123;</span><br><span class=\"line\">    // 获取 LoadedApk 对象</span><br><span class=\"line\">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // 创建 ContextImpl 上下文</span><br><span class=\"line\">    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    // 创建 Instrumentation 对象</span><br><span class=\"line\">    if (data.instrumentationName != null) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        mInstrumentation = new Instrumentation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 调用 LoadedApk 的 makeApplication 方法创建 Application</span><br><span class=\"line\">        Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class=\"line\">        mInitialApplication = app;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class=\"line\">        // 调用 Application.onCreate 方法</span><br><span class=\"line\">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        StrictMode.setThreadPolicy(savedPolicy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-1-5-2-ActivityStackSupervisor-attachApplicationLocked\"><a href=\"#4-1-5-2-ActivityStackSupervisor-attachApplicationLocked\" class=\"headerlink\" title=\"4.1.5.2 ActivityStackSupervisor.attachApplicationLocked\"></a>4.1.5.2 ActivityStackSupervisor.attachApplicationLocked</h4><p>在 <strong>4.1.4</strong> 小节中通过 <strong>Binder</strong> 向 <strong>ActivityThread</strong> 发起 <code>bindApplication</code> 请求后，会根据启动组件的类型去做相应的处理，如果是 <code>Acitivity</code>，则会调用 <strong>ActivityStackSupervisor</strong> 的 <code>attachApplicationLocked</code> 方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(ProcessRecord app)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String processName = app.processName;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> didSomething = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> displayNdx = mActivityDisplays.size() - <span class=\"number\">1</span>; displayNdx &gt;= <span class=\"number\">0</span>; --displayNdx) &#123;</span><br><span class=\"line\">        ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> stackNdx = stacks.size() - <span class=\"number\">1</span>; stackNdx &gt;= <span class=\"number\">0</span>; --stackNdx) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ActivityStack stack = stacks.get(stackNdx);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isFrontStack(stack)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 获取前台stack中栈顶第一个非 finishing 状态的 Activity</span></span><br><span class=\"line\">            ActivityRecord hr = stack.topRunningActivityLocked(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hr.app == <span class=\"keyword\">null</span> &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 真正的启动 Activity</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (realStartActivityLocked(hr, app, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">                            didSomething = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> didSomething;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">##### 4.1.5.2.1 ActivityStackSupervisor.realStartActivityLocked</span><br><span class=\"line\"></span><br><span class=\"line\">前面 **<span class=\"number\">2.1</span>.8ActivityStackSupervisor.startSpecificActivityLocked**  小节中分析过，如果当前 `Activity` 依附的 `Application` 已经被启动，则调用 `realStartActivityLocked` 方法，否则创建新的进程，再创建新的进程之后，两个流程的在这里合并起来了：</span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">(ActivityRecord r, ProcessRecord app, <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityStack stack = task.stack;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class=\"line\">        <span class=\"comment\">// 通过 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法</span></span><br><span class=\"line\">        app.thread.scheduleLaunchActivity(<span class=\"keyword\">new</span> Intent(r.intent), r.appToken,</span><br><span class=\"line\">                System.identityHashCode(r), r.info, <span class=\"keyword\">new</span> Configuration(mService.mConfiguration),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class=\"line\">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class=\"line\">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.launchFailed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第二次启动失败，则结束该 Activity</span></span><br><span class=\"line\">            mService.appDiedLocked(app);</span><br><span class=\"line\">            stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"2nd-crash\"</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 第一个启动失败，则重启进程</span></span><br><span class=\"line\">        app.activities.remove(r);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">这里有一次使用 `Binder` 调用 `ApplicationThread` 的 `scheduleLaunchActivity` 方法。</span><br><span class=\"line\"></span><br><span class=\"line\">##### 4.1.5.2.2 ApplicationThread.scheduleLaunchActivity</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleLaunchActivity</span><span class=\"params\">(Intent intent, IBinder token, <span class=\"keyword\">int</span> ident, ActivityInfo </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        compatInfo, String referrer, IVoiceInteractor voiceInteractor, <span class=\"keyword\">int</span> procState, Bundle </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        List&lt;ReferrerIntent&gt; pendingNewIntents, <span class=\"keyword\">boolean</span> notResumed, <span class=\"keyword\">boolean</span> isForward, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    updateProcessState(procState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面提到过，<strong>H</strong> 是 <strong>ActivityThread</strong> 中一个 <strong>Handler</strong> 类，它接收到 <code>LAUNCH_ACTIVITY</code> 消息后会调用 <code>handleLaunchActivity</code> 方法。</p>\n<h5 id=\"4-1-5-2-3-ActivityThread-handleLaunchActivity\"><a href=\"#4-1-5-2-3-ActivityThread-handleLaunchActivity\" class=\"headerlink\" title=\"4.1.5.2.3 ActivityThread.handleLaunchActivity\"></a>4.1.5.2.3 ActivityThread.handleLaunchActivity</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 初始化 WMS</span></span><br><span class=\"line\">    WindowManagerGlobal.initialize();</span><br><span class=\"line\">    <span class=\"comment\">// 执行 performLaunchActivity 方法</span></span><br><span class=\"line\">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        r.createdConfig = <span class=\"keyword\">new</span> Configuration(mConfiguration);</span><br><span class=\"line\">        Bundle oldState = r.state;</span><br><span class=\"line\">        <span class=\"comment\">// 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法</span></span><br><span class=\"line\">        handleResumeActivity(r.token, <span class=\"keyword\">false</span>, r.isForward,</span><br><span class=\"line\">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class=\"line\">            r.activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            mInstrumentation.callActivityOnPause(r.activity);</span><br><span class=\"line\">            r.paused = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 停止该 Activity</span></span><br><span class=\"line\">        ActivityManagerNative.getDefault()</span><br><span class=\"line\">            .finishActivity(r.token, Activity.RESULT_CANCELED, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-1-4-2-4-ApplicationThread-performLaunchActivity\"><a href=\"#4-1-4-2-4-ApplicationThread-performLaunchActivity\" class=\"headerlink\" title=\"4.1.4.2.4 ApplicationThread.performLaunchActivity\"></a>4.1.4.2.4 ApplicationThread.performLaunchActivity</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class=\"line\">        <span class=\"comment\">// Instrumentation 中使用反射创建 Activity</span></span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Application 对象并调用 Application 的 onCreate 方法</span></span><br><span class=\"line\">        Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"comment\">// attach 到 Window 上</span></span><br><span class=\"line\">            activity.attach(appContext, <span class=\"keyword\">this</span>, getInstrumentation(), r.token,</span><br><span class=\"line\">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class=\"line\">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class=\"line\">                    r.referrer, r.voiceInteractor);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (customIntent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                activity.mIntent = customIntent;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.lastNonConfigurationInstances = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            activity.mStartedActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置主题</span></span><br><span class=\"line\">                activity.setTheme(theme);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重新创建的 Activity</span></span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第一次创建的 Activity</span></span><br><span class=\"line\">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;  <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-1-5-2-5-Instrumentation-callActivityOnCreate\"><a href=\"#4-1-5-2-5-Instrumentation-callActivityOnCreate\" class=\"headerlink\" title=\"4.1.5.2.5 Instrumentation.callActivityOnCreate\"></a>4.1.5.2.5 Instrumentation.callActivityOnCreate</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PersistableBundle persistentState)</span> </span>&#123;</span><br><span class=\"line\">    prePerformCreate(activity);</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Activity 的 performCreate 方法</span></span><br><span class=\"line\">    activity.performCreate(icicle, persistentState);</span><br><span class=\"line\">    postPerformCreate(activity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-1-5-2-6-Activity-performCreate\"><a href=\"#4-1-5-2-6-Activity-performCreate\" class=\"headerlink\" title=\"4.1.5.2.6 Activity.performCreate\"></a>4.1.5.2.6 Activity.performCreate</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performCreate</span><span class=\"params\">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class=\"line\">        restoreHasCurrentPermissionRequest(icicle);</span><br><span class=\"line\">    onCreate(icicle, persistentState);</span><br><span class=\"line\">    mActivityTransitionState.readState(icicle);</span><br><span class=\"line\">    performCreateCommon();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>终于，onCreate 方法被调用了！！！</p>\n<h2 id=\"4-2-小结\"><a href=\"#4-2-小结\" class=\"headerlink\" title=\"4.2 小结\"></a>4.2 小结</h2><p>从 <code>ActivityThread</code> 到最终 <code>Activity</code> 被创建及生命周期被调用，核心过程涉及到了三次<strong> Binder IPC</strong> 过程，分别是：</p>\n<pre><code>1. ActivityThread 调用 AMS 的 attachApplication 方法\n\n2. AMS 调用 ApplicationThread 的 bindApplication 方法\n\n3. ActivityStackSupervisor 调用 Application 的 attachApplicationLocked 方法\n</code></pre><p>整个过程的时序图如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u8r1k48wj30t30qo43w.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<ol start=\"5\">\n<li>总结<br>纵观整个过程，从 Launcher 到 AMS、从 AMS 再到 Zygote、再从 Zygote 到 ActivityThread，最后在 ActivitThread 中层层调用到 Activity 的生命周期方法，中间涉及到了无数的细节，但总体上脉络还是非常清晰的，各个 Android 版本的 Framework 层代码可以某些过程的实现不太一样，但是整个调用流程大体上也是相同的，借用 <a href=\"http://gityuan.com/android/\" target=\"_blank\" rel=\"noopener\">Gityuan</a> 大神的一张图作为结尾：</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0u8shvqsuj30qo0k0gt0.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n"},{"title":"为什么要有Java内存模型?","date":"2019-03-11T02:54:34.000Z","_content":"\n# 为什么要有Java内存模型?\n\nJava内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。\n\n网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。\n\n## 为什么要有内存模型\n\n在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。\n\n**内存模型，英文名Memory Model**，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。\n\n### CPU和缓存一致性\n我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。\n\n刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。\n\n> 这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。\n\n\n可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。\n\n所以，人们想出来了一个好的办法，就是在CPU和内存之间增加**高速缓存**。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是**速度快，内存小，并且昂贵**。\n\n那么，程序的执行过程就变成了：\n\n当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的**高速缓存**当中，那么CPU进行计算时就可以直接从它的**高速缓存读取数据和向其中写入数据**，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n\n> 之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。\n\n\n而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。\n\n按照数据读取顺序和与CPU结合的紧密程度，**CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3）**，每一级缓存中所储存的全部数据都是下一级缓存的一部分。\n\n这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。\n\n那么，在有了多级缓存之后，程序的执行就变成了：\n\n当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。\n\n> 随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。\n\n单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。\n\n> 公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。\n\n> 单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。\n\n> 多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。\n\n> 还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0ynd4vsasj30fg0bi0tg.jpg)\n\n\n随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。\n\n单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。\n\n单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。\n\n多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。**由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。**\n\n**在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。**\n\n如果这家公司的命令都是串行下发的话，那么就没有任何问题。\n\n如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。\n\n如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。\n\n> 比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。\n\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0ynvitf1ij30kl0b7mxv.jpg)\n\n### 处理器优化和指令重排\n上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。\n\n除了现在很多流行的**处理器会对代码进行优化乱序处理**，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时**编译器（JIT）也会做指令重排**。\n\n**可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。**\n\n> 关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。\n\n\n## 并发编程的问题\n前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。\n\n其实，**原子性问题，可见性问题和有序性问题**。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。\n\n这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：\n\n1. **原子性:**指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。\n\n2. **可见性:**指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n3. **有序性:**即程序执行的顺序按照代码的先后顺序执行。\n\n**有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。**所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。\n\n### 什么是内存模型\n前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？\n\n最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。\n\n**所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。**\n为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。\n\n内存模型解决并发问题主要采用两种方式：**限制处理器优化和使用内存屏障。**本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。\n\n### 什么是Java内存模型\n前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。\n\n我们知道，Java程序是需要运行在Java虚拟机上面的，**Java内存模型（Java Memory Model ,JMM）**就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。\n\n提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）\n\nJava内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。\n\n而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。\n\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg)\n\n\n这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。\n\n所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。\n\n### Java内存模型的实现\n了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如**volatile、synchronized、final、concurren**包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。\n\n在开发多线程的代码的时候，我们可以直接使用`synchronized`等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。\n\n本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，**并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证:**\n\n#### 原子性\n在Java中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。这两个字节码，在Java中对应的关键字就是`synchronized`。\n\n因此，在Java中可以使用`synchronized`来保证方法和代码块内的操作是原子性的。\n\n#### 可见性\n**Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。**\n\nJava中的`volatile`关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性。\n\n除了`volatile`，Java中的`synchronized`和`final`两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。\n\n#### 有序性\n在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：\n\n**`volatile`关键字会禁止指令重排。**`synchronized`关键字保证同一时刻只允许**一条线程**操作。\n\n好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。\n\n**但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。**\n\n总结\n在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。\n\n可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。","source":"_posts/WhyhasJMMexit-1552272874543.md","raw":"---\ntitle: 为什么要有Java内存模型?\ntags:\n  - Java内存模型\ncategories:\n  - Java\ndate: 2019-03-11 10:54:34\n---\n\n# 为什么要有Java内存模型?\n\nJava内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。\n\n网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。\n\n## 为什么要有内存模型\n\n在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。\n\n**内存模型，英文名Memory Model**，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。\n\n### CPU和缓存一致性\n我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。\n\n刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。\n\n> 这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。\n\n\n可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。\n\n所以，人们想出来了一个好的办法，就是在CPU和内存之间增加**高速缓存**。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是**速度快，内存小，并且昂贵**。\n\n那么，程序的执行过程就变成了：\n\n当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的**高速缓存**当中，那么CPU进行计算时就可以直接从它的**高速缓存读取数据和向其中写入数据**，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n\n> 之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。\n\n\n而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。\n\n按照数据读取顺序和与CPU结合的紧密程度，**CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3）**，每一级缓存中所储存的全部数据都是下一级缓存的一部分。\n\n这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。\n\n那么，在有了多级缓存之后，程序的执行就变成了：\n\n当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。\n\n> 随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。\n\n单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。\n\n> 公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。\n\n> 单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。\n\n> 多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。\n\n> 还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0ynd4vsasj30fg0bi0tg.jpg)\n\n\n随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。\n\n单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。\n\n单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。\n\n多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。**由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。**\n\n**在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。**\n\n如果这家公司的命令都是串行下发的话，那么就没有任何问题。\n\n如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。\n\n如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。\n\n> 比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。\n\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0ynvitf1ij30kl0b7mxv.jpg)\n\n### 处理器优化和指令重排\n上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。\n\n除了现在很多流行的**处理器会对代码进行优化乱序处理**，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时**编译器（JIT）也会做指令重排**。\n\n**可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。**\n\n> 关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。\n\n\n## 并发编程的问题\n前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。\n\n其实，**原子性问题，可见性问题和有序性问题**。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。\n\n这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：\n\n1. **原子性:**指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。\n\n2. **可见性:**指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n3. **有序性:**即程序执行的顺序按照代码的先后顺序执行。\n\n**有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。**所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。\n\n### 什么是内存模型\n前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？\n\n最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。\n\n**所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。**\n为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。\n\n内存模型解决并发问题主要采用两种方式：**限制处理器优化和使用内存屏障。**本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。\n\n### 什么是Java内存模型\n前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。\n\n我们知道，Java程序是需要运行在Java虚拟机上面的，**Java内存模型（Java Memory Model ,JMM）**就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。\n\n提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）\n\nJava内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。\n\n而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。\n\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg)\n\n\n这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。\n\n所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。\n\n### Java内存模型的实现\n了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如**volatile、synchronized、final、concurren**包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。\n\n在开发多线程的代码的时候，我们可以直接使用`synchronized`等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。\n\n本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，**并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证:**\n\n#### 原子性\n在Java中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。这两个字节码，在Java中对应的关键字就是`synchronized`。\n\n因此，在Java中可以使用`synchronized`来保证方法和代码块内的操作是原子性的。\n\n#### 可见性\n**Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。**\n\nJava中的`volatile`关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性。\n\n除了`volatile`，Java中的`synchronized`和`final`两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。\n\n#### 有序性\n在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：\n\n**`volatile`关键字会禁止指令重排。**`synchronized`关键字保证同一时刻只允许**一条线程**操作。\n\n好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。\n\n**但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。**\n\n总结\n在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。\n\n可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。","slug":"WhyhasJMMexit-1552272874543","published":1,"updated":"2019-03-11T02:56:55.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt3rajjl0000tc9zztbsiab3","content":"<h1 id=\"为什么要有Java内存模型\"><a href=\"#为什么要有Java内存模型\" class=\"headerlink\" title=\"为什么要有Java内存模型?\"></a>为什么要有Java内存模型?</h1><p>Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。</p>\n<p>网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。</p>\n<h2 id=\"为什么要有内存模型\"><a href=\"#为什么要有内存模型\" class=\"headerlink\" title=\"为什么要有内存模型\"></a>为什么要有内存模型</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p>\n<p><strong>内存模型，英文名Memory Model</strong>，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</p>\n<h3 id=\"CPU和缓存一致性\"><a href=\"#CPU和缓存一致性\" class=\"headerlink\" title=\"CPU和缓存一致性\"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p>\n<p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p>\n<blockquote>\n<p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p>\n</blockquote>\n<p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p>\n<p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加<strong>高速缓存</strong>。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是<strong>速度快，内存小，并且昂贵</strong>。</p>\n<p>那么，程序的执行过程就变成了：</p>\n<p>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的<strong>高速缓存</strong>当中，那么CPU进行计算时就可以直接从它的<strong>高速缓存读取数据和向其中写入数据</strong>，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>\n<blockquote>\n<p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p>\n</blockquote>\n<p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p>\n<p>按照数据读取顺序和与CPU结合的紧密程度，<strong>CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3）</strong>，每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p>\n<p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p>\n<p>那么，在有了多级缓存之后，程序的执行就变成了：</p>\n<p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</p>\n<blockquote>\n<p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p>\n</blockquote>\n<p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p>\n<blockquote>\n<p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p>\n</blockquote>\n<blockquote>\n<p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p>\n</blockquote>\n<blockquote>\n<p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p>\n</blockquote>\n<blockquote>\n<p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p>\n</blockquote>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0ynd4vsasj30fg0bi0tg.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p>\n<p>单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p>\n<p>单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p>\n<p>多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。<strong>由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</strong></p>\n<p><strong>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</strong></p>\n<p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p>\n<p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p>\n<p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p>\n<blockquote>\n<p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p>\n</blockquote>\n<p><img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0ynvitf1ij30kl0b7mxv.jpg\" alt=\"\"></p>\n<h3 id=\"处理器优化和指令重排\"><a href=\"#处理器优化和指令重排\" class=\"headerlink\" title=\"处理器优化和指令重排\"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。</p>\n<p>除了现在很多流行的<strong>处理器会对代码进行优化乱序处理</strong>，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时<strong>编译器（JIT）也会做指令重排</strong>。</p>\n<p><strong>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</strong></p>\n<blockquote>\n<p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p>\n</blockquote>\n<h2 id=\"并发编程的问题\"><a href=\"#并发编程的问题\" class=\"headerlink\" title=\"并发编程的问题\"></a>并发编程的问题</h2><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p>\n<p>其实，<strong>原子性问题，可见性问题和有序性问题</strong>。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p>\n<p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p>\n<ol>\n<li><p><strong>原子性:</strong>指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>\n</li>\n<li><p><strong>可见性:</strong>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n</li>\n<li><p><strong>有序性:</strong>即程序执行的顺序按照代码的先后顺序执行。</p>\n</li>\n</ol>\n<p><strong>有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。</strong>所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p>\n<h3 id=\"什么是内存模型\"><a href=\"#什么是内存模型\" class=\"headerlink\" title=\"什么是内存模型\"></a>什么是内存模型</h3><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p>\n<p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p>\n<p><strong>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</strong><br>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>\n<p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化和使用内存屏障。</strong>本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p>\n<h3 id=\"什么是Java内存模型\"><a href=\"#什么是Java内存模型\" class=\"headerlink\" title=\"什么是Java内存模型\"></a>什么是Java内存模型</h3><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p>\n<p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）</strong>就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>\n<p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）\" target=\"_blank\" rel=\"noopener\">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）</a></p>\n<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>\n<p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg\" alt=\"\"></p>\n<p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p>\n<p>所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</p>\n<h3 id=\"Java内存模型的实现\"><a href=\"#Java内存模型的实现\" class=\"headerlink\" title=\"Java内存模型的实现\"></a>Java内存模型的实现</h3><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如<strong>volatile、synchronized、final、concurren</strong>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p>\n<p>在开发多线程的代码的时候，我们可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p>\n<p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，<strong>并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证:</strong></p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p>\n<p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><p><strong>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</strong></p>\n<p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p>\n<p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p>\n<p><strong><code>volatile</code>关键字会禁止指令重排。</strong><code>synchronized</code>关键字保证同一时刻只允许<strong>一条线程</strong>操作。</p>\n<p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。</p>\n<p><strong>但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</strong></p>\n<p>总结<br>在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。</p>\n<p>可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要有Java内存模型\"><a href=\"#为什么要有Java内存模型\" class=\"headerlink\" title=\"为什么要有Java内存模型?\"></a>为什么要有Java内存模型?</h1><p>Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。</p>\n<p>网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。</p>\n<h2 id=\"为什么要有内存模型\"><a href=\"#为什么要有内存模型\" class=\"headerlink\" title=\"为什么要有内存模型\"></a>为什么要有内存模型</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p>\n<p><strong>内存模型，英文名Memory Model</strong>，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</p>\n<h3 id=\"CPU和缓存一致性\"><a href=\"#CPU和缓存一致性\" class=\"headerlink\" title=\"CPU和缓存一致性\"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p>\n<p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p>\n<blockquote>\n<p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p>\n</blockquote>\n<p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p>\n<p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加<strong>高速缓存</strong>。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是<strong>速度快，内存小，并且昂贵</strong>。</p>\n<p>那么，程序的执行过程就变成了：</p>\n<p>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的<strong>高速缓存</strong>当中，那么CPU进行计算时就可以直接从它的<strong>高速缓存读取数据和向其中写入数据</strong>，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>\n<blockquote>\n<p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p>\n</blockquote>\n<p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p>\n<p>按照数据读取顺序和与CPU结合的紧密程度，<strong>CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3）</strong>，每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p>\n<p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p>\n<p>那么，在有了多级缓存之后，程序的执行就变成了：</p>\n<p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</p>\n<blockquote>\n<p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p>\n</blockquote>\n<p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p>\n<blockquote>\n<p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p>\n</blockquote>\n<blockquote>\n<p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p>\n</blockquote>\n<blockquote>\n<p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p>\n</blockquote>\n<blockquote>\n<p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p>\n</blockquote>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0ynd4vsasj30fg0bi0tg.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p>\n<p>单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p>\n<p>单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p>\n<p>多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。<strong>由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</strong></p>\n<p><strong>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</strong></p>\n<p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p>\n<p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p>\n<p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p>\n<blockquote>\n<p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p>\n</blockquote>\n<p><img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0ynvitf1ij30kl0b7mxv.jpg\" alt=\"\"></p>\n<h3 id=\"处理器优化和指令重排\"><a href=\"#处理器优化和指令重排\" class=\"headerlink\" title=\"处理器优化和指令重排\"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。</p>\n<p>除了现在很多流行的<strong>处理器会对代码进行优化乱序处理</strong>，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时<strong>编译器（JIT）也会做指令重排</strong>。</p>\n<p><strong>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</strong></p>\n<blockquote>\n<p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p>\n</blockquote>\n<h2 id=\"并发编程的问题\"><a href=\"#并发编程的问题\" class=\"headerlink\" title=\"并发编程的问题\"></a>并发编程的问题</h2><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p>\n<p>其实，<strong>原子性问题，可见性问题和有序性问题</strong>。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p>\n<p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p>\n<ol>\n<li><p><strong>原子性:</strong>指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>\n</li>\n<li><p><strong>可见性:</strong>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n</li>\n<li><p><strong>有序性:</strong>即程序执行的顺序按照代码的先后顺序执行。</p>\n</li>\n</ol>\n<p><strong>有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。</strong>所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p>\n<h3 id=\"什么是内存模型\"><a href=\"#什么是内存模型\" class=\"headerlink\" title=\"什么是内存模型\"></a>什么是内存模型</h3><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p>\n<p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p>\n<p><strong>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</strong><br>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>\n<p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化和使用内存屏障。</strong>本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p>\n<h3 id=\"什么是Java内存模型\"><a href=\"#什么是Java内存模型\" class=\"headerlink\" title=\"什么是Java内存模型\"></a>什么是Java内存模型</h3><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p>\n<p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）</strong>就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>\n<p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）\" target=\"_blank\" rel=\"noopener\">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）</a></p>\n<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>\n<p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g0vi2ulxltj30br0ahwes.jpg\" alt=\"\"></p>\n<p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p>\n<p>所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</p>\n<h3 id=\"Java内存模型的实现\"><a href=\"#Java内存模型的实现\" class=\"headerlink\" title=\"Java内存模型的实现\"></a>Java内存模型的实现</h3><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如<strong>volatile、synchronized、final、concurren</strong>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p>\n<p>在开发多线程的代码的时候，我们可以直接使用<code>synchronized</code>等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p>\n<p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，<strong>并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证:</strong></p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><p>在Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。这两个字节码，在Java中对应的关键字就是<code>synchronized</code>。</p>\n<p>因此，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><p><strong>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</strong></p>\n<p>Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。</p>\n<p>除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><p>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。实现方式有所区别：</p>\n<p><strong><code>volatile</code>关键字会禁止指令重排。</strong><code>synchronized</code>关键字保证同一时刻只允许<strong>一条线程</strong>操作。</p>\n<p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。</p>\n<p><strong>但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</strong></p>\n<p>总结<br>在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。</p>\n<p>可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。</p>\n"},{"title":"#系统源码解读:深入理解DecorView与ViewRootImpl","date":"2019-03-13T12:39:32.000Z","_content":"\n\n# 系统源码解读:深入理解DecorView与ViewRootImpl\n\n## 前言\n对于Android开发者来说，View无疑是开发中经常接触的，**包括它的事件分发机制、测量、布局、绘制流程等**，如果要自定义一个View，那么应该对以上流程有所了解、研究。本系列文章将会为大家带来View的工作流程详细解析。在深入接触View的测量、布局、绘制这三个流程之前，我们从Activity入手，看看从Activity创建后到View的正式工作之前，所要经历的步骤。以下源码均取自Android API 21。\n<!--more-->\n## setContentView\n从`setContentView`说起\n一般地，我们在`Activity`中，会在`onCreate()`方法中写下这样一句：\n\n```JAVA\nsetContentView(R.layout.main);\n```\n\n显然，这是为`activity`设置一个我们定义好的main.xml布局，我们跟踪一下源码，看看这个方法是怎样做的，`Activity`的`setContentView()`:\n\n```JAVA\npublic void setContentView(@LayoutRes int layoutResID) {\n     getWindow().setContentView(layoutResID);  //调用getWindow方法，返回mWindow\n     initWindowDecorActionBar();\n}\n...\npublic Window getWindow() {   \n     return mWindow;\n}\n```\n\n从上面看出，里面调用了`mWindow`的`setContentView`方法，那么这个**“mWindow”**是何方神圣呢？尝试追踪一下源码，发现`mWindow`是`Window`类型的，但是它是一个抽象类，`setContentView`也是抽象方法，所以我们要找到Window类的实现类才行。我们在Activity中查找一下mWindow在哪里被赋值了，可以发现它在Activity#attach方法中有如下实现：\n\n```JAVA\n final void attach(Context context, ActivityThread aThread,\n            Instrumentation instr, IBinder token, int ident,\n            Application application, Intent intent, ActivityInfo info,\n            CharSequence title, Activity parent, String id,\n            NonConfigurationInstances lastNonConfigurationInstances,\n            Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n            Window window) {\n    ...\n        mWindow = new PhoneWindow(this, window);//创建一个Window对象\n        mWindow.setWindowControllerCallback(this);\n        mWindow.setCallback(this);//设置回调，向Activity分发点击或状态改变等事件\n        mWindow.setOnWindowDismissedCallback(this);\n     ...\n        mWindow.setWindowManager(\n                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),\n                mToken, mComponent.flattenToString(),\n                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//给Window设置WindowManager对象\n ...\n    }\n```\n我们只看关键部分，这里实例化了`PhoneWindow`类，由此得知，`PhoneWindow`是`Window`的实现类，那么我们在`PhoneWindow`类里面找到它的`setContentView`方法，看看它又实现了什么，`PhoneWindow`的`setContentView`:\n\n```JAVA\n@Override\npublic void setContentView(int layoutResID) {\n    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window\n    // decor, when theme attributes and the like are crystalized. Do not check the feature\n    // before this happens.\n    if (mContentParent == null) { // 1\n        installDecor();//mContentParent为空，创建一个DecroView\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        mContentParent.removeAllViews();//mContentParent不为空，删除其中的View\n    }\n\n    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                getContext());\n        transitionTo(newScene);\n    } else {\n        mLayoutInflater.inflate(layoutResID, mContentParent); //为mContentParent添加子View,即Activity中设置的布局文件\n    }\n    final Callback cb = getCallback();\n    if (cb != null && !isDestroyed()) {\n        cb.onContentChanged();//回调通知，内容改变\n    }\n}\n```\n\n首先判断了`mContentParent`是否为`null`，如果为空则执行`installDecor()`方法，那么这个`mContentParent`又是什么呢？我们看一下它的注释：\n\n```\n// This is the view in which the window contents are placed. It is either\n// mDecor itself, or a child of mDecor where the contents go.\nprivate ViewGroup mContentParent;\n```\n\n它是一个`ViewGroup`类型，结合2的代码处得知,这个`mContentParent`是我们设置的布局(即main.xml)的父布局。注释还提到了，这个`mContentParent`是`mDecor`本身或者是`mDecor`的一个子元素，这句话什么意思呢？这里先留一个疑问，下面会解释。\n\n这里先梳理一下以上的内容：**通过上面的流程我们大致可以了解先在`PhoneWindow`中创建了一个`DecroView`，其中创建的过程中可能根据`Theme`不同，加载不同的布局格式，例如有没有Title，或有没有`ActionBar`等，然后再向`mContentParent`中加入子View,即Activity中设置的布局。到此位置，视图一层层嵌套添加上了。**\n\n## 创建DecorView\n接着上面提到的`installDecor()`方法，我们看看它的源码，**PhoneWindow#installDecor:**\n\n```JAVA\nprivate void installDecor() {\n    if (mDecor == null) {\n        mDecor = generateDecor(); // 1 生成DecorView\n        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n        mDecor.setIsRootNamespace(true);\n        if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n        }\n    }\n    if (mContentParent == null) {\n        mContentParent = generateLayout(mDecor); // 2 为DecorView设置布局格式，并返回mContentParent\n        ...\n        } \n    }\n}\n```\n\n首先，会执行1的代码，调用`PhoneWindow#generateDecor`方法：\n\n```JAVA\nprotected DecorView generateDecor() {\n    return new DecorView(getContext(), -1);\n}\n```\n\n可以看出，这里实例化了`DecorView`，而`DecorView`则是`PhoneWindow`类的一个内部类，继承于`FrameLayout`，由此可知它也是一个`ViewGroup`。 \n那么，DecroView到底充当了什么样的角色呢？ \n其实，`DecorView`是整个`ViewTree`的最顶层`View`，它是一个`FrameLayout`布局，代表了整个应用的界面。在该布局下面，**有标题view和内容view这两个子元素**，而内容view则是上面提到的mContentParent。\n\n我们接着看2处的代码，**PhoneWindow#generateLayout方法**:\n\n\n```JAVA\nprotected ViewGroup generateLayout(DecorView decor) {\n        // Apply data from current theme.\n        // 从主题文件中获取样式信息\n        TypedArray a = getWindowStyle();\n\n        ...\n\n        if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) {\n            requestFeature(FEATURE_NO_TITLE);\n        } else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) {\n            // Don't allow an action bar if there is no title.\n            requestFeature(FEATURE_ACTION_BAR);\n        }\n\n        if(...){\n            ...\n        }\n\n        // Inflate the window decor.\n        // 根据主题样式，加载窗口布局\n        int layoutResource;\n        int features = getLocalFeatures();\n        // System.out.println(\"Features: 0x\" + Integer.toHexString(features));\n        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n            layoutResource = R.layout.screen_swipe_dismiss;\n        } else if(...){\n            ...\n        }\n\n        View in = mLayoutInflater.inflate(layoutResource, null);    //加载layoutResource\n        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); //往DecorView中添加子View，即mContentParent\n        mContentRoot = (ViewGroup) in;\n\n        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); // 这里获取的就是mContentParent  @android:id/content\n        if (contentParent == null) {\n            throw new RuntimeException(\"Window couldn't find content container view\");\n        }\n\n        if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n            ProgressBar progress = getCircularProgressBar(false);\n            if (progress != null) {\n                progress.setIndeterminate(true);\n            }\n        }\n\n        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n            registerSwipeCallbacks();\n        }\n\n        // Remaining setup -- of background and title -- that only applies\n        // to top-level windows.\n        ...\n\n        return contentParent;\n    }\n```\n\n由以上代码可以看出，该方法还是做了相当多的工作的，首先根据设置的主题样式来设置`DecorView`的风格，比如说有没有`titlebar`之类的，接着为`DecorView`添加子`View`，而这里的子`View`则是上面提到的`mContentParent`，如果上面设置了`FEATURE_NO_ACTIONBAR`，那么`DecorView`就只有`mContentParent`一个子`View`，这也解释了上面的疑问：`mContentParent`是`DecorView`本身或者是`DecorView`的一个子元素。 \n用一幅图来表示DecorView的结构如下：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g11ffv2vb6j30er0gjgn9.jpg)\n\n**小结：** `DecorView`是顶级`View`，内部有`titlebar`和`contentParent`两个子元素，c`ontentParent`的`id`是`content`，而我们设置的`main.xml`布局则是`contentParent`里面的一个子元素。\n\n在`DecorView`创建完毕后，让我们回到P`honeWindow#setContentView`方法，直接看2处代码： `mLayoutInflater.inflate(layoutResID, mContentParent)`;这里加载了我们设置的`main.xml`布局文件，并且设置`mContentParent`为main.xml的父布局，至于它怎么加载的，这里就不展开来说了。\n\n到目前为止，通过`setContentView`方法，创建了`DecorView`和加载了我们提供的布局，但是这时，**我们的View还是不可见的**，因为我们仅仅是加载了布局，并没有对View进行任何的**测量、布局、绘制**工作。在View进行测量流程之前，还要进行一个步骤，那就是把`DecorView`添加至`window`中，然后经过一系列过程触发`ViewRootImpl#performTraversals`方法，在该方法内部会正式开始测量、布局、绘制这三大流程。至于该一系列过程是怎样的，因为涉及到了很多机制，这里简单说明一下：\n\n## 将DecorView添加至Window\n\n每一个`Activity`组件都有一个关联的`Window`对象，用来描述一个应用程序窗口。每一个应用程序窗口内部又包含有一个`View`对象，用来描述应用程序窗口的视图。上文分析了创建`DecorView`的过程，现在则要把`DecorVie`w添加到`Window`对象中。而要了解这个过程，我们首先要简单先了解一下`Activity`的创建过程： \n首先，在`ActivityThread`#`handleLaunchActivity`中启动`Activity`，在这里面会调用到`Activity`#`onCreate`方法，从而完成上面所述的`DecorView`创建动作，当o`nCreate()`方法执行完毕，在`handleLaunchActivity`方法会继续调用到\n`ActivityThread#handleResumeActivity`方法，我们看看这个方法的源码：\n\n```JAVA\nfinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) { \n    //...\n    ActivityClientRecord r = performResumeActivity(token, clearHide); // 这里会调用到onResume()方法\n\n    if (r != null) {\n        final Activity a = r.activity;\n\n        //...\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow(); // 获得window对象\n            View decor = r.window.getDecorView(); // 获得DecorView对象\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager(); // 获得windowManager对象\n            WindowManager.LayoutParams l = r.window.getAttributes();\n            a.mDecor = decor;\n            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n            l.softInputMode |= forwardBit;\n            if (a.mVisibleFromClient) {\n                a.mWindowAdded = true;\n                wm.addView(decor, l); // 调用addView方法\n            }\n            //...\n        }\n    }\n}\n```\n在该方法内部，获取该`activity`所关联的`window`对象，`DecorView`对象，以及`WindowManager`对象，而`WindowManager`是抽象类，它的实现类是`WindowManagerImpl`，所以后面调用的是\n`WindowManagerImpl#addView方法`，我们看看源码：\n\n```JAVA\npublic final class WindowManagerImpl implements WindowManager {    \n    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();\n    ...\n    @Override\n    public void addView(View view, ViewGroup.LayoutParams params) {\n        mGlobal.addView(view, params, mDisplay, mParentWindow);\n    }\n}\n```\n\n接着调用了`mGlobal`的成员函数，而`mGlobal`则是`WindowManagerGlobal`的一个实例，那么我们接着看\n`WindowManagerGlobal#addView`方法：\n\n\n```JAVA\npublic void addView(View view, ViewGroup.LayoutParams params,\n            Display display, Window parentWindow) {\n        ...\n\n        ViewRootImpl root;\n        View panelParentView = null;\n\n        synchronized (mLock) {\n            ...\n\n            root = new ViewRootImpl(view.getContext(), display); // 1\n\n            view.setLayoutParams(wparams);\n\n            mViews.add(view);\n            mRoots.add(root);\n            mParams.add(wparams);\n        }\n\n        // do this last because it fires off messages to start doing things\n        try {\n            root.setView(view, wparams, panelParentView); // 2\n        } catch (RuntimeException e) {\n            // BadTokenException or InvalidDisplayException, clean up.\n            synchronized (mLock) {\n                final int index = findViewLocked(view, false);\n                if (index >= 0) {\n                    removeViewLocked(index, true);\n                }\n            }\n            throw e;\n        }\n    }\n```\n\n先看1号代码处，实例化了`ViewRootImpl`类，接着，在2号代码处，调用`ViewRootImpl#setView`方法，并把`DecorView`作为参数传递进去，在这个方法内部，会通过跨进程的方式向`WMS（WindowManagerService）`发起一个调用，从而将`DecorView`最终添加到`Window`上，在这个过程中，ViewRootImpl、DecorView和WMS会彼此关联，至于详细过程这里不展开来说了。 \n最后通过`WMS`调用`ViewRootImpl#performTraverals`方法,然后依照下图流程层层调用，完成绘制，最终界面才显示出来,下偏文章讲View的绘制.\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g11g5op2u0j30iv0c0juh.jpg)\n\n\n\n","source":"_posts/DecorViewAndViewRootImpl-1552480772465.md","raw":"---\ntitle: '#系统源码解读:深入理解DecorView与ViewRootImpl'\ntags: [Android源码解析,DecorView,ViewRootImpl]\ncategories:\n  - Android\ndate: 2019-03-13 20:39:32\n---\n\n\n# 系统源码解读:深入理解DecorView与ViewRootImpl\n\n## 前言\n对于Android开发者来说，View无疑是开发中经常接触的，**包括它的事件分发机制、测量、布局、绘制流程等**，如果要自定义一个View，那么应该对以上流程有所了解、研究。本系列文章将会为大家带来View的工作流程详细解析。在深入接触View的测量、布局、绘制这三个流程之前，我们从Activity入手，看看从Activity创建后到View的正式工作之前，所要经历的步骤。以下源码均取自Android API 21。\n<!--more-->\n## setContentView\n从`setContentView`说起\n一般地，我们在`Activity`中，会在`onCreate()`方法中写下这样一句：\n\n```JAVA\nsetContentView(R.layout.main);\n```\n\n显然，这是为`activity`设置一个我们定义好的main.xml布局，我们跟踪一下源码，看看这个方法是怎样做的，`Activity`的`setContentView()`:\n\n```JAVA\npublic void setContentView(@LayoutRes int layoutResID) {\n     getWindow().setContentView(layoutResID);  //调用getWindow方法，返回mWindow\n     initWindowDecorActionBar();\n}\n...\npublic Window getWindow() {   \n     return mWindow;\n}\n```\n\n从上面看出，里面调用了`mWindow`的`setContentView`方法，那么这个**“mWindow”**是何方神圣呢？尝试追踪一下源码，发现`mWindow`是`Window`类型的，但是它是一个抽象类，`setContentView`也是抽象方法，所以我们要找到Window类的实现类才行。我们在Activity中查找一下mWindow在哪里被赋值了，可以发现它在Activity#attach方法中有如下实现：\n\n```JAVA\n final void attach(Context context, ActivityThread aThread,\n            Instrumentation instr, IBinder token, int ident,\n            Application application, Intent intent, ActivityInfo info,\n            CharSequence title, Activity parent, String id,\n            NonConfigurationInstances lastNonConfigurationInstances,\n            Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n            Window window) {\n    ...\n        mWindow = new PhoneWindow(this, window);//创建一个Window对象\n        mWindow.setWindowControllerCallback(this);\n        mWindow.setCallback(this);//设置回调，向Activity分发点击或状态改变等事件\n        mWindow.setOnWindowDismissedCallback(this);\n     ...\n        mWindow.setWindowManager(\n                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),\n                mToken, mComponent.flattenToString(),\n                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//给Window设置WindowManager对象\n ...\n    }\n```\n我们只看关键部分，这里实例化了`PhoneWindow`类，由此得知，`PhoneWindow`是`Window`的实现类，那么我们在`PhoneWindow`类里面找到它的`setContentView`方法，看看它又实现了什么，`PhoneWindow`的`setContentView`:\n\n```JAVA\n@Override\npublic void setContentView(int layoutResID) {\n    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window\n    // decor, when theme attributes and the like are crystalized. Do not check the feature\n    // before this happens.\n    if (mContentParent == null) { // 1\n        installDecor();//mContentParent为空，创建一个DecroView\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        mContentParent.removeAllViews();//mContentParent不为空，删除其中的View\n    }\n\n    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                getContext());\n        transitionTo(newScene);\n    } else {\n        mLayoutInflater.inflate(layoutResID, mContentParent); //为mContentParent添加子View,即Activity中设置的布局文件\n    }\n    final Callback cb = getCallback();\n    if (cb != null && !isDestroyed()) {\n        cb.onContentChanged();//回调通知，内容改变\n    }\n}\n```\n\n首先判断了`mContentParent`是否为`null`，如果为空则执行`installDecor()`方法，那么这个`mContentParent`又是什么呢？我们看一下它的注释：\n\n```\n// This is the view in which the window contents are placed. It is either\n// mDecor itself, or a child of mDecor where the contents go.\nprivate ViewGroup mContentParent;\n```\n\n它是一个`ViewGroup`类型，结合2的代码处得知,这个`mContentParent`是我们设置的布局(即main.xml)的父布局。注释还提到了，这个`mContentParent`是`mDecor`本身或者是`mDecor`的一个子元素，这句话什么意思呢？这里先留一个疑问，下面会解释。\n\n这里先梳理一下以上的内容：**通过上面的流程我们大致可以了解先在`PhoneWindow`中创建了一个`DecroView`，其中创建的过程中可能根据`Theme`不同，加载不同的布局格式，例如有没有Title，或有没有`ActionBar`等，然后再向`mContentParent`中加入子View,即Activity中设置的布局。到此位置，视图一层层嵌套添加上了。**\n\n## 创建DecorView\n接着上面提到的`installDecor()`方法，我们看看它的源码，**PhoneWindow#installDecor:**\n\n```JAVA\nprivate void installDecor() {\n    if (mDecor == null) {\n        mDecor = generateDecor(); // 1 生成DecorView\n        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n        mDecor.setIsRootNamespace(true);\n        if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n        }\n    }\n    if (mContentParent == null) {\n        mContentParent = generateLayout(mDecor); // 2 为DecorView设置布局格式，并返回mContentParent\n        ...\n        } \n    }\n}\n```\n\n首先，会执行1的代码，调用`PhoneWindow#generateDecor`方法：\n\n```JAVA\nprotected DecorView generateDecor() {\n    return new DecorView(getContext(), -1);\n}\n```\n\n可以看出，这里实例化了`DecorView`，而`DecorView`则是`PhoneWindow`类的一个内部类，继承于`FrameLayout`，由此可知它也是一个`ViewGroup`。 \n那么，DecroView到底充当了什么样的角色呢？ \n其实，`DecorView`是整个`ViewTree`的最顶层`View`，它是一个`FrameLayout`布局，代表了整个应用的界面。在该布局下面，**有标题view和内容view这两个子元素**，而内容view则是上面提到的mContentParent。\n\n我们接着看2处的代码，**PhoneWindow#generateLayout方法**:\n\n\n```JAVA\nprotected ViewGroup generateLayout(DecorView decor) {\n        // Apply data from current theme.\n        // 从主题文件中获取样式信息\n        TypedArray a = getWindowStyle();\n\n        ...\n\n        if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) {\n            requestFeature(FEATURE_NO_TITLE);\n        } else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) {\n            // Don't allow an action bar if there is no title.\n            requestFeature(FEATURE_ACTION_BAR);\n        }\n\n        if(...){\n            ...\n        }\n\n        // Inflate the window decor.\n        // 根据主题样式，加载窗口布局\n        int layoutResource;\n        int features = getLocalFeatures();\n        // System.out.println(\"Features: 0x\" + Integer.toHexString(features));\n        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n            layoutResource = R.layout.screen_swipe_dismiss;\n        } else if(...){\n            ...\n        }\n\n        View in = mLayoutInflater.inflate(layoutResource, null);    //加载layoutResource\n        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); //往DecorView中添加子View，即mContentParent\n        mContentRoot = (ViewGroup) in;\n\n        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); // 这里获取的就是mContentParent  @android:id/content\n        if (contentParent == null) {\n            throw new RuntimeException(\"Window couldn't find content container view\");\n        }\n\n        if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n            ProgressBar progress = getCircularProgressBar(false);\n            if (progress != null) {\n                progress.setIndeterminate(true);\n            }\n        }\n\n        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {\n            registerSwipeCallbacks();\n        }\n\n        // Remaining setup -- of background and title -- that only applies\n        // to top-level windows.\n        ...\n\n        return contentParent;\n    }\n```\n\n由以上代码可以看出，该方法还是做了相当多的工作的，首先根据设置的主题样式来设置`DecorView`的风格，比如说有没有`titlebar`之类的，接着为`DecorView`添加子`View`，而这里的子`View`则是上面提到的`mContentParent`，如果上面设置了`FEATURE_NO_ACTIONBAR`，那么`DecorView`就只有`mContentParent`一个子`View`，这也解释了上面的疑问：`mContentParent`是`DecorView`本身或者是`DecorView`的一个子元素。 \n用一幅图来表示DecorView的结构如下：\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g11ffv2vb6j30er0gjgn9.jpg)\n\n**小结：** `DecorView`是顶级`View`，内部有`titlebar`和`contentParent`两个子元素，c`ontentParent`的`id`是`content`，而我们设置的`main.xml`布局则是`contentParent`里面的一个子元素。\n\n在`DecorView`创建完毕后，让我们回到P`honeWindow#setContentView`方法，直接看2处代码： `mLayoutInflater.inflate(layoutResID, mContentParent)`;这里加载了我们设置的`main.xml`布局文件，并且设置`mContentParent`为main.xml的父布局，至于它怎么加载的，这里就不展开来说了。\n\n到目前为止，通过`setContentView`方法，创建了`DecorView`和加载了我们提供的布局，但是这时，**我们的View还是不可见的**，因为我们仅仅是加载了布局，并没有对View进行任何的**测量、布局、绘制**工作。在View进行测量流程之前，还要进行一个步骤，那就是把`DecorView`添加至`window`中，然后经过一系列过程触发`ViewRootImpl#performTraversals`方法，在该方法内部会正式开始测量、布局、绘制这三大流程。至于该一系列过程是怎样的，因为涉及到了很多机制，这里简单说明一下：\n\n## 将DecorView添加至Window\n\n每一个`Activity`组件都有一个关联的`Window`对象，用来描述一个应用程序窗口。每一个应用程序窗口内部又包含有一个`View`对象，用来描述应用程序窗口的视图。上文分析了创建`DecorView`的过程，现在则要把`DecorVie`w添加到`Window`对象中。而要了解这个过程，我们首先要简单先了解一下`Activity`的创建过程： \n首先，在`ActivityThread`#`handleLaunchActivity`中启动`Activity`，在这里面会调用到`Activity`#`onCreate`方法，从而完成上面所述的`DecorView`创建动作，当o`nCreate()`方法执行完毕，在`handleLaunchActivity`方法会继续调用到\n`ActivityThread#handleResumeActivity`方法，我们看看这个方法的源码：\n\n```JAVA\nfinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) { \n    //...\n    ActivityClientRecord r = performResumeActivity(token, clearHide); // 这里会调用到onResume()方法\n\n    if (r != null) {\n        final Activity a = r.activity;\n\n        //...\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow(); // 获得window对象\n            View decor = r.window.getDecorView(); // 获得DecorView对象\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager(); // 获得windowManager对象\n            WindowManager.LayoutParams l = r.window.getAttributes();\n            a.mDecor = decor;\n            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n            l.softInputMode |= forwardBit;\n            if (a.mVisibleFromClient) {\n                a.mWindowAdded = true;\n                wm.addView(decor, l); // 调用addView方法\n            }\n            //...\n        }\n    }\n}\n```\n在该方法内部，获取该`activity`所关联的`window`对象，`DecorView`对象，以及`WindowManager`对象，而`WindowManager`是抽象类，它的实现类是`WindowManagerImpl`，所以后面调用的是\n`WindowManagerImpl#addView方法`，我们看看源码：\n\n```JAVA\npublic final class WindowManagerImpl implements WindowManager {    \n    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();\n    ...\n    @Override\n    public void addView(View view, ViewGroup.LayoutParams params) {\n        mGlobal.addView(view, params, mDisplay, mParentWindow);\n    }\n}\n```\n\n接着调用了`mGlobal`的成员函数，而`mGlobal`则是`WindowManagerGlobal`的一个实例，那么我们接着看\n`WindowManagerGlobal#addView`方法：\n\n\n```JAVA\npublic void addView(View view, ViewGroup.LayoutParams params,\n            Display display, Window parentWindow) {\n        ...\n\n        ViewRootImpl root;\n        View panelParentView = null;\n\n        synchronized (mLock) {\n            ...\n\n            root = new ViewRootImpl(view.getContext(), display); // 1\n\n            view.setLayoutParams(wparams);\n\n            mViews.add(view);\n            mRoots.add(root);\n            mParams.add(wparams);\n        }\n\n        // do this last because it fires off messages to start doing things\n        try {\n            root.setView(view, wparams, panelParentView); // 2\n        } catch (RuntimeException e) {\n            // BadTokenException or InvalidDisplayException, clean up.\n            synchronized (mLock) {\n                final int index = findViewLocked(view, false);\n                if (index >= 0) {\n                    removeViewLocked(index, true);\n                }\n            }\n            throw e;\n        }\n    }\n```\n\n先看1号代码处，实例化了`ViewRootImpl`类，接着，在2号代码处，调用`ViewRootImpl#setView`方法，并把`DecorView`作为参数传递进去，在这个方法内部，会通过跨进程的方式向`WMS（WindowManagerService）`发起一个调用，从而将`DecorView`最终添加到`Window`上，在这个过程中，ViewRootImpl、DecorView和WMS会彼此关联，至于详细过程这里不展开来说了。 \n最后通过`WMS`调用`ViewRootImpl#performTraverals`方法,然后依照下图流程层层调用，完成绘制，最终界面才显示出来,下偏文章讲View的绘制.\n\n![](https://ws1.sinaimg.cn/large/007lnl1egy1g11g5op2u0j30iv0c0juh.jpg)\n\n\n\n","slug":"DecorViewAndViewRootImpl-1552480772465","published":1,"updated":"2019-03-13T12:42:38.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt7736n30000yann7euwzfot","content":"<h1 id=\"系统源码解读-深入理解DecorView与ViewRootImpl\"><a href=\"#系统源码解读-深入理解DecorView与ViewRootImpl\" class=\"headerlink\" title=\"系统源码解读:深入理解DecorView与ViewRootImpl\"></a>系统源码解读:深入理解DecorView与ViewRootImpl</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于Android开发者来说，View无疑是开发中经常接触的，<strong>包括它的事件分发机制、测量、布局、绘制流程等</strong>，如果要自定义一个View，那么应该对以上流程有所了解、研究。本系列文章将会为大家带来View的工作流程详细解析。在深入接触View的测量、布局、绘制这三个流程之前，我们从Activity入手，看看从Activity创建后到View的正式工作之前，所要经历的步骤。以下源码均取自Android API 21。<br><a id=\"more\"></a></p>\n<h2 id=\"setContentView\"><a href=\"#setContentView\" class=\"headerlink\" title=\"setContentView\"></a>setContentView</h2><p>从<code>setContentView</code>说起<br>一般地，我们在<code>Activity</code>中，会在<code>onCreate()</code>方法中写下这样一句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>\n<p>显然，这是为<code>activity</code>设置一个我们定义好的main.xml布局，我们跟踪一下源码，看看这个方法是怎样做的，<code>Activity</code>的<code>setContentView()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">     getWindow().setContentView(layoutResID);  <span class=\"comment\">//调用getWindow方法，返回mWindow</span></span><br><span class=\"line\">     initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Window <span class=\"title\">getWindow</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">     <span class=\"keyword\">return</span> mWindow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面看出，里面调用了<code>mWindow</code>的<code>setContentView</code>方法，那么这个<strong>“mWindow”</strong>是何方神圣呢？尝试追踪一下源码，发现<code>mWindow</code>是<code>Window</code>类型的，但是它是一个抽象类，<code>setContentView</code>也是抽象方法，所以我们要找到Window类的实现类才行。我们在Activity中查找一下mWindow在哪里被赋值了，可以发现它在Activity#attach方法中有如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           CharSequence title, Activity parent, String id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Window window)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">       mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>, window);<span class=\"comment\">//创建一个Window对象</span></span><br><span class=\"line\">       mWindow.setWindowControllerCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">       mWindow.setCallback(<span class=\"keyword\">this</span>);<span class=\"comment\">//设置回调，向Activity分发点击或状态改变等事件</span></span><br><span class=\"line\">       mWindow.setOnWindowDismissedCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">       mWindow.setWindowManager(</span><br><span class=\"line\">               (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class=\"line\">               mToken, mComponent.flattenToString(),</span><br><span class=\"line\">               (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class=\"number\">0</span>);<span class=\"comment\">//给Window设置WindowManager对象</span></span><br><span class=\"line\">...</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我们只看关键部分，这里实例化了<code>PhoneWindow</code>类，由此得知，<code>PhoneWindow</code>是<code>Window</code>的实现类，那么我们在<code>PhoneWindow</code>类里面找到它的<code>setContentView</code>方法，看看它又实现了什么，<code>PhoneWindow</code>的<code>setContentView</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class=\"line\">    <span class=\"comment\">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class=\"line\">    <span class=\"comment\">// before this happens.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 1</span></span><br><span class=\"line\">        installDecor();<span class=\"comment\">//mContentParent为空，创建一个DecroView</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">        mContentParent.removeAllViews();<span class=\"comment\">//mContentParent不为空，删除其中的View</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class=\"line\">                getContext());</span><br><span class=\"line\">        transitionTo(newScene);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mLayoutInflater.inflate(layoutResID, mContentParent); <span class=\"comment\">//为mContentParent添加子View,即Activity中设置的布局文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">        cb.onContentChanged();<span class=\"comment\">//回调通知，内容改变</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先判断了<code>mContentParent</code>是否为<code>null</code>，如果为空则执行<code>installDecor()</code>方法，那么这个<code>mContentParent</code>又是什么呢？我们看一下它的注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This is the view in which the window contents are placed. It is either</span><br><span class=\"line\">// mDecor itself, or a child of mDecor where the contents go.</span><br><span class=\"line\">private ViewGroup mContentParent;</span><br></pre></td></tr></table></figure>\n<p>它是一个<code>ViewGroup</code>类型，结合2的代码处得知,这个<code>mContentParent</code>是我们设置的布局(即main.xml)的父布局。注释还提到了，这个<code>mContentParent</code>是<code>mDecor</code>本身或者是<code>mDecor</code>的一个子元素，这句话什么意思呢？这里先留一个疑问，下面会解释。</p>\n<p>这里先梳理一下以上的内容：<strong>通过上面的流程我们大致可以了解先在<code>PhoneWindow</code>中创建了一个<code>DecroView</code>，其中创建的过程中可能根据<code>Theme</code>不同，加载不同的布局格式，例如有没有Title，或有没有<code>ActionBar</code>等，然后再向<code>mContentParent</code>中加入子View,即Activity中设置的布局。到此位置，视图一层层嵌套添加上了。</strong></p>\n<h2 id=\"创建DecorView\"><a href=\"#创建DecorView\" class=\"headerlink\" title=\"创建DecorView\"></a>创建DecorView</h2><p>接着上面提到的<code>installDecor()</code>方法，我们看看它的源码，<strong>PhoneWindow#installDecor:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mDecor = generateDecor(); <span class=\"comment\">// 1 生成DecorView</span></span><br><span class=\"line\">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class=\"line\">        mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mContentParent = generateLayout(mDecor); <span class=\"comment\">// 2 为DecorView设置布局格式，并返回mContentParent</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，会执行1的代码，调用<code>PhoneWindow#generateDecor</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DecorView <span class=\"title\">generateDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DecorView(getContext(), -<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，这里实例化了<code>DecorView</code>，而<code>DecorView</code>则是<code>PhoneWindow</code>类的一个内部类，继承于<code>FrameLayout</code>，由此可知它也是一个<code>ViewGroup</code>。<br>那么，DecroView到底充当了什么样的角色呢？<br>其实，<code>DecorView</code>是整个<code>ViewTree</code>的最顶层<code>View</code>，它是一个<code>FrameLayout</code>布局，代表了整个应用的界面。在该布局下面，<strong>有标题view和内容view这两个子元素</strong>，而内容view则是上面提到的mContentParent。</p>\n<p>我们接着看2处的代码，<strong>PhoneWindow#generateLayout方法</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ViewGroup <span class=\"title\">generateLayout</span><span class=\"params\">(DecorView decor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Apply data from current theme.</span></span><br><span class=\"line\">        <span class=\"comment\">// 从主题文件中获取样式信息</span></span><br><span class=\"line\">        TypedArray a = getWindowStyle();</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            requestFeature(FEATURE_NO_TITLE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Don't allow an action bar if there is no title.</span></span><br><span class=\"line\">            requestFeature(FEATURE_ACTION_BAR);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(...)&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Inflate the window decor.</span></span><br><span class=\"line\">        <span class=\"comment\">// 根据主题样式，加载窗口布局</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> layoutResource;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> features = getLocalFeatures();</span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(\"Features: 0x\" + Integer.toHexString(features));</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(...)&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        View in = mLayoutInflater.inflate(layoutResource, <span class=\"keyword\">null</span>);    <span class=\"comment\">//加载layoutResource</span></span><br><span class=\"line\">        decor.addView(in, <span class=\"keyword\">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); <span class=\"comment\">//往DecorView中添加子View，即mContentParent</span></span><br><span class=\"line\">        mContentRoot = (ViewGroup) in;</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); <span class=\"comment\">// 这里获取的就是mContentParent  @android:id/content</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (contentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Window couldn't find content container view\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ProgressBar progress = getCircularProgressBar(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (progress != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                progress.setIndeterminate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            registerSwipeCallbacks();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remaining setup -- of background and title -- that only applies</span></span><br><span class=\"line\">        <span class=\"comment\">// to top-level windows.</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> contentParent;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>由以上代码可以看出，该方法还是做了相当多的工作的，首先根据设置的主题样式来设置<code>DecorView</code>的风格，比如说有没有<code>titlebar</code>之类的，接着为<code>DecorView</code>添加子<code>View</code>，而这里的子<code>View</code>则是上面提到的<code>mContentParent</code>，如果上面设置了<code>FEATURE_NO_ACTIONBAR</code>，那么<code>DecorView</code>就只有<code>mContentParent</code>一个子<code>View</code>，这也解释了上面的疑问：<code>mContentParent</code>是<code>DecorView</code>本身或者是<code>DecorView</code>的一个子元素。<br>用一幅图来表示DecorView的结构如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g11ffv2vb6j30er0gjgn9.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p><strong>小结：</strong> <code>DecorView</code>是顶级<code>View</code>，内部有<code>titlebar</code>和<code>contentParent</code>两个子元素，c<code>ontentParent</code>的<code>id</code>是<code>content</code>，而我们设置的<code>main.xml</code>布局则是<code>contentParent</code>里面的一个子元素。</p>\n<p>在<code>DecorView</code>创建完毕后，让我们回到P<code>honeWindow#setContentView</code>方法，直接看2处代码： <code>mLayoutInflater.inflate(layoutResID, mContentParent)</code>;这里加载了我们设置的<code>main.xml</code>布局文件，并且设置<code>mContentParent</code>为main.xml的父布局，至于它怎么加载的，这里就不展开来说了。</p>\n<p>到目前为止，通过<code>setContentView</code>方法，创建了<code>DecorView</code>和加载了我们提供的布局，但是这时，<strong>我们的View还是不可见的</strong>，因为我们仅仅是加载了布局，并没有对View进行任何的<strong>测量、布局、绘制</strong>工作。在View进行测量流程之前，还要进行一个步骤，那就是把<code>DecorView</code>添加至<code>window</code>中，然后经过一系列过程触发<code>ViewRootImpl#performTraversals</code>方法，在该方法内部会正式开始测量、布局、绘制这三大流程。至于该一系列过程是怎样的，因为涉及到了很多机制，这里简单说明一下：</p>\n<h2 id=\"将DecorView添加至Window\"><a href=\"#将DecorView添加至Window\" class=\"headerlink\" title=\"将DecorView添加至Window\"></a>将DecorView添加至Window</h2><p>每一个<code>Activity</code>组件都有一个关联的<code>Window</code>对象，用来描述一个应用程序窗口。每一个应用程序窗口内部又包含有一个<code>View</code>对象，用来描述应用程序窗口的视图。上文分析了创建<code>DecorView</code>的过程，现在则要把<code>DecorVie</code>w添加到<code>Window</code>对象中。而要了解这个过程，我们首先要简单先了解一下<code>Activity</code>的创建过程：<br>首先，在<code>ActivityThread</code>#<code>handleLaunchActivity</code>中启动<code>Activity</code>，在这里面会调用到<code>Activity</code>#<code>onCreate</code>方法，从而完成上面所述的<code>DecorView</code>创建动作，当o<code>nCreate()</code>方法执行完毕，在<code>handleLaunchActivity</code>方法会继续调用到<br><code>ActivityThread#handleResumeActivity</code>方法，我们看看这个方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> clearHide, <span class=\"keyword\">boolean</span> isForward)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    ActivityClientRecord r = performResumeActivity(token, clearHide); <span class=\"comment\">// 这里会调用到onResume()方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow(); <span class=\"comment\">// 获得window对象</span></span><br><span class=\"line\">            View decor = r.window.getDecorView(); <span class=\"comment\">// 获得DecorView对象</span></span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager(); <span class=\"comment\">// 获得windowManager对象</span></span><br><span class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">            a.mDecor = decor;</span><br><span class=\"line\">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class=\"line\">            l.softInputMode |= forwardBit;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                wm.addView(decor, l); <span class=\"comment\">// 调用addView方法</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该方法内部，获取该<code>activity</code>所关联的<code>window</code>对象，<code>DecorView</code>对象，以及<code>WindowManager</code>对象，而<code>WindowManager</code>是抽象类，它的实现类是<code>WindowManagerImpl</code>，所以后面调用的是<br><code>WindowManagerImpl#addView方法</code>，我们看看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着调用了<code>mGlobal</code>的成员函数，而<code>mGlobal</code>则是<code>WindowManagerGlobal</code>的一个实例，那么我们接着看<br><code>WindowManagerGlobal#addView</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        View panelParentView = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\"></span><br><span class=\"line\">            mViews.add(view);</span><br><span class=\"line\">            mRoots.add(root);</span><br><span class=\"line\">            mParams.add(wparams);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// do this last because it fires off messages to start doing things</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            root.setView(view, wparams, panelParentView); <span class=\"comment\">// 2</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = findViewLocked(view, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    removeViewLocked(index, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>先看1号代码处，实例化了<code>ViewRootImpl</code>类，接着，在2号代码处，调用<code>ViewRootImpl#setView</code>方法，并把<code>DecorView</code>作为参数传递进去，在这个方法内部，会通过跨进程的方式向<code>WMS（WindowManagerService）</code>发起一个调用，从而将<code>DecorView</code>最终添加到<code>Window</code>上，在这个过程中，ViewRootImpl、DecorView和WMS会彼此关联，至于详细过程这里不展开来说了。<br>最后通过<code>WMS</code>调用<code>ViewRootImpl#performTraverals</code>方法,然后依照下图流程层层调用，完成绘制，最终界面才显示出来,下偏文章讲View的绘制.</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g11g5op2u0j30iv0c0juh.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"系统源码解读-深入理解DecorView与ViewRootImpl\"><a href=\"#系统源码解读-深入理解DecorView与ViewRootImpl\" class=\"headerlink\" title=\"系统源码解读:深入理解DecorView与ViewRootImpl\"></a>系统源码解读:深入理解DecorView与ViewRootImpl</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于Android开发者来说，View无疑是开发中经常接触的，<strong>包括它的事件分发机制、测量、布局、绘制流程等</strong>，如果要自定义一个View，那么应该对以上流程有所了解、研究。本系列文章将会为大家带来View的工作流程详细解析。在深入接触View的测量、布局、绘制这三个流程之前，我们从Activity入手，看看从Activity创建后到View的正式工作之前，所要经历的步骤。以下源码均取自Android API 21。<br>","more":"</p>\n<h2 id=\"setContentView\"><a href=\"#setContentView\" class=\"headerlink\" title=\"setContentView\"></a>setContentView</h2><p>从<code>setContentView</code>说起<br>一般地，我们在<code>Activity</code>中，会在<code>onCreate()</code>方法中写下这样一句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>\n<p>显然，这是为<code>activity</code>设置一个我们定义好的main.xml布局，我们跟踪一下源码，看看这个方法是怎样做的，<code>Activity</code>的<code>setContentView()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">     getWindow().setContentView(layoutResID);  <span class=\"comment\">//调用getWindow方法，返回mWindow</span></span><br><span class=\"line\">     initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Window <span class=\"title\">getWindow</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">     <span class=\"keyword\">return</span> mWindow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面看出，里面调用了<code>mWindow</code>的<code>setContentView</code>方法，那么这个<strong>“mWindow”</strong>是何方神圣呢？尝试追踪一下源码，发现<code>mWindow</code>是<code>Window</code>类型的，但是它是一个抽象类，<code>setContentView</code>也是抽象方法，所以我们要找到Window类的实现类才行。我们在Activity中查找一下mWindow在哪里被赋值了，可以发现它在Activity#attach方法中有如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           CharSequence title, Activity parent, String id,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           Window window)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">       mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>, window);<span class=\"comment\">//创建一个Window对象</span></span><br><span class=\"line\">       mWindow.setWindowControllerCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">       mWindow.setCallback(<span class=\"keyword\">this</span>);<span class=\"comment\">//设置回调，向Activity分发点击或状态改变等事件</span></span><br><span class=\"line\">       mWindow.setOnWindowDismissedCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">       mWindow.setWindowManager(</span><br><span class=\"line\">               (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class=\"line\">               mToken, mComponent.flattenToString(),</span><br><span class=\"line\">               (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class=\"number\">0</span>);<span class=\"comment\">//给Window设置WindowManager对象</span></span><br><span class=\"line\">...</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我们只看关键部分，这里实例化了<code>PhoneWindow</code>类，由此得知，<code>PhoneWindow</code>是<code>Window</code>的实现类，那么我们在<code>PhoneWindow</code>类里面找到它的<code>setContentView</code>方法，看看它又实现了什么，<code>PhoneWindow</code>的<code>setContentView</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class=\"line\">    <span class=\"comment\">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class=\"line\">    <span class=\"comment\">// before this happens.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 1</span></span><br><span class=\"line\">        installDecor();<span class=\"comment\">//mContentParent为空，创建一个DecroView</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">        mContentParent.removeAllViews();<span class=\"comment\">//mContentParent不为空，删除其中的View</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class=\"line\">                getContext());</span><br><span class=\"line\">        transitionTo(newScene);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mLayoutInflater.inflate(layoutResID, mContentParent); <span class=\"comment\">//为mContentParent添加子View,即Activity中设置的布局文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">        cb.onContentChanged();<span class=\"comment\">//回调通知，内容改变</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先判断了<code>mContentParent</code>是否为<code>null</code>，如果为空则执行<code>installDecor()</code>方法，那么这个<code>mContentParent</code>又是什么呢？我们看一下它的注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This is the view in which the window contents are placed. It is either</span><br><span class=\"line\">// mDecor itself, or a child of mDecor where the contents go.</span><br><span class=\"line\">private ViewGroup mContentParent;</span><br></pre></td></tr></table></figure>\n<p>它是一个<code>ViewGroup</code>类型，结合2的代码处得知,这个<code>mContentParent</code>是我们设置的布局(即main.xml)的父布局。注释还提到了，这个<code>mContentParent</code>是<code>mDecor</code>本身或者是<code>mDecor</code>的一个子元素，这句话什么意思呢？这里先留一个疑问，下面会解释。</p>\n<p>这里先梳理一下以上的内容：<strong>通过上面的流程我们大致可以了解先在<code>PhoneWindow</code>中创建了一个<code>DecroView</code>，其中创建的过程中可能根据<code>Theme</code>不同，加载不同的布局格式，例如有没有Title，或有没有<code>ActionBar</code>等，然后再向<code>mContentParent</code>中加入子View,即Activity中设置的布局。到此位置，视图一层层嵌套添加上了。</strong></p>\n<h2 id=\"创建DecorView\"><a href=\"#创建DecorView\" class=\"headerlink\" title=\"创建DecorView\"></a>创建DecorView</h2><p>接着上面提到的<code>installDecor()</code>方法，我们看看它的源码，<strong>PhoneWindow#installDecor:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mDecor = generateDecor(); <span class=\"comment\">// 1 生成DecorView</span></span><br><span class=\"line\">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class=\"line\">        mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mContentParent = generateLayout(mDecor); <span class=\"comment\">// 2 为DecorView设置布局格式，并返回mContentParent</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，会执行1的代码，调用<code>PhoneWindow#generateDecor</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DecorView <span class=\"title\">generateDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DecorView(getContext(), -<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，这里实例化了<code>DecorView</code>，而<code>DecorView</code>则是<code>PhoneWindow</code>类的一个内部类，继承于<code>FrameLayout</code>，由此可知它也是一个<code>ViewGroup</code>。<br>那么，DecroView到底充当了什么样的角色呢？<br>其实，<code>DecorView</code>是整个<code>ViewTree</code>的最顶层<code>View</code>，它是一个<code>FrameLayout</code>布局，代表了整个应用的界面。在该布局下面，<strong>有标题view和内容view这两个子元素</strong>，而内容view则是上面提到的mContentParent。</p>\n<p>我们接着看2处的代码，<strong>PhoneWindow#generateLayout方法</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ViewGroup <span class=\"title\">generateLayout</span><span class=\"params\">(DecorView decor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Apply data from current theme.</span></span><br><span class=\"line\">        <span class=\"comment\">// 从主题文件中获取样式信息</span></span><br><span class=\"line\">        TypedArray a = getWindowStyle();</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            requestFeature(FEATURE_NO_TITLE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Don't allow an action bar if there is no title.</span></span><br><span class=\"line\">            requestFeature(FEATURE_ACTION_BAR);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(...)&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Inflate the window decor.</span></span><br><span class=\"line\">        <span class=\"comment\">// 根据主题样式，加载窗口布局</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> layoutResource;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> features = getLocalFeatures();</span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(\"Features: 0x\" + Integer.toHexString(features));</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(...)&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        View in = mLayoutInflater.inflate(layoutResource, <span class=\"keyword\">null</span>);    <span class=\"comment\">//加载layoutResource</span></span><br><span class=\"line\">        decor.addView(in, <span class=\"keyword\">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); <span class=\"comment\">//往DecorView中添加子View，即mContentParent</span></span><br><span class=\"line\">        mContentRoot = (ViewGroup) in;</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); <span class=\"comment\">// 这里获取的就是mContentParent  @android:id/content</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (contentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Window couldn't find content container view\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ProgressBar progress = getCircularProgressBar(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (progress != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                progress.setIndeterminate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            registerSwipeCallbacks();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remaining setup -- of background and title -- that only applies</span></span><br><span class=\"line\">        <span class=\"comment\">// to top-level windows.</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> contentParent;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>由以上代码可以看出，该方法还是做了相当多的工作的，首先根据设置的主题样式来设置<code>DecorView</code>的风格，比如说有没有<code>titlebar</code>之类的，接着为<code>DecorView</code>添加子<code>View</code>，而这里的子<code>View</code>则是上面提到的<code>mContentParent</code>，如果上面设置了<code>FEATURE_NO_ACTIONBAR</code>，那么<code>DecorView</code>就只有<code>mContentParent</code>一个子<code>View</code>，这也解释了上面的疑问：<code>mContentParent</code>是<code>DecorView</code>本身或者是<code>DecorView</code>的一个子元素。<br>用一幅图来表示DecorView的结构如下：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g11ffv2vb6j30er0gjgn9.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p><strong>小结：</strong> <code>DecorView</code>是顶级<code>View</code>，内部有<code>titlebar</code>和<code>contentParent</code>两个子元素，c<code>ontentParent</code>的<code>id</code>是<code>content</code>，而我们设置的<code>main.xml</code>布局则是<code>contentParent</code>里面的一个子元素。</p>\n<p>在<code>DecorView</code>创建完毕后，让我们回到P<code>honeWindow#setContentView</code>方法，直接看2处代码： <code>mLayoutInflater.inflate(layoutResID, mContentParent)</code>;这里加载了我们设置的<code>main.xml</code>布局文件，并且设置<code>mContentParent</code>为main.xml的父布局，至于它怎么加载的，这里就不展开来说了。</p>\n<p>到目前为止，通过<code>setContentView</code>方法，创建了<code>DecorView</code>和加载了我们提供的布局，但是这时，<strong>我们的View还是不可见的</strong>，因为我们仅仅是加载了布局，并没有对View进行任何的<strong>测量、布局、绘制</strong>工作。在View进行测量流程之前，还要进行一个步骤，那就是把<code>DecorView</code>添加至<code>window</code>中，然后经过一系列过程触发<code>ViewRootImpl#performTraversals</code>方法，在该方法内部会正式开始测量、布局、绘制这三大流程。至于该一系列过程是怎样的，因为涉及到了很多机制，这里简单说明一下：</p>\n<h2 id=\"将DecorView添加至Window\"><a href=\"#将DecorView添加至Window\" class=\"headerlink\" title=\"将DecorView添加至Window\"></a>将DecorView添加至Window</h2><p>每一个<code>Activity</code>组件都有一个关联的<code>Window</code>对象，用来描述一个应用程序窗口。每一个应用程序窗口内部又包含有一个<code>View</code>对象，用来描述应用程序窗口的视图。上文分析了创建<code>DecorView</code>的过程，现在则要把<code>DecorVie</code>w添加到<code>Window</code>对象中。而要了解这个过程，我们首先要简单先了解一下<code>Activity</code>的创建过程：<br>首先，在<code>ActivityThread</code>#<code>handleLaunchActivity</code>中启动<code>Activity</code>，在这里面会调用到<code>Activity</code>#<code>onCreate</code>方法，从而完成上面所述的<code>DecorView</code>创建动作，当o<code>nCreate()</code>方法执行完毕，在<code>handleLaunchActivity</code>方法会继续调用到<br><code>ActivityThread#handleResumeActivity</code>方法，我们看看这个方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> clearHide, <span class=\"keyword\">boolean</span> isForward)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    ActivityClientRecord r = performResumeActivity(token, clearHide); <span class=\"comment\">// 这里会调用到onResume()方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow(); <span class=\"comment\">// 获得window对象</span></span><br><span class=\"line\">            View decor = r.window.getDecorView(); <span class=\"comment\">// 获得DecorView对象</span></span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager(); <span class=\"comment\">// 获得windowManager对象</span></span><br><span class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">            a.mDecor = decor;</span><br><span class=\"line\">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class=\"line\">            l.softInputMode |= forwardBit;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                wm.addView(decor, l); <span class=\"comment\">// 调用addView方法</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在该方法内部，获取该<code>activity</code>所关联的<code>window</code>对象，<code>DecorView</code>对象，以及<code>WindowManager</code>对象，而<code>WindowManager</code>是抽象类，它的实现类是<code>WindowManagerImpl</code>，所以后面调用的是<br><code>WindowManagerImpl#addView方法</code>，我们看看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着调用了<code>mGlobal</code>的成员函数，而<code>mGlobal</code>则是<code>WindowManagerGlobal</code>的一个实例，那么我们接着看<br><code>WindowManagerGlobal#addView</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        View panelParentView = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\"></span><br><span class=\"line\">            mViews.add(view);</span><br><span class=\"line\">            mRoots.add(root);</span><br><span class=\"line\">            mParams.add(wparams);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// do this last because it fires off messages to start doing things</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            root.setView(view, wparams, panelParentView); <span class=\"comment\">// 2</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> index = findViewLocked(view, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    removeViewLocked(index, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>先看1号代码处，实例化了<code>ViewRootImpl</code>类，接着，在2号代码处，调用<code>ViewRootImpl#setView</code>方法，并把<code>DecorView</code>作为参数传递进去，在这个方法内部，会通过跨进程的方式向<code>WMS（WindowManagerService）</code>发起一个调用，从而将<code>DecorView</code>最终添加到<code>Window</code>上，在这个过程中，ViewRootImpl、DecorView和WMS会彼此关联，至于详细过程这里不展开来说了。<br>最后通过<code>WMS</code>调用<code>ViewRootImpl#performTraverals</code>方法,然后依照下图流程层层调用，完成绘制，最终界面才显示出来,下偏文章讲View的绘制.</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://ws1.sinaimg.cn/large/007lnl1egy1g11g5op2u0j30iv0c0juh.jpg\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjszuvyt20007qk9ygg28izz4","category_id":"cjszuvyt70009qk9yzkadowvp","_id":"cjszuvytf000dqk9y5ivaej0t"},{"post_id":"cjszuvyt50008qk9yympx46in","category_id":"cjszuvyte000bqk9ytb3ifh0w","_id":"cjszuvytg000fqk9ye8miijku"},{"post_id":"cjszuvytu000lqk9ys81ck9r6","category_id":"cjszuvyt70009qk9yzkadowvp","_id":"cjszuvytw000nqk9y2w02zjz1"},{"post_id":"cjszuvyug000pqk9ynt1939hw","category_id":"cjszuvyte000bqk9ytb3ifh0w","_id":"cjszuvyui000rqk9y6fpb1nes"},{"post_id":"cjszuvyuz000zqk9yobb3qdkv","category_id":"cjszuvyte000bqk9ytb3ifh0w","_id":"cjszuvyv00011qk9yupkug73f"},{"post_id":"cjt3rajjl0000tc9zztbsiab3","category_id":"cjszuvyt70009qk9yzkadowvp","_id":"cjt3rajjv0002tc9z3077joik"},{"post_id":"cjt7736n30000yann7euwzfot","category_id":"cjszuvyte000bqk9ytb3ifh0w","_id":"cjt7736nd0002yann5qvabg36"}],"PostTag":[{"post_id":"cjszuvyt20007qk9ygg28izz4","tag_id":"cjszuvytc000aqk9yjqduc1ro","_id":"cjszuvyth000hqk9yq1rsb3j7"},{"post_id":"cjszuvyt20007qk9ygg28izz4","tag_id":"cjszuvyte000cqk9y1hahmpu1","_id":"cjszuvyti000iqk9ycduh7cbp"},{"post_id":"cjszuvyt20007qk9ygg28izz4","tag_id":"cjszuvytf000eqk9yezl860v6","_id":"cjszuvyti000jqk9yyayfmx1y"},{"post_id":"cjszuvyt50008qk9yympx46in","tag_id":"cjszuvytg000gqk9y7mgxohmc","_id":"cjszuvyti000kqk9y2j30jzu9"},{"post_id":"cjszuvytu000lqk9ys81ck9r6","tag_id":"cjszuvytw000mqk9yd4gjl60q","_id":"cjszuvytw000oqk9y4b35d1b3"},{"post_id":"cjszuvyug000pqk9ynt1939hw","tag_id":"cjszuvyui000qqk9y6a0197f5","_id":"cjszuvyuk000vqk9yzkksvqet"},{"post_id":"cjszuvyug000pqk9ynt1939hw","tag_id":"cjszuvyui000sqk9yj8f2855k","_id":"cjszuvyuk000wqk9ye4x6u2z5"},{"post_id":"cjszuvyug000pqk9ynt1939hw","tag_id":"cjszuvyuj000tqk9ynltdc7id","_id":"cjszuvyuk000xqk9ygirne652"},{"post_id":"cjszuvyug000pqk9ynt1939hw","tag_id":"cjszuvyuk000uqk9yo24zspl5","_id":"cjszuvyuk000yqk9y9kfrzo8q"},{"post_id":"cjszuvyuz000zqk9yobb3qdkv","tag_id":"cjszuvyv00010qk9ywt1jhayv","_id":"cjszuvyv00012qk9yf09jotgi"},{"post_id":"cjt3rajjl0000tc9zztbsiab3","tag_id":"cjszuvyte000cqk9y1hahmpu1","_id":"cjt3rajju0001tc9z7s2gsyj8"},{"post_id":"cjt7736n30000yann7euwzfot","tag_id":"cjt7736n80001yannjeyv2nn1","_id":"cjt7736ne0005yannl1vcsvb3"},{"post_id":"cjt7736n30000yann7euwzfot","tag_id":"cjt7736nd0003yannrvle5esf","_id":"cjt7736ne0006yannifa6m8mi"},{"post_id":"cjt7736n30000yann7euwzfot","tag_id":"cjt7736ne0004yanncmb2r63p","_id":"cjt7736nf0007yann86xt7afh"}],"Tag":[{"name":"JVM内存结构","_id":"cjszuvytc000aqk9yjqduc1ro"},{"name":"Java内存模型","_id":"cjszuvyte000cqk9y1hahmpu1"},{"name":"Java对象模型","_id":"cjszuvytf000eqk9yezl860v6"},{"name":"AsyncTask","_id":"cjszuvytg000gqk9y7mgxohmc"},{"name":"ThreadLocal","_id":"cjszuvytw000mqk9yd4gjl60q"},{"name":"Handler","_id":"cjszuvyui000qqk9y6a0197f5"},{"name":"MessageQueue","_id":"cjszuvyui000sqk9yj8f2855k"},{"name":"Looper","_id":"cjszuvyuj000tqk9ynltdc7id"},{"name":"Android 消息机制","_id":"cjszuvyuk000uqk9yo24zspl5"},{"name":"Activity 启动流程分析","_id":"cjszuvyv00010qk9ywt1jhayv"},{"name":"Android源码解析","_id":"cjt7736n80001yannjeyv2nn1"},{"name":"DecorView","_id":"cjt7736nd0003yannrvle5esf"},{"name":"ViewRootImpl","_id":"cjt7736ne0004yanncmb2r63p"}]}}