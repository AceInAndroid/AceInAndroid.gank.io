<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Ace的技术客栈</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="前端,js,jquery,javascript,html5,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验">
<meta property="og:type" content="website">
<meta property="og:title" content="Ace的技术客栈">
<meta property="og:url" content="http://www.azhangbing.com/index.html">
<meta property="og:site_name" content="Ace的技术客栈">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ace的技术客栈">
  
    <link rel="alternative" href="/atom.xml" title="Ace的技术客栈" type="application/atom+xml">
  
  
    <link rel="icon" href="//images/logo.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="//images/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Ace</a></h1>
        </hgroup>

        
        <p class="header-subtitle">业精于勤荒于嬉 行成于思毁于随</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/tags">标签</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:2577113@qq.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/AceInAndroid" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="#" title="weibo">weibo</a>
                            
                                <a class="fl google" target="_blank" href="#" title="google">google</a>
                            
                                <a class="fl twitter" target="_blank" href="#" title="twitter">twitter</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/并发编程/" style="font-size: 10px;">并发编程</a> <a href="/tags/感悟/" style="font-size: 15px;">感悟</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">业精于勤荒于嬉</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Ace</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="//images/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Ace</a></h1>
            </hgroup>
            
            <p class="header-subtitle">业精于勤荒于嬉 行成于思毁于随</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/tags">标签</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:2577113@qq.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/AceInAndroid" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
                    
                        <a class="google" target="_blank" href="#" title="google">google</a>
                    
                        <a class="twitter" target="_blank" href="#" title="twitter">twitter</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Cling介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/25/Cling介绍/" class="article-date">
      <time datetime="2017-10-25T06:41:51.000Z" itemprop="datePublished">2017-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/25/Cling介绍/">Cling介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Android投屏-同屏库Cling源码使用和解析"><a href="#Android投屏-同屏库Cling源码使用和解析" class="headerlink" title="Android投屏,同屏库Cling源码使用和解析"></a>Android投屏,同屏库Cling源码使用和解析</h1><h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h2><p>为了满足手机与TV端相互交互分享图片在TV上播放的需求,在了解了一番技术选型之后,选用了基于DLNA的UPnP协议的<a href="https://github.com/4thline/cling" target="_blank" rel="external">Cling</a>这个库.</p>
<p>(1) 定义自己的 UpnpService 类，继承自 AndroidUpnpServiceImpl<br>(2) 启动该 Service,同时启动jetty资源服务器<br>(3) 从 UpnpService 中获取 ControlPoint，并搜索设备</p>
<p>搜索注册在同局域网的所有设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">    private ServiceConnection serviceConnection = new ServiceConnection() &#123;</div><div class="line"></div><div class="line">        public void onServiceConnected(ComponentName className, IBinder service) &#123;</div><div class="line">            isBind = true;</div><div class="line">            upnpService = (AndroidUpnpService) service;</div><div class="line">            ....</div><div class="line">upnpService.getRegistry().addListener(registryListener);</div><div class="line">            ....</div><div class="line">            // 搜索局域网内设备</div><div class="line">upnpService.getControlPoint().search();</div><div class="line">        &#125;</div><div class="line">      ...</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line"> private RegistryListener registryListener = new RegistryListener() &#123;</div><div class="line">    ....</div><div class="line">            @Override</div><div class="line">        public void localDeviceAdded(Registry registry, LocalDevice localDevice) &#123;</div><div class="line">           ....</div><div class="line">           //注册接收TV设备消息的回调</div><div class="line">           localService.getManager().getImplementation().setiControlCallback(innerCallback);</div><div class="line">              ....</div><div class="line">        &#125;</div><div class="line">        </div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void remoteDeviceAdded(Registry registry, RemoteDevice remoteDevice) &#123;</div><div class="line">            //添加搜索到的设备到remoteDevices</div><div class="line">            remoteDevices.add(remoteDevice);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      ......</div><div class="line">       &#125;;</div></pre></td></tr></table></figure>
<p>然后根据和家相册TV独有的字段过滤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 过滤感兴趣的设备</div><div class="line"> * @return </div><div class="line"> */</div><div class="line">public List&lt;Device&gt; getDmrDevices() &#123;</div><div class="line">    List&lt;Device&gt; devices = new ArrayList&lt;&gt;();</div><div class="line">    List&lt;Device&gt; mdevices = new ArrayList&lt;&gt;();</div><div class="line">    devices.addAll(remoteDevices);</div><div class="line">    for (int i = 0; i &lt; devices.size(); i++) &#123;</div><div class="line">        if (!dmrDeviceType.equals(devices.get(i).getType())) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        String devices_uuid = devices.get(i).getIdentity().getUdn().toString();</div><div class="line">        String localuuid = LocalDeviceFactoty.uniqueSystemIdentifier(LocalDeviceFactoty.DMR_KEY).toString();</div><div class="line">        if (!devices_uuid.equals(localuuid)) &#123;</div><div class="line">        //过滤我们感兴趣的设备</div><div class="line">            if (devices_uuid.contains(&quot;-dmp&quot;))</div><div class="line">                mdevices.add(devices.get(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return mdevices;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>连接电视</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void connecttotv(Device device, Handler handler) &#123;</div><div class="line">    String data = &quot;&quot;;</div><div class="line">    JSONObject jsonObject = new JSONObject();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            jsonObject.put(&quot;tv_uuid&quot;, device.getIdentity().getUdn().getIdentifierString());</div><div class="line">            jsonObject.put(&quot;phone_uuid&quot;, DevicesManager.getInstance().getDmsDeviceIdentifierString());</div><div class="line">            jsonObject.put(&quot;phone_model&quot;, Utils.getDevName());</div><div class="line">            jsonObject.put(&quot;phone_ip&quot;, getPhoneIP());</div><div class="line">            data = jsonObject.toString();</div><div class="line">        &#125; catch (JSONException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        sendtoTV(device.getIdentity().getUdn().getIdentifierString(), Constants.TYPE_CONNECT, data, handler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sendtoTV()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//查找设备的方法</div><div class="line">           Service service = device.findService(simpleParamServiceId);</div><div class="line">           if (service != null) &#123;</div><div class="line">               targetService = service;</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       SendSimpleParamActionCallback callback = new SendSimpleParamActionCallback(targetService, str);</div><div class="line">       callback.setiServiceResult(iServiceResult);</div><div class="line"></div><div class="line">       upnpService().getControlPoint().execute(callback)</div></pre></td></tr></table></figure>
<h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h2><h3 id="2-1-总体设计"><a href="#2-1-总体设计" class="headerlink" title="2.1 总体设计"></a>2.1 总体设计</h3><h4 id="2-1-1-概述"><a href="#2-1-1-概述" class="headerlink" title="2.1.1 概述"></a>2.1.1 概述</h4><p>Cling 作为 UPnP 协议栈，其主旨即是在设备的发现，控制等过程中对不同的协议及内容进行处理。UPnP 协议栈由多个层组成，Cling 只关心底层的 TCP/IP 协议以及包含 SSDP（设备发现），SOAP（设备控制），GENA（设备事件）协议的层。</p>
<h4 id="2-1-2-使用场景"><a href="#2-1-2-使用场景" class="headerlink" title="2.1.2 使用场景"></a>2.1.2 使用场景</h4><blockquote>
<ul>
<li>手机加入到局域网中，建立 MulticastSocket 监听局域网中设备</li>
<li>手机 向多播发出 M-SEARCH 报文</li>
<li>和家相册TV端 获取局域网中手机发出的报文，判断是否符合条件，若符合向手机回应 OK 报文，报文中包含 description,URL,uuid,udn等信息(封装在Device里)</li>
<li>手机 监听局域网获取到相关报文，并通过 URL 获得设备描述信息判断是不是自己感兴趣</li>
<li>手机 通过 Jetty Service 将媒体内容的HTTP链接推送到 和家相册TV端并播放</li>
</ul>
</blockquote>
<h4 id="2-1-3-设备发现及控制流程"><a href="#2-1-3-设备发现及控制流程" class="headerlink" title="2.1.3 设备发现及控制流程"></a>2.1.3 设备发现及控制流程</h4><p><img src="http://oy261wvqm.bkt.clouddn.com/2017-10-25-control_flow.png" alt="control_flo"></p>
<h4 id="2-1-4-类关系图"><a href="#2-1-4-类关系图" class="headerlink" title="2.1.4 类关系图"></a>2.1.4 类关系图</h4><p><img src="http://oy261wvqm.bkt.clouddn.com/2017-10-25-15089023672484.png" alt=""></p>
<h4 id="2-1-5-类功能详细介绍"><a href="#2-1-5-类功能详细介绍" class="headerlink" title="2.1.5 类功能详细介绍"></a>2.1.5 类功能详细介绍</h4><blockquote>
<p>由类图可知，Cling 的一切都是从 UpnpService 开始的，其中包含了 ControlPoint，ProtocolFactory，Registry，Router 四个核心模块，以及一个配置信息类 UpnpServiceConfiguration。<br>ControlPoint<br>控制点的接口，主要功能是异步执行搜索，设备控制订阅等指令。<br>此接口定义了查找设备，向设备发送指令，订阅设备变更，其实现类只有一个为 ControlPointImpl。</p>
</blockquote>
<h5 id="2-1-5-1-ControlPoint"><a href="#2-1-5-1-ControlPoint" class="headerlink" title="2.1.5.1 ControlPoint"></a>2.1.5.1 ControlPoint</h5><h6 id="1-查找"><a href="#1-查找" class="headerlink" title="(1) 查找"></a>(1) 查找</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void search(UpnpHeader searchType, int mxSeconds);</div></pre></td></tr></table></figure>
<p>第一个参数UpnpHeader表示查询条件，第二个参数表示最大超时时间，以秒为单位。<br>UpnpHeader 是一个抽象类，其中定义了包含每个过程请求中的 Header 信息的枚举类型Type以及泛型 value，查询时常用的实现类有：DeviceTypeHeader，UDNHeader 等，可根据设备类型、UDN、服务类型等多种方式。</p>
<h6 id="2-执行控制指令"><a href="#2-执行控制指令" class="headerlink" title="(2) 执行控制指令"></a>(2) 执行控制指令</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Future execute(ActionCallback callback);</div></pre></td></tr></table></figure>
<p>将 ActionCallback 放入 DefaultUpnpServiceConfiguration 中定义的线程池 <strong>ClingExecutor</strong> 执行，执行完毕回调 ActionCallback 中定义的 success 或 failure 函数。<br>ActionCallback 是命令执行的回调接口，在其 run 方法内会根据是本地命令还是远程命令进行执行，执行结束后回调成功或失败接口。</p>
<h6 id="3-执行事件订阅指令"><a href="#3-执行事件订阅指令" class="headerlink" title="(3) 执行事件订阅指令"></a>(3) 执行事件订阅指令</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void execute(SubscriptionCallback callback);</div></pre></td></tr></table></figure>
<p>将 SubscriptionCallback 放入 DefaultUpnpServiceConfiguration 中定义的线程池 ClingExecutor 执行，执行完毕回调 ActionCallback 中定义的 established、failed、ended 等函数。</p>
<h5 id="2-1-5-2-ProtocolFactory"><a href="#2-1-5-2-ProtocolFactory" class="headerlink" title="2.1.5.2 ProtocolFactory"></a>2.1.5.2 ProtocolFactory</h5><p>UPnP 协议的工厂类，用于根据收到的 UPnP 协议或是本地设备的 meta 信息，创建一个可执行的协议。<br>使用简单工厂模式封装协议内容的处理，实现类为 ProtocolFactoryImpl，主要根据接收报文和发送报文两大类创建不同协议。</p>
<p>在该类中 UDP 包通过 createReceivingAsync() 方法对传递来的 IncomingDatagramMessage 进行处理，如 NOTIFY–ReceivingNotification，MSEARCH–ReceivingSearch。<br>TCP 包通过 createReceivingSync 进行分发处理，并通过 ReceivingSync 的子类进行处理，子类中调用 executeSync 方法等待并返回 response。</p>
<h6 id="1-处理接收到的报文"><a href="#1-处理接收到的报文" class="headerlink" title="(1) 处理接收到的报文"></a>(1) 处理接收到的报文</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public ReceivingAsync createReceivingAsync(IncomingDatagramMessage message);</div></pre></td></tr></table></figure>
<p>IncomingDatagramMessage 封装了 UDP 包的信息，在 createReceivingAsync 中根据消息的操作类型及方法创建不同的 ReceivingAsync 子类对象，ReceivingAsync 子类通过重写 execute 方法定义具体实现。如请求的 NOTIFY 信息创建 ReceivingNotification，请求的 MSEARCH 创建 ReceivingSearch。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public ReceivingSync createReceivingSync(StreamRequestMessage message);</div></pre></td></tr></table></figure>
<p>StreamRequestMessage 封装 TCP 报文，在 createReceivingSync 中根据消息的操作类型方法及 UPnP 服务 NameSpace 等的配置创建不同的 ReceivingSync 的子类对象，ReceivingSync 子类通过重写 executeSync 方法定义具体实现。</p>
<h6 id="2-组装发送的报文"><a href="#2-组装发送的报文" class="headerlink" title="(2) 组装发送的报文"></a>(2) 组装发送的报文</h6><p>有若干功能类似的方法，返回不同的 SendingAsync 子类对象，通过重写 executeSync 方法定义具体实现。如：</p>
<blockquote>
<ol>
<li>向组播发送 ssdp:alive 告知设备存活<br>public SendingNotificationAlive createSendingNotificationAlive(LocalDevice localDevice)</li>
<li>生产 SendingSearch 实例的工厂方法，SendingSearch 中定义了查询条件以及请求超时时间，在重写的 execute 函数中，在线程启动后创建 OutgoingSearchRequest 对象并通过 Router 发送。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public SendingSearch createSendingSearch(UpnpHeader searchTarget, int mxSeconds);</div></pre></td></tr></table></figure>
<h5 id="2-1-5-3-Registry"><a href="#2-1-5-3-Registry" class="headerlink" title="2.1.5.3 Registry"></a>2.1.5.3 Registry</h5><p>设备资源管理器，用于设备、资源、订阅消息的管理，包括添加、更新、移除、查询。可将新设备时加入 Registry 中，在设备失效后从 Registry 中移除。目前实现类为 RegistryImpl。<br>关联类包括：RegistryListener、Resource、RegistryItem、RegistryItems、LocalItems、RemoteItems、ExpirationDetails、RegistryMaintainer。</p>
<h5 id="2-1-5-4-RegistryListener"><a href="#2-1-5-4-RegistryListener" class="headerlink" title="2.1.5.4 RegistryListener"></a>2.1.5.4 RegistryListener</h5><p>设备状态监听类，包含本地/远程设备的发现、添加、更新、移除等回调函数。可通过<br>addListener(RegistryListener listener)<br>添加，保存在RegistryListener的 Set\ registryListener 参数内。<br>实现类有空实现的 DefaultRegistryListener 以及通过注入属性实现的 RegistryListenerAdapter。</p>
<h5 id="2-1-5-5-Resource"><a href="#2-1-5-5-Resource" class="headerlink" title="2.1.5.5 Resource"></a>2.1.5.5 Resource</h5><p>资源的父类。该类中定义资源的 URI，model 等属性。</p>
<h5 id="2-1-5-6-RegistryItem"><a href="#2-1-5-6-RegistryItem" class="headerlink" title="2.1.5.6 RegistryItem"></a>2.1.5.6 RegistryItem</h5><p>KV 形式的数据项，在 RegistryImpl 中用于包装设备、资源、订阅消息等。</p>
<h5 id="2-1-5-7-RegistryItems"><a href="#2-1-5-7-RegistryItems" class="headerlink" title="2.1.5.7 RegistryItems"></a>2.1.5.7 RegistryItems</h5><p>RegistryImpl中设备、资源集合的父类，定义了对元素的增删查改等操作。<br>包含deviceItems和subscriptionItems两个属性，分别表示设备集合和订阅消息集合，集合元素为RegistryItem。<br>子类有LocalItems和RemoteItems分别表示本地设备和远程设备集合。</p>
<h5 id="2-1-5-8-LocalItems"><a href="#2-1-5-8-LocalItems" class="headerlink" title="2.1.5.8 LocalItems"></a>2.1.5.8 LocalItems</h5><p>继承自 RegistryItems，key 为 LocalDevice，value 为 LocalGENASubscription。存储本地设备及其订阅消息。</p>
<h5 id="2-1-5-9-RemoteItems"><a href="#2-1-5-9-RemoteItems" class="headerlink" title="2.1.5.9 RemoteItems"></a>2.1.5.9 RemoteItems</h5><p>继承自 RegistryItems，key 为 RemoteDevice，value 为 RemoteGENASubscription。存储远程设备及其订阅消息。</p>
<h5 id="2-1-5-10-xpirationDetails"><a href="#2-1-5-10-xpirationDetails" class="headerlink" title="2.1.5.10 xpirationDetails"></a>2.1.5.10 xpirationDetails</h5><p>为 RegistryItem 的属性，记录上次刷新和最大超时时间，从而判断对象是否过期。</p>
<h5 id="2-1-5-11-RegistryMaintainer"><a href="#2-1-5-11-RegistryMaintainer" class="headerlink" title="2.1.5.11 RegistryMaintainer"></a>2.1.5.11 RegistryMaintainer</h5><p>资源管理器中元素有效期的定期维护，每隔 1000ms 调用一次 registry.maintain() 方法，该方法执行的操作有：</p>
<h6 id="1-判断过期的-item，并从-resourceItems-中移除；"><a href="#1-判断过期的-item，并从-resourceItems-中移除；" class="headerlink" title="(1) 判断过期的 item，并从 resourceItems 中移除；"></a>(1) 判断过期的 item，并从 resourceItems 中移除；</h6><h6 id="2-遍历-resourceItems，对其中的每个-Resource-调用其-maintain-方法；"><a href="#2-遍历-resourceItems，对其中的每个-Resource-调用其-maintain-方法；" class="headerlink" title="(2) 遍历 resourceItems，对其中的每个 Resource 调用其 maintain() 方法；"></a>(2) 遍历 resourceItems，对其中的每个 Resource 调用其 maintain() 方法；</h6><h6 id="3-remoteItems-maintain-对-remote-进行维护；"><a href="#3-remoteItems-maintain-对-remote-进行维护；" class="headerlink" title="(3) remoteItems.maintain() 对 remote 进行维护；"></a>(3) remoteItems.maintain() 对 remote 进行维护；</h6><h6 id="4-localItems-maintain-对-local-进行维护；"><a href="#4-localItems-maintain-对-local-进行维护；" class="headerlink" title="(4) localItems.maintain() 对 local 进行维护；"></a>(4) localItems.maintain() 对 local 进行维护；</h6><h6 id="5-runPendingExecutions-执行异步任务。"><a href="#5-runPendingExecutions-执行异步任务。" class="headerlink" title="(5) runPendingExecutions 执行异步任务。"></a>(5) runPendingExecutions 执行异步任务。</h6><h5 id="2-1-5-12-Router"><a href="#2-1-5-12-Router" class="headerlink" title="2.1.5.12 Router"></a>2.1.5.12 Router</h5><p>数据传输层接口，负责接收和发送 UPnP 和 UDP 消息，或者将接收到的数据流广播给局域网内的其他设备。<br>目前实现类为 RouterImpl 和 MockRouter，其中 MockRouter 仅用来作为测试时的 Mock 接口，RouterImpl 作为默认的数据传输层实现。</p>
<h6 id="1-enable"><a href="#1-enable" class="headerlink" title="(1) enable()"></a>(1) enable()</h6><p>启动。<br>得到配置中的NetworkAddressFactory，其目前实现为NetworkAddressFactoryImpl，调用startInterfaceBasedTransports()为NetworkAddressFactory的每个网络接口绑定一个多播接收器MulticastReceiver，用来监听多播地址，并处理获取到的数据。<br>KV 形式存储在multicastReceivers中;调用startAddressBasedTransportsNetworkAddressFactory的每个地址绑定一个StreamServer和DatagramIO，监听并进行数据处理。KV 形式存储在streamServers中。创建一个StreamClient用于发送 TCP 消息。</p>
<h6 id="2-disable"><a href="#2-disable" class="headerlink" title="(2) disable()"></a>(2) disable()</h6><p>停止。<br>停止StreamClient，停止streamServers中每个StreamServer，停止multicastReceivers中每个MulticastReceiver，停止datagramIOs中每个DatagramIO。<br>通过可重入锁写锁控制启动和停止的并发。</p>
<h6 id="3-getActiveStreamServers-InetAddress-preferredAddress"><a href="#3-getActiveStreamServers-InetAddress-preferredAddress" class="headerlink" title="(3) getActiveStreamServers(InetAddress preferredAddress)"></a>(3) getActiveStreamServers(InetAddress preferredAddress)</h6><p>根据 preferredAddress 得到活跃的 StreamServer，如果 preferredAddress 对应的 StreamServer 存在且活跃则返回，否则返回当前所有活跃的 StreamServer。</p>
<h6 id="4-received-IncomingDatagramMessage-msg"><a href="#4-received-IncomingDatagramMessage-msg" class="headerlink" title="(4) received(IncomingDatagramMessage msg)"></a>(4) received(IncomingDatagramMessage msg)</h6><p>根据消息类型得到协议并执行。</p>
<h6 id="5-发送数据"><a href="#5-发送数据" class="headerlink" title="(5) 发送数据"></a>(5) 发送数据</h6><p>send(StreamRequestMessage msg) 通过 StreamClient 发送 TCP 包。<br>send(OutgoingDatagramMessage msg) 向所有 datagramIO 发送 UDP 包。<br>broadcast(byte[] bytes) 向所有 datagramIO 广播发送数据。</p>
<h5 id="2-1-5-13-StreamClient"><a href="#2-1-5-13-StreamClient" class="headerlink" title="2.1.5.13 StreamClient"></a>2.1.5.13 StreamClient</h5><p>StreamClient 具体实现类为 AbstractStreamClient 以及其子类 StreamClientImpl。<br>在 Android 系统下使用的 Jetty 实现。在该类中具体的 http 协议处理由 HttpClient 实现，核心方法 sendRequest 用于创建请求并获取返回 response，请求及返回值通过 HttpContentExchange 封装，每一个 StreamRequestMessage 及其对应的 HttpContentExchange 通过 createCallable 方法封装为 Callable 对象，并将其压入 DefaultUpnpServiceConfiguration 中的 defaultExecutorService。在 call() 中调用 client.send(exchange) 发送 request 并获取 response。</p>
<h5 id="2-1-5-14-StreamServer"><a href="#2-1-5-14-StreamServer" class="headerlink" title="2.1.5.14 StreamServer"></a>2.1.5.14 StreamServer</h5><p>StreamServer 用来接收 HTTP 请求并进行处理。在 AndroidUpnpServiceConfiguration 中进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public StreamServer createStreamServer(NetworkAddressFactory networkAddressFactory) &#123;</div><div class="line">        // Use Jetty, start/stop a new shared instance of JettyServletContainer</div><div class="line">        return new AsyncServletStreamServerImpl(</div><div class="line">            new AsyncServletStreamServerConfigurationImpl(</div><div class="line">                JettyServletContainer.INSTANCE,</div><div class="line">                networkAddressFactory.getStreamListenPort()</div><div class="line">            )</div><div class="line">        );</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>本质上是由 Jetty 实现的 servlet 容器。从 HttpServletRequest 中获取数据流并传递给 Router 的 received(UpnpStream stream) 进行处理。JettyServletContainer 使用了单例模式，其中定义 Server 的具体实现，并使用 synchronized 同步 Server 属性变更操作。</p>
<h5 id="2-1-5-15-ReceivingNotification"><a href="#2-1-5-15-ReceivingNotification" class="headerlink" title="2.1.5.15 ReceivingNotification"></a>2.1.5.15 ReceivingNotification</h5><p>处理接收到的 notification 消息。如 ALIVE，BYEBYE。当接收到 ALIVE 消息后，会在后台启动一个线程执行 RetrieveRemoteDescriptors 获取该设备的信息。</p>
<h5 id="2-1-5-16-RetrieveRemoteDescriptors"><a href="#2-1-5-16-RetrieveRemoteDescriptors" class="headerlink" title="2.1.5.16 RetrieveRemoteDescriptors"></a>2.1.5.16 RetrieveRemoteDescriptors</h5><p>用来主动获取远端介绍详情，并返回 RemoteService 加入到 Registry 中。</p>
<h5 id="额外补充-MulticastSocket多播协议"><a href="#额外补充-MulticastSocket多播协议" class="headerlink" title="额外补充 MulticastSocket多播协议"></a>额外补充 MulticastSocket多播协议</h5><p>前面说过设备开启之后 启动MulticastSocket多播协议，<br>先来复习一下网络通讯中的三种模式：</p>
<p>在当前网络通信中（TCP/IP也不例外）有三种通信模式：<strong>单播、广播、组播(又叫多播, 个人感觉叫多播描述的有点不恰当)</strong>，其中多播出现的时间最晚，但同时具备单播和广播的优点，最具有发展前景。<br>通信方式分类：<br>    1.单播：单台主机与单台主机之间的通信；<br>    2.广播：单台主机与网络中所有主机的通信；<br>    3.组播：单台主机与选定的一组主机的通信；</p>
<h6 id="单播："><a href="#单播：" class="headerlink" title="单播："></a>单播：</h6><blockquote>
<pre><code>单播是网络通信中最常见的，网络节点之间的通信 就好像是人们之间的对话一样。如果一个人对另外一个人说话，
那么用网络技术的术语来描述就是“单播”，此时信息的接收和传递只在两个节点之间进行。
1. 单播的优点：
    (1)服务器以及响应客户端的请求；
    (2)服务器能针对每个客户端的不同请求发送不同的响应，容易显示个性化服务；
2. 单播的缺点：
    (1)服务器针对每个客户机发送数据流，服务器流量＝客户机数量×客户机流量；在客户数量大、每个客户机流量大的流媒体应用中服务器不堪重负；
3. 应用场景：
   单播在网络中得到了广泛的应用，网络上绝大部分的数据都 是以单播的形式传输的。例如：收发电子邮件、游览网页时，必须与邮件服务器、
   服务器建立连接，此时使用的就是单播通信方式；
</code></pre></blockquote>
<h6 id="广播："><a href="#广播：" class="headerlink" title="广播："></a>广播：</h6><blockquote>
<pre><code>“广播”可以比方为：一个人通过广播喇叭对在场的全体说话(他才不管你是否乐意听)。换句话说: 广播是一台主机对某一个网络上的所有主机发送数据报包。
这个网络可能是网络，也可能时子网，还有可能是所有子网。
广播有两类：本地广播和定向广播：
        定向广播：将数据报包发送到本网络之外的特定网络的所有主机，然而，由于互联网上的大部分路由器都不转发定向广播消息，所以这里不深入介绍了
        本地广播：将数据报包发送到本地网络的所有主机，IPv4的本地广播地址为“255.255.255.255”，路由器不会转发此广播；
1.广播的优点：
   (1)通信的效率高，信息一下子就可以传递到某一个网络上的所有主机。
   (2)由于服务器不用向每个客户端单独发送数据，所以服务器流量比较负载低；
2.广播的缺点：
   (1)非常占用网络的带宽；
   (2)缺乏针对性,也不管主机是否真的需要接收该数据, 就强制的接收数据；
3.应用场景：
   (1)有线电视就是典型的广播型网络
</code></pre></blockquote>
<h6 id="组播："><a href="#组播：" class="headerlink" title="组播："></a>组播：</h6><blockquote>
<pre><code> ”组播“可以比方为：你对着大街喊：”是男人的来一下，一人发一百块”，那么男的过来，女就不会过来,因为没有钱发她不理你(组播：其中所有的男生就是一个组)，
 换句话说: 组播是一台主机向指定的一组主机发送数据报包，因为如果采用单播方式，逐个节点传输，有多少个目标节点，就会有多少次传送过程，这种方式显然效率 极低，是不可取  
 的；如果采用不区分目标、全部发送的广播方式，虽然一次可以传送完数据，但是显然达不到区分特定数据接收对象的目的，又会占用网络带宽。采用组播方式，既可以 实现一次传送所
 有目标节点的数据，也可以达到只对特定对象传送数据的目的。
 IP网络的组播一般通过组播IP地址来实现。组播IP地址就是D类IP地址，即224.0.0.0至239.255.255.255之间的IP地址。
 1.组播的优点：
(1)具备广播所具备的所有优点；
(2)与单播相比，提供了发送数据报包的效率，与广播相比，减少了网络流量；
 2.组播的缺点：
(1)与单播协议相比没有纠错机制，发生丢包错包后难以弥补，但可以通过一定的容错机制和QOS加以弥补；
</code></pre></blockquote>
<p>没有代码bb个毛线，来实现一下：</p>
<h6 id="UDP单播的例子"><a href="#UDP单播的例子" class="headerlink" title="UDP单播的例子"></a>UDP单播的例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  </div><div class="line">// 客户端  </div><div class="line">public class ClientTest  </div><div class="line">&#123;  </div><div class="line">    private static final int MAXRECEIVED = 255;  </div><div class="line">  </div><div class="line">    public static void main(String[] args) throws IOException  </div><div class="line">    &#123;  </div><div class="line">        byte[] msg = new String(&quot;connect test successfully!!!&quot;).getBytes();  </div><div class="line">  </div><div class="line">        DatagramSocket client = new DatagramSocket();  </div><div class="line">  </div><div class="line">        InetAddress inetAddr = InetAddress.getLocalHost();  </div><div class="line">        SocketAddress socketAddr = new InetSocketAddress(inetAddr, 8888);  </div><div class="line">  </div><div class="line">        DatagramPacket sendPacket = new DatagramPacket(msg, msg.length,  </div><div class="line">                socketAddr);  </div><div class="line">  </div><div class="line">        client.send(sendPacket);  </div><div class="line">  </div><div class="line">        client.close();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">//服务端  </div><div class="line">public class ServerTest  </div><div class="line">&#123;  </div><div class="line">    private static final int MAXREV = 255;  </div><div class="line">  </div><div class="line">    public static void main(String[] args) throws IOException  </div><div class="line">    &#123;  </div><div class="line">        DatagramSocket server = new DatagramSocket(8888);  </div><div class="line">        DatagramPacket recvPacket = new DatagramPacket(new byte[MAXREV], MAXREV);  </div><div class="line">  </div><div class="line">        while (true)  </div><div class="line">        &#123;  </div><div class="line">            server.receive(recvPacket);  </div><div class="line">  </div><div class="line">            byte[] receiveMsg = Arrays.copyOfRange(recvPacket.getData(),  </div><div class="line">                    recvPacket.getOffset(),  </div><div class="line">                    recvPacket.getOffset() + recvPacket.getLength());  </div><div class="line">  </div><div class="line">            System.out.println(&quot;Handing at client &quot;  </div><div class="line">                    + recvPacket.getAddress().getHostName() + &quot; ip &quot;  </div><div class="line">                    + recvPacket.getAddress().getHostAddress());  </div><div class="line">  </div><div class="line">            System.out.println(&quot;Server Receive Data:&quot; + new String(receiveMsg));  </div><div class="line">  </div><div class="line">            server.send(recvPacket);  </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="UDP广播的例子"><a href="#UDP广播的例子" class="headerlink" title="UDP广播的例子"></a>UDP广播的例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//客户端  </div><div class="line">public class BroadcastSender  </div><div class="line">&#123;  </div><div class="line">    public static void main(String[] args) throws IOException  </div><div class="line">    &#123;  </div><div class="line">        byte[] msg = new String(&quot;connection successfully!!!&quot;).getBytes();  </div><div class="line">        /* </div><div class="line">         * 在Java UDP中单播与广播的代码是相同的,要实现具有广播功能的程序只需要使用广播地址即可, 例如：这里使用了本地的广播地址 </div><div class="line">         */  </div><div class="line">        InetAddress inetAddr = InetAddress.getByName(&quot;255.255.255.255&quot;);  </div><div class="line">        DatagramSocket client = new DatagramSocket();  </div><div class="line">  </div><div class="line">        DatagramPacket sendPack = new DatagramPacket(msg, msg.length, inetAddr,  </div><div class="line">                8888);  </div><div class="line">  </div><div class="line">        client.send(sendPack);  </div><div class="line">        System.out.println(&quot;Client send msg complete&quot;);  </div><div class="line">        client.close();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">//服务端  </div><div class="line">public class BroadcastReceive  </div><div class="line">&#123;  </div><div class="line">    public static void main(String[] args) throws IOException  </div><div class="line">    &#123;  </div><div class="line">  </div><div class="line">        DatagramPacket receive = new DatagramPacket(new byte[1024], 1024);  </div><div class="line">        DatagramSocket server = new DatagramSocket(8888);  </div><div class="line">  </div><div class="line">        System.out.println(&quot;---------------------------------&quot;);  </div><div class="line">        System.out.println(&quot;Server current start......&quot;);  </div><div class="line">        System.out.println(&quot;---------------------------------&quot;);  </div><div class="line">  </div><div class="line">        while (true)  </div><div class="line">        &#123;  </div><div class="line">            server.receive(receive);  </div><div class="line">  </div><div class="line">            byte[] recvByte = Arrays.copyOfRange(receive.getData(), 0,  </div><div class="line">                    receive.getLength());  </div><div class="line">  </div><div class="line">            System.out.println(&quot;Server receive msg:&quot; + new String(recvByte));  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="UDP组播的例子"><a href="#UDP组播的例子" class="headerlink" title="UDP组播的例子"></a>UDP组播的例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//客户端  </div><div class="line">public class MulticastSender  </div><div class="line">&#123;  </div><div class="line">    public static void main(String[] args) throws IOException  </div><div class="line">    &#123;  </div><div class="line">        int port = 8888;  </div><div class="line">        byte[] msg = &quot;Connection successfully!!!&quot;.getBytes();  </div><div class="line">  </div><div class="line">        InetAddress inetRemoteAddr = InetAddress.getByName(&quot;224.0.0.5&quot;);  </div><div class="line">  </div><div class="line">        /* </div><div class="line">         * Java UDP组播应用程序主要通过MulticastSocket实例进行通信,它是DatagramSocket的是一个子类, </div><div class="line">         * 其中包含了一些额外的可以控制多播的属性. </div><div class="line">         *  </div><div class="line">         * 注意： </div><div class="line">         *  </div><div class="line">         * 多播数据报包实际上可以通过DatagramSocket发送,只需要简单地指定一个多播地址。 </div><div class="line">         * 我们这里使用MulticastSocket,是因为它具有DatagramSocket没有的能力 </div><div class="line">         */  </div><div class="line">        MulticastSocket client = new MulticastSocket();  </div><div class="line">  </div><div class="line">        DatagramPacket sendPack = new DatagramPacket(msg, msg.length,  </div><div class="line">                inetRemoteAddr, port);  </div><div class="line">  </div><div class="line">        client.send(sendPack);  </div><div class="line">  </div><div class="line">        System.out.println(&quot;Client send msg complete&quot;);  </div><div class="line">  </div><div class="line">        client.close();  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">//服务端  </div><div class="line">public class MulticastReceive  </div><div class="line">&#123;  </div><div class="line">    public static void main(String[] args) throws IOException  </div><div class="line">    &#123;  </div><div class="line">        InetAddress inetRemoteAddr = InetAddress.getByName(&quot;224.0.0.5&quot;);  </div><div class="line">  </div><div class="line">        DatagramPacket recvPack = new DatagramPacket(new byte[1024], 1024);  </div><div class="line">  </div><div class="line">        MulticastSocket server = new MulticastSocket(8888);  </div><div class="line">  </div><div class="line">        /* </div><div class="line">         * 如果是发送数据报包,可以不加入多播组; 如果是接收数据报包,必须加入多播组; 这里是接收数据报包,所以必须加入多播组; </div><div class="line">         */  </div><div class="line">        server.joinGroup(inetRemoteAddr);  </div><div class="line">  </div><div class="line">        System.out.println(&quot;---------------------------------&quot;);  </div><div class="line">        System.out.println(&quot;Server current start......&quot;);  </div><div class="line">        System.out.println(&quot;---------------------------------&quot;);  </div><div class="line">  </div><div class="line">        while (true)  </div><div class="line">        &#123;  </div><div class="line">            server.receive(recvPack);  </div><div class="line">  </div><div class="line">            byte[] recvByte = Arrays.copyOfRange(recvPack.getData(), 0,  </div><div class="line">                    recvPack.getLength());  </div><div class="line">  </div><div class="line">            System.out.println(&quot;Server receive msg:&quot; + new String(recvByte));  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java-到底是值传递还是引用传递" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/24/Java-到底是值传递还是引用传递/" class="article-date">
      <time datetime="2017-10-24T07:06:00.000Z" itemprop="datePublished">2017-10-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/24/Java-到底是值传递还是引用传递/">Java 到底是值传递还是引用传递?</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p> Java 到底是值传递还是引用传递？不知道就进来看看吧~<br>
          
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a  href="/2017/10/24/Java-到底是值传递还是引用传递/#more">more&gt;&gt; >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-1024快乐-如何成为一个程序员-程序员入门进阶书籍推荐" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/24/1024快乐-如何成为一个程序员-程序员入门进阶书籍推荐/" class="article-date">
      <time datetime="2017-10-24T03:01:00.000Z" itemprop="datePublished">2017-10-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/24/1024快乐-如何成为一个程序员-程序员入门进阶书籍推荐/">1024快乐,如何成为一个程序员,程序员入门进阶书籍推荐</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>祝天下程序员们，1024节日快乐啊</p>
<p>自成为程序员已经三年了，总结一些读过的书和万年不变的话题Java怎么入门，很多人推《Thinking In Java》</p>
<p>而Think in java被誉为“java圣经”并没有夸张。不管你java是什么水平，每次读TIJ都会感到很有收获。新手会从中读到java的一些基础知识，进阶者可以看到更广阔的应用空间，老手会从中发现太多的思考方式，并梳理一些知识遗漏。最关键的是里面太多的内容可以给人启发，而且很多思想可以应用到其他的语言比如C++。另外整本书谬误相对很少，可以少走很多弯路。</p>
<p>群里有一个大牛是这么说的：能看得进去TIJ并且能学到东西的人，我才觉得或许有培养的想法。看不进去的人，我往往不想太费口舌。只会用各种框架和各种工具的程序员，他们的发展方向不过是一个熟练的代码工人。<br>
          
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/感悟/">感悟</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a  href="/2017/10/24/1024快乐-如何成为一个程序员-程序员入门进阶书籍推荐/#more">more&gt;&gt; >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入理解-“-”-equals" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/23/深入理解-“-”-equals/" class="article-date">
      <time datetime="2017-10-23T05:15:00.000Z" itemprop="datePublished">2017-10-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/23/深入理解-“-”-equals/">深入理解 &#34;==&#34; &amp; equals() </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h3 id="深入理解-“-”-amp-equals"><a href="#深入理解-“-”-amp-equals" class="headerlink" title="深入理解 “==”&amp; .equals()"></a>深入理解 “==”&amp; .equals()</h3><p>继上一片讲了String  里面涉及到了== 和 equals,这里来详细讲一下</p>
          
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a  href="/2017/10/23/深入理解-“-”-equals/#more">more&gt;&gt; >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入理解ThreadLocal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/21/深入理解ThreadLocal/" class="article-date">
      <time datetime="2017-10-20T19:47:00.000Z" itemprop="datePublished">2017-10-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/21/深入理解ThreadLocal/">深入理解ThreadLocal</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h4 id="深入理解ThreadLocal"><a href="#深入理解ThreadLocal" class="headerlink" title="深入理解ThreadLocal"></a>深入理解ThreadLocal</h4><p>今天解析了Handler messageQueue Loop三者的关系</p>
<p>新建一个Handler的时候同时会取出这个Handler对应的Looper对象,如果当前线程没有looper就报错.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public Handler() &#123;</div><div class="line">    ......</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用了Looper.myLooper()方法,让我们来看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static final Looper myLooper() &#123;  </div><div class="line">    return (Looper)sThreadLocal.get();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法非常简单，就是从sThreadLocal对象中取出Looper。如果sThreadLocal中有Looper存在就返回Looper.</p>
<p>这个Looper再哪设置呢?<br>
          
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a  href="/2017/10/21/深入理解ThreadLocal/#more">more&gt;&gt; >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Handler-postDelayed-的原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/20/Handler-postDelayed-的原理/" class="article-date">
      <time datetime="2017-10-20T03:34:00.000Z" itemprop="datePublished">2017-10-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/20/Handler-postDelayed-的原理/">Handler.postDelayed()的原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h3 id="Handler-postDelayed-的原理"><a href="#Handler-postDelayed-的原理" class="headerlink" title="Handler.postDelayed()的原理"></a>Handler.postDelayed()的原理</h3><p>今天有人在群里问Handler.postDelayed()运行在主线程的Loop里为什么没有阻塞主线程.<br>Handler.postDelayed()是先delay一定的时间，然后再放入messageQueue中，还是先直接放入MessageQueue中，还是先等待,到时间再放入队列？</p>
          
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a  href="/2017/10/20/Handler-postDelayed-的原理/#more">more&gt;&gt; >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 Ace
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>