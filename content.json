{"meta":{"title":"Zhangbing's Blog","subtitle":null,"description":"Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable","author":"Zhangbing","url":"http://zhangbing.cc","root":"/"},"pages":[{"title":"about","date":"2019-03-01T01:49:06.000Z","updated":"2019-03-01T01:49:06.597Z","comments":true,"path":"about/index.html","permalink":"http://zhangbing.cc/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-07T02:18:01.655Z","updated":"2019-03-07T02:18:01.650Z","comments":false,"path":"categories/index.html","permalink":"http://zhangbing.cc/categories/index.html","excerpt":"","text":"title: categories date: 2019-03-07 10:16:23"},{"title":"home","date":"2019-03-01T03:15:59.000Z","updated":"2019-03-01T03:15:59.093Z","comments":true,"path":"home/index.html","permalink":"http://zhangbing.cc/home/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-07T02:18:21.402Z","updated":"2019-03-07T02:18:21.348Z","comments":false,"path":"tags/index.html","permalink":"http://zhangbing.cc/tags/index.html","excerpt":"","text":"title: tags date: 2019-03-01 09:48:50"},{"title":"404","date":"2019-03-01T01:49:50.000Z","updated":"2019-03-01T01:49:50.255Z","comments":true,"path":"404/index.html","permalink":"http://zhangbing.cc/404/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解Android 消息机制：Handler、MessageQueue 和 Looper","slug":"HandlerMessagequeueLooper-1551427172528","date":"2019-03-01T07:59:32.000Z","updated":"2019-03-01T08:09:24.608Z","comments":true,"path":"2019/03/01/HandlerMessagequeueLooper-1551427172528/","link":"","permalink":"http://zhangbing.cc/2019/03/01/HandlerMessagequeueLooper-1551427172528/","excerpt":"Android 消息机制：Handler、MessageQueue 和 Looper在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：","text":"Android 消息机制：Handler、MessageQueue 和 Looper在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解： 1、Handler 的作用通常，当我们在非主线程当中做了异步的操作之后使用 Handler 来在主线程当中更新 UI。之所以这么设计无非就是因为 Android 中的 View 不是线程安全的。之所以将 View 设计成非线程安全的，是因为： 1).对 View 进行加锁之后会增加控件使用的复杂度；2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI， 确切来说它有两个作用： 任务调度：即通过 post() 和 send() 等方法来指定某个任务在某个时间执行； 线程切换：你也许用过 RxJava，但如果在 Android 中使用的话还要配合 RxAndroid，而这里的 RxAndroid 内部就使用 Handler 来实现线程切换。 下文中，我们就来分别看一下它的这两个功能的作用和原理。 1.1 任务调度使用 Hanlder 可以让一个任务在某个时间点执行或者等待某段时间之后执行。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 post() 和 sned() 两类方法。post() 类的用来指定某个 Runnable 在某个时间点执行，send() 类的用来指定某个 Message 在某个时间点执行。这里的 Message 是 Android 中定义的一个类。它内部有多个字段，比如 what、arg1、arg2、replyTo 和 sendingUid 来帮助我们指定该消息的内容和对象。同时， Message 还实现了 Parcelable 接口，这表明它可以被用来跨进程传输。此外，它内部还定义了一个 Message 类型的 next 字段，这表明 Message 可以被用作链表的结点。实际上 MessageQueue 里面只存放了一个 mMessage，即链表的头结点。所以，MessageQueue 内部的消息队列，本质上是一个单链表，每个链表的结点就是 Message。当调用 post() 类型的方法来调度某个 Runnable 的时候，首先会将其包装成一个 Message，然后再使用 send()类的方法进行任务分发。所以，不论是 post() 类的方法还是 send() 类的方法，最终都会使用 Handler 的 sendMessageAtTime() 方法来将其加入到队列中：12345678public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; // ... 无关代码 return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 使用 Handler 进行任务调度是非常简单的。下面的代码就实现了让一个 Runnable 在 500ms 之后执行的逻辑： 123456new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; // do something &#125;&#125;, 500); 上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。既然每个 Runnable 被 post() 发送之后还要被包装成 Message，那么 Message 的意义何在呢？Runnable 被包装的过程依赖于 Handler 内部的 getPostMessage() 方法。下面是该方法的定义： 12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 可见，我们的 Runnable 会被赋值给 Message 的 callback。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要： 首先，要使用 send() 类型的方法来传递我们的 Message 给 Handler； 然后，我们的 Handler 要覆写 handleMessage() 方法，并在该方法中获取每个 Message 并根据其内部的信息依次处理。 下面的一个例子用来演示 send() 类型的方法。首先，我们要定义 Handler 并覆写其 handleMessage() 方法来处理消息： 123456789101112private final static int SAY_HELLO = 1;private static Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SAY_HELLO: LogUtils.d(\"Hello!\"); break; &#125; &#125;&#125;; 然后，我们向该 Handler 发送消息： 123Message message = Message.obtain(handler);message.what = SAY_HELLO;message.sendToTarget(); 这样，我们的 Handler 接收到了消息并根据其 what 得知要 SAY_HELLO，于是就打印出了日志信息。除了调用 Message 的 sendToTarget() 方法，我们还可以直接调用 handler 的 sendMessage() 方法（sendToTarget() 内部调用了 handler 的 sendMessage()）。 1.2 线程切换下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。 123456789101112// 在主线程中获取 Handlerprivate static Handler handler = new Handler(); // 更新UI，会将消息发送到主线程当中new Thread(() -&gt; &#123; try &#123; Thread.sleep(2000); handler.post(() -&gt; getBinding().tv.setText(\"主线程更新UI\")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start(); 上面之所以能够在主线程当中更新 UI，主要是因为我们的 Handler 是在主线程当中进行获取的。随后，我们调用 handler 的 post() 方法之后，传入的 Runnable 会被包装成 Message，然后加入到主线程对应的消息队列中去，并由主线程对应的 Looper 获取到并执行。所以，就使得该 Runnable 的操作最终在主线程中完成。也许你会觉得先在主线程当中获取到 Handler 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 Looper 的 getMainLooper() 方法来获取主线程对应的 Looper，然后使用它来实例化一个 Handler 并使用该 Handler来处理消息： 12new Handler(Looper.getMainLooper()) .post(() -&gt; getBinding().tv.setText(\"主线程更新UI\")); 本质上，当我们调用 Handler 的无参构造方法，或者说不指定 Looper 的构造方法的时候，会直接使用当前线程对应的 Looper 来实例化 Handler。每个线程对应的 Looper 存储在该线程的局部变量 ThreadLocal 里。当某个线程的局部变量里面没有 Looper 的时候就会抛出一个异常。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。主线程对应的 Looper 会在 ActivityThread 的静态方法 main() 中被创建，它会调用 Looper 的 prepareMainLooper() 静态方法来创建主线程对应的 Looper。然后会调用 Looper 的 loop() 静态方法来开启 Looper 循环以不断处理消息。这里的 ActivityThread 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。ActivityThread 内部定义了一个内部类 H，它继承自 Handler，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 Looper。下面的代码中，我们开启了一个线程，并在线程中先调用 Looper 的 prepare() 静态方法，此时 Looper 会为我们当前的线程创建 Looper，然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息： 123456new Thread(() -&gt; &#123; LogUtils.d(\"+++++++++\" + Thread.currentThread()); Looper.prepare(); new Handler().post(() -&gt; LogUtils.d(\"+++++++++\" + Thread.currentThread())); Looper.loop();&#125;).start(); 从以上的内容我们可以看出，Handler 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 ThreadLocal 来对每个线程对应的Looper中的消息队列进行存储。 2、源码解析以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。 2.1 实例化 HandlerHandler 提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 Looper，另一种在构造方法中不需要指定任何 Looper，在构造方法内部会获取当前线程对应的 Looper 来初始化 Handler。第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作： 123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 第二种初始化的方式最终会调用下面的方法。这里使用 Looper 的静态方法 myLooper() 来获取当前线程对应的 Looper。如果当前线程不存在任何 Looper 就会抛出一个异常。 1234567891011121314151617181920public Handler(Callback callback, boolean async) &#123; // 潜在内存泄漏的检查 if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; // 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException(); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 而 Looper 的静态方法 myLooper() 会使用线程局部变量 sThreadLocal 来获取之前存储到该线程内部的 Looper： 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 2.2 Looper 的初始化前面我们也说过 Looper 的创建过程。对于主线程的 Looper 会在 ActivityThread 的 main() 方法中被调用： 12345678public static void main(String[] args) &#123; // ... 无关代码 Looper.prepareMainLooper(); // ... 无关代码 // 开启 Looper 循环 Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 这里调用了 Looper 的静态方法 prepareMainLooper() 来初始化主线程的 Looper： 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; 其内部先调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中，然后判断 sMainLooper 是否之前存在过。这是一种基本的单例校验，显然，我们只允许主线程的 Looper 被实例化一次。同样，非主线程的 Looper 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 prepare() 静态方法。它同样调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。 下面是 prepare() 方法的代码:12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 经过上述分析，我们可以得知，对于一个线程只能实例化一个 Looper，所以当我们在同一个线程中多次创建 Handler 实例，它们是共享一个 Looper 。或者说是一个 Looper 对应多个 Handler 也是可以的。 2.3 MessageQueue 的实例化相比于 Looper 和 Handler，MessageQueue 就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 native 的方法。你可以在 android_os_MessageQueue 查看其源码的定义。每当我们实例化一个 Looper 的时候会调用它的构造方法，并在其中实例化一个 MessageQueue： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在实例化 Handler 的小节中可以看出，每次实例化一个 Handler 的时候，会从当前线程对应的 Looper 中取出 MessageQueue。所以，这里我们又可以得出结论: 一个 Handler 对应一个 MessageQueue。 当我们实例化一个 MessageQueue 的时候会使用它的构造方法。这里会调用 native 层的 nativeInit() 方法来完成 MessageQueue 的初始化： 1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 在 native 层，nativeInit() 方法的定义如下： 123456789static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 上面我们可以看出，在该方法中实例化了一个NativeMessageQueue 之后返回了 mPtr 作为是 Java 层 MessageQueue 与NativeMessesageQueue 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 MessageQueue 同样使用 mPtr 来表示 native 层的消息队列。NativeMessageQueue 在 native 层的部分定义和其构造方法的定义如下。 12345678910class NativeMessageQueue : public MessageQueue, public LooperCallback &#123;// ... 无关代码NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 从上面我们可以看出，NativeMessageQueue 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper （其源码在 Looper）。 在 Android 的 native 层存在着一个于 Java 层类似的 Looper，它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信。当消息队列中有消息存入时，会唤醒 Native 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Native 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。 既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？ 这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长以至于无法处理其他事件的时候才会出现 ANR。上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下： 12345678910111213141516171819202122232425void Looper::rebuildEpollLocked() &#123; // 如果之前存在的话就关闭之前的 epoll 实例 if (mEpollFd &gt;= 0) &#123; mEpollFd.reset(); // 关闭旧的epoll实例 &#125; // 申请新的 epoll 实例，并且注册 “Wake管道” mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT)); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance: %s\", strerror(errno)); struct epoll_event eventItem; // 把未使用的数据区域进行置0操作 memset(&amp; eventItem, 0, sizeof(epoll_event)); eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd.get(); // 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd) int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\", strerror(errno)); // 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加 for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); // 将 request 队列的事件，分别添加到 epoll 实例 int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem); &#125;&#125; 这里涉及了 epoll 相关的知识。epoll 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。上面的代码中使用了 epoll_ctl 方法来将被监听的描述符添加到 epoll 句柄。关于 epoll 的指令，可以参考这篇博文 《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》。这部分代码的主要作用是创建一个 epoll 实例并用它来监听 event 触发。 2.4 消息的执行过程2.4.1 消息入队的过程在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 从上面可以看出，入队的时候实际上是使用了 MessageQueue 的 enqueueMessage() 方法。所以，我们再来看下该方法的定义： 123456789101112131415161718192021222324252627282930313233boolean enqueueMessage(Message msg, long when) &#123; // ... 无关代码，校验 synchronized (this) &#123; // ... 无关代码 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。这里的 nativeWake() 方法会最终调用 native 层的 Looper 的 awake() 方法： 123456789void Looper::wake() &#123; uint64_t inc = 1; ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d: %s\", mWakeEventFd.get(), strerror(errno)); &#125; &#125;&#125; 2.4.2 消息执行的过程在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。 123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper(); // .. 无关代码 final MessageQueue queue = me.mQueue; // .. 无关代码 for (;;) &#123; Message msg = queue.next(); // 可能会 bolck if (msg == null) &#123; return; &#125; // ... 无关代码 final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; // ... 无关代码 msg.recycleUnchecked(); &#125;&#125; 从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 MessageQueue 的 next() 方法来取出下一个消息并进行分发。这里我们先不看 next() 方法的定义。我们先把这个方法中涉及的部分分析一下。当获取到了下一个消息之后，会调用它的target 也就是发送该消息的 Handler 的 dispatchMessage() 方法来进行处理。该方法的定义如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 从上面可以看出，如果该消息是通过包装 Runnable 得到的话，会直接调用它的 handleCallback() 方法进行处理。在该方法内部会直接调用 Runnable 的 run() 方法。因为比较见到那，我们就不贴出代码了。然后，会根据 mCallback 是否为空来决定是交给 mCallback 进行处理还是内部的 handleMessage() 方法。这里的 mCallback 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 handleMessage() 方法，我们就再熟悉不过了，它就是我们创建 Handler 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 Handler 中进行处理了。以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 MessageQueue 是如何获取 “下一个” 消息的。 2.4.3 MessageQueue 的消息管理上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑： 1234567891011121314151617Message next() &#123; // 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。 final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 调用 native 的方法，可能会这个函数发生 block nativePollOnce(ptr, nextPollTimeoutMillis); // ... 无关代码 &#125;&#125; 从上面可以看出 Java 层的 MessageQueue 的 next() 方法是一个循环。除了获取消息队列之外，还要监听Natvie 层 Looper 的事件触发。通过调用 native 层的 nativePollOnce() 方法来实现。该方法内部又会调用 NativeMessageQueue 的 pollOnce() 方法。而且注意下，在下面的方法中，nativeMessageQueue 是从 Java 层的 mPtr 中获取到的。所以我们说，在初始化 MessageQueue 的时候得到的 mPtr 起到了桥梁的作用： 12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 在 NativeMessageQueue 的 pollOnce() 方法中会调用 native 层的 Looper 的 pollOnce()，并最终调用 native 层 Looper 的 pollInner() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192int Looper::pollInner(int timeoutMillis) &#123; // ... 根据下一个消息的事件调整超时时间 int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; // 将要空闲 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 待已注册之事件被触发或计时终了 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; // 不再空闲 mLock.lock(); // 请求锁 if (mEpollRebuildRequired) &#123; mEpollRebuildRequired = false; rebuildEpollLocked(); // 根据需要重建 epoll goto Done; &#125; // 进行检查 if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; result = POLL_ERROR; // 错误 goto Done; &#125; if (eventCount == 0) &#123; result = POLL_TIMEOUT; // 超时 goto Done; &#125; // 处理所有消息 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd.get()) &#123; // 唤醒 fd 有反应 if (epollEvents &amp; EPOLLIN) &#123; awoken(); // 已经唤醒了，则读取并清空管道数据 &#125; &#125; else &#123; // 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; // 将消息放进 mResponses 中 pushResponse(events, mRequests.valueAt(requestIndex)); &#125; &#125; &#125;Done: ; // 触发所有的消息回调，处理 Native 层的Message mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; &#123; // 获取 handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); &#125; // 释放 handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; &#125; else &#123; // 队列头部的消息决定了下个唤醒的时间 mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; mLock.unlock(); // 释放锁 // 触发所有的响应回调 for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); // 移除文件描述符 &#125; response.request.callback.clear(); result = POLL_CALLBACK; &#125; &#125; return result;&#125; 从上面我们可以看出 Native 层的 pollInner() 方法首先会根据 Java 层传入的 timeoutMillis 调用 epoll_wait 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 enqueueMessage() 方法的最后几行代码： 123if (needWake) &#123; nativeWake(mPtr);&#125; 即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。 3、总结在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。 3.1 Handler、MessageQueue 和 Looper 之间的关系首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示： HandlerMessageQueueLooper 也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。 3.2 Handler 的消息发送过程然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析： Handler 根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 Message 类型的数据。但不论哪种类型最终都会调用 Handler 的 sendMessageAtTime() 方法来加入到 MessageQueue 的队列中。区别在于，post 类型的方法需要经过 Handler 的 getPostMessage() 包装成 Message 之后再发送。 3.3 Looper 的执行过程当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 loop() 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述： Looper 当我们调用 Looper 的 loop()方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 next() 方法来获取下一个消息的时候，会调用 nativePollOnce() 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。","categories":[],"tags":[]},{"title":"ThreadLocal 源码深入分析","slug":"ThradLocalCodeRead1551409309746","date":"2019-03-01T03:01:49.000Z","updated":"2019-03-01T08:09:42.295Z","comments":true,"path":"2019/03/01/ThradLocalCodeRead1551409309746/","link":"","permalink":"http://zhangbing.cc/2019/03/01/ThradLocalCodeRead1551409309746/","excerpt":"ThreadLocal 源码深入分析以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～ ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 GC。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal 通常定义为 private static 类型。 假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，Thread作为key，变量作为value。事实上，JDK 中确实使用了类似 Map 的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中ThreadLocal的实现。","text":"ThreadLocal 源码深入分析以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～ ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 GC。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal 通常定义为 private static 类型。 假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，Thread作为key，变量作为value。事实上，JDK 中确实使用了类似 Map 的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中ThreadLocal的实现。 初探 ThreadLocal我们从 ThreadLocal 的几个成员变量入手： 12345678910111213141516171819private final int threadLocalHashCode = nextHashCode();/** * The next hash code to be given out. Updated atomically. Starts at * zero. */private static AtomicInteger nextHashCode = new AtomicInteger();/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; ThreadLocal 通过 threadLocalHashCode 来标识每一个 ThreadLocal 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(这个数的原理没有探究)。 再看 set 方法： 1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 可以看到通过Thread.currentThread()方法获取了当前的线程引用，并传给了getMap(Thread)方法获取一个ThreadLocalMap的实例。我们继续跟进getMap(Thread)方法： 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 可以看到getMap(Thread)方法直接返回Thread实例的成员变量threadLocals。它的定义在Thread内部，访问级别为package级别： 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 到了这里，我们可以看出，每个Thread里面都有一个ThreadLocal.ThreadLocalMap成员变量，也就是说每个线程通过ThreadLocal.ThreadLocalMap与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。 我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals。 ThreadLocal#createMap方法的源码如下： 1234void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 下面我们探究一下 ThreadLocalMap 的实现。 ThreadLocalMapThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下： ThreadLocalMap 可以看到ThreadLocalMap有一个常量和三个成员变量： 1234567891011121314151617/** * The initial capacity -- MUST be a power of two. */private static final int INITIAL_CAPACITY = 16;/** * The table, resized as necessary. * table.length MUST always be a power of two. */private Entry[] table;/** * The number of entries in the table. */private int size = 0;/** * The next size value at which to resize. */private int threshold; // Default to 0 其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。 Entry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下： 12345678910111213141516/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。 ThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)： 123456789101112/** * Construct a new map initially containing (firstKey, firstValue). * ThreadLocalMaps are constructed lazily, so we only create * one when we have at least one entry to put in it. */ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。 注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 2的指数，因为这可以使得hash发生冲突的次数减小。 接下来我们来看ThreadLocalMap#set方法的实现： 1234567891011121314151617181920212223242526272829303132/** * Set the value associated with key. * * @param key the thread local object * @param value the value to be set */private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 如果冲突了，就会通过nextIndex方法再次计算哈希值： 123456/** * Increment i modulo len. */private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125; 到这里，我们看到 ThreadLocalMap 解决冲突的方法是 线性探测法（不断加 1），而不是 HashMap 的 链地址法，这一点也能从 Entry 的结构上推断出来。 如果entry里对应的key为null的话，表明此entry为staled entry，就将其替换为当前的key和value： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Replace a stale entry encountered during a set operation * with an entry for the specified key. The value passed in * the value parameter is stored in the entry, whether or not * an entry already exists for the specified key. * * As a side effect, this method expunges all stale entries in the * \"run\" containing the stale entry. (A run is a sequence of entries * between two null slots.) * * @param key the key * @param value the value to be associated with key * @param staleSlot index of the first stale entry encountered while * searching for key. */private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; 具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。 若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）： 123456789101112131415161718192021222324252627282930313233343536373839/** * Heuristically scan some cells looking for stale entries. * This is invoked when either a new element is added, or * another stale one has been expunged. It performs a * logarithmic number of scans, as a balance between no * scanning (fast but retains garbage) and a number of scans * proportional to number of elements, that would find all * garbage but would cause some insertions to take O(n) time. * * @param i a position known NOT to hold a stale entry. The * scan starts at the element after i. * * @param n scan control: &#123;@code log2(n)&#125; cells are scanned, * unless a stale entry is found, in which case * &#123;@code log2(table.length)-1&#125; additional cells are scanned. * When called from insertions, this parameter is the number * of elements, but when from replaceStaleEntry, it is the * table length. (Note: all this could be changed to be either * more or less aggressive by weighting n instead of just * using straight log n. But this version is simple, fast, and * seems to work well.) * * @return true if any stale entries have been removed. */private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; 一旦发现一个位置对应的 Entry 所持有的 ThreadLocal 弱引用为null，就会把此位置当做 staleSlot 并调用 expungeStaleEntry 方法进行整理 (rehashing) 的操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). */private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 只要没有清理任何的 stale entries 并且 size 达到阈值的时候（即 table 已满，所有元素都可用），都会触发rehashing： 1234567891011121314151617181920212223/** * Re-pack and/or re-size the table. First scan the entire * table removing stale entries. If this doesn't sufficiently * shrink the size of the table, double the table size. */private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize();&#125;/** * Expunge all stale entries in the table. */private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125;&#125; rehash 操作会执行一次全表的扫描清理工作，并在 size 大于等于 threshold 的四分之三时进行 resize。但注意在 setThreshold 的时候又取了三分之二： 123456/** * Set the resize threshold to maintain at worst a 2/3 load factor. */private void setThreshold(int len) &#123; threshold = len * 2 / 3;&#125; 因此 ThreadLocalMap 的实际 load factor 为 3/4 * 2/3 = 0.5。 我们继续看 getEntry 的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125;/** * Version of getEntry method for use when key is not found in * its direct hash slot. * * @param key the thread local object * @param i the table index for key's hash code * @param e the entry at table[i] * @return the entry associated with key, or null if no such */private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; 逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用getEntryAfterMiss方法，根据线性探测法继续查找，直到找到或对应entry为null，并返回。 ThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法： 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; remove 方法的思想类似，直接放源码： 1234567891011121314151617/** * Remove the entry for key. */private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125;&#125; remove的时候同样也会调用expungeStaleEntry方法执行清理工作。 总结每个 Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的 ThreadLocal 被及时回收，不会造成内存泄露，又可以提升性能。假如我们把 ThreadLocalMap 做成一个 Map 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将 ThreadLocalMap 与线程相绑定的实现，完美地解决了这个问题。 总结一下什么时候无用的 Entry 会被清理： Thread 结束的时候插入元素时，发现 staled entry，则会进行替换并清理插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容调用 ThreadLocalMap 的 remove 方法或set(null) 时尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。 特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 remove 了。 总的来说，对于多线程资源共享的问题，同步机制采用了 以时间换空间 的方式，而 ThreadLocal 则采用了 以空间换时间 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。","categories":[],"tags":[]},{"title":"Android 源码分析之 AsyncTask 源码分析","slug":"AsyncTask20190228155539","date":"2019-02-28T07:54:26.000Z","updated":"2019-03-01T08:09:09.913Z","comments":true,"path":"2019/02/28/AsyncTask20190228155539/","link":"","permalink":"http://zhangbing.cc/2019/02/28/AsyncTask20190228155539/","excerpt":"Android 源码分析之 AsyncTask 源码分析1、AsyncTask的使用使用 AsyncTask 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 ThreadPoolExecutor 和 FutureTask等。AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 Params、Progress 和 Result，分别用来指定参数、进度和结果的值的类型。以及四个重要的方法，分别是 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()。这四个方法中，除了 doInBackground()，其他三个都是运行在UI线程的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 doInBackground() 运行在后台线程中，用来执行耗时的任务。","text":"Android 源码分析之 AsyncTask 源码分析1、AsyncTask的使用使用 AsyncTask 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 ThreadPoolExecutor 和 FutureTask等。AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 Params、Progress 和 Result，分别用来指定参数、进度和结果的值的类型。以及四个重要的方法，分别是 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()。这四个方法中，除了 doInBackground()，其他三个都是运行在UI线程的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 doInBackground() 运行在后台线程中，用来执行耗时的任务。 一种典型的使用方法如下： 123456789101112131415161718192021222324private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; @Override protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); if (isCancelled()) break; &#125; return totalSize; &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; setProgressPercent(progress[0]); &#125; @Override protected void onPostExecute(Long result) &#123; showDialog(\"Downloaded \" + result + \" bytes\"); &#125;&#125; 上面说 AsyncTask 有4个重要的方法，这里我们覆写了3个。doInBackground()运行在线程当中，耗时的任务可以放在这里进行；onProgressUpdate() 用来处理当任务的进度发生变化时候的逻辑；onPostExecute() 用来处理当任务执行完毕之后的逻辑。另外，这里我们还用到了 publishProgress() 和 isCancelled() 两个方法，分别用来发布任务进度和判断任务是否被取消。然后，我们可以用下面的方式来使用它： 1new DownloadFilesTask().execute(url1, url2, url3); 使用AsyncTask的时候要注意以下几点内容： AsyncTask 的类必须在主线程中进行加载，当在4.1之后这个过程会自动进行； AsyncTask 的对象必须在主线程中创建； execute()方法必须在UI线程中被调用； 不要直接调用 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()； 一个AsyncTask对象的 execute() 方法只能被调用一次； Android 1.6 之前，AsyncTask 是串行执行任务的；1.6 采用线程池处理并行任务；从 3.0 开始，又采用一个线程来串行执行任务。3.0 之后可以用 executeOnExecutor() 来并行地执行任务，如果我们希望在3.0之后能并行地执行上面的任务，那么我们应该这样去写： 1new DownloadFilesTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url1, url2, url3); 这里的 AsyncTask.THREAD_POOL_EXECUTOR 是 AsyncTask 内部定义的一个线程池，我们可以使用它来将 AsyncTask 设置成并行的。 2、AsyncTask源码分析2.1 AsyncTask 的初始化过程当初始化一个 AsyncTask 的时候，所有的重载构造方法都会调用下面的这个构造方法。这里做了几件事情： 初始化一个 Handler 对象 mHandler，该 Handler 用来将消息发送到它所在的线程中，通常使用默认的值，即主线程的 Handler； 初始化一个 WorkerRunnable 对象 mWorker。它是一个 WorkerRunnable 类型的实例，而 WorkerRunnable 又继承自 Callable，因此它是一个可以被执行的对象。我们会把在该对象中回调 doInBackground() 来将我们的业务逻辑放在线程池中执行。 初始化一个 FutureTask 对象 mFuture。该对象包装了 mWorker 并且当 mWorker 执行完毕之后会调用它的 postResultIfNotInvoked()方法来通知主线程（不论任务已经执行完毕还是被取消了，都会调用这个方法）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public AsyncTask(@Nullable Looper callbackLooper) &#123; // 1. 初始化用来发送消息的 Handler mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); // 2. 封装一个对象用来执行我们的任务 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 回调我们的业务逻辑 result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; // 发送结果给主线程 postResult(result); &#125; return result; &#125; &#125;; // 3. 初始化一个 FutureTask，并且当它执行完毕的时候，会调用 postResultIfNotInvoked 来将消息的执行结果发送到主线程中 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; // 如果任务没有被触发，也要发送一个结果 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 当这样设置完毕之后，我们就可以使用 execute() 方法来开始执行任务了。 2.2 AsyncTask 中任务的串行执行过程我们从 execute() 方法开始分析 AsyncTask: 12345678910111213141516171819@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; // 1.判断线程当前的状态 switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(...); case FINISHED: throw new IllegalStateException(...); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); // 2.回调生命周期方法 mWorker.mParams = params; // 3.赋值给可执行的对象 WorkerRunnable exec.execute(mFuture); // 4.在线程池中执行任务 return this;&#125; 当我们调用 AsyncTask 的 execute() 方法的时候会立即调用它的 executeOnExecutor() 方法。这里传入了两个参数，分别是一个 Executor 和任务的参数 params。从上面我们可以看出，当直接调用 execute() 方法的时候会使用默认的线程池 sDefaultExecutor，而当我们指定了线程池之后，会使用我们指定的线程池来执行任务。在 1 处，会对 AsyncTask 当前的状态进行判断，这就对应了前面说的，一个任务只能被执行一次。在 2 处会调用onPreExecute()方法，如果我们覆写了该方法，那么它就会在这个时候被调用。在 3 处的操作是在为 mWorker 赋值，即把调用 execute 方法时传入的参数赋值给了 mWorker。接下来，会将 mFuture 添加到线程池中执行。当我们不指定任何线程池的时候使用的 sDefaultExecutor 是一个串行的线程池，它的定义如下： 1234567891011121314151617181920212223242526272829303132public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; // 相当于对传入的Runnable进行了一层包装 r.run(); &#125; finally &#123; // 分配下一个任务 scheduleNext(); &#125; &#125; &#125;); // 如果当前没有正在执行的任务，那么就尝试从队列中取出并执行 if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; // 从队列中取任务并使用THREAD_POOL_EXECUTOR执行 if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 从上面我们可以看出，我们添加到线程池中的任务实际上并没有直接交给线程池来执行，而是对其进行了处理之后才执行的，SerialExecutor 通过内部维护了双端队列，每当一个 AsyncTask 调用 execute() 方法的时候都会被放在该队列当中进行排队。如果当前没有正在执行的任务，那么就从队列中取一个任务交给 THREAD_POOL_EXECUTOR 执行；当一个任务执行完毕之后又会调用 scheduleNext() 取下一个任务执行。也就是说，实际上 sDefaultExecutor 在这里只是起了一个任务调度的作用，任务最终还是交给 THREAD_POOL_EXECUTOR 执行的。这里的THREAD_POOL_EXECUTOR也是一个线程池，它在静态代码块中被初始化： 12345678static &#123; // 使用指定的参数创建一个线程池 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 我们也可以直接将这个静态的线程池作为我们任务执行的线程池而不是放在上面的队列中被串行地执行。 2.3 将任务执行的结果发送到其他线程上面的 WorkerRunnable 中已经用到了 postResult 方法，它用来将任务执行的结果发送给 Handler： 123456private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; mHandler 会在创建 AsyncTask 的时候初始化。我们可以通过 AsyncTask 的构造方法传入 Handler 和 Looper 来指定该对象所在的线程。当我们没有指定的时候，会使用 AsyncTask 内部的 InternalHandler 创建 Handler： 123456789101112131415161718192021222324252627282930313233private final Handler mHandler;public AsyncTask(@Nullable Looper callbackLooper) &#123; // 根据传入的参数创建Handler对象 mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper);&#125;private static Handler getMainHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; // 使用 InternalHandler 创建对象 sHandler = new InternalHandler(Looper.getMainLooper()); &#125; return sHandler; &#125;&#125;// AsyncTask 内部定义 的Handler 类型private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; // 根据传入的消息类型进行处理 switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 3、总结上面我们梳理了 AsyncTask 的大致过程，我们来梳理下：每当我们实例化一个 AsyncTask 的时候都会在内部封装成一个 Runnable 对象，该对象可以直接放在线程池中执行。这里存在两个线程池，一个是 SerialExecutor 一个是 THREAD_POOL_EXECUTOR，前者主要用来进行任务调度，即把交给线程的任务放在队列中进行排队执行，而时机上所有的任务都是在后者中执行完成的。这个两个线程池都是静态的字段，所以它们对应于整个类的。也就是说，当使用默认的线程池的时候，实例化的 AsyncTask 会一个个地，按照加入到队列中的顺序依次执行。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-12-18T01:59:04.000Z","updated":"2019-02-28T07:54:22.337Z","comments":true,"path":"2018/12/18/hello-world/","link":"","permalink":"http://zhangbing.cc/2018/12/18/hello-world/","excerpt":"","text":"换硬盘博客都丢了,就从头再来吧!","categories":[],"tags":[]}]}