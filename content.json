{"meta":{"title":"Zhangbing's Blog","subtitle":null,"description":"Remember what should be remembered, and forget what should be forgotten.Alter what is changeable, and accept what is mutable","author":"Zhangbing","url":"http://zhangbing.cc","root":"/"},"pages":[{"title":"404","date":"2019-03-01T01:49:50.000Z","updated":"2019-03-01T01:49:50.255Z","comments":true,"path":"404/index.html","permalink":"http://zhangbing.cc/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-03-01T01:49:06.000Z","updated":"2019-03-01T01:49:06.597Z","comments":true,"path":"about/index.html","permalink":"http://zhangbing.cc/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-07T02:18:01.655Z","updated":"2019-03-07T02:18:01.650Z","comments":false,"path":"categories/index.html","permalink":"http://zhangbing.cc/categories/index.html","excerpt":"","text":"title: categories date: 2019-03-07 10:16:23"},{"title":"home","date":"2019-03-01T03:15:59.000Z","updated":"2019-03-01T03:15:59.093Z","comments":true,"path":"home/index.html","permalink":"http://zhangbing.cc/home/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-08T09:23:44.000Z","updated":"2019-03-08T09:23:44.547Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhangbing.cc/tags/index-1.html","excerpt":"","text":""},{"title":"","date":"2019-03-08T09:24:06.639Z","updated":"2019-03-07T02:18:21.348Z","comments":false,"path":"tags/index.html","permalink":"http://zhangbing.cc/tags/index.html","excerpt":"","text":"title: tags date: 2019-03-01 09:48:50"}],"posts":[{"title":"JVM内存结构、 Java内存模型 以及 Java对象模型","slug":"JVMModel-1552035735257","date":"2019-03-08T09:02:15.000Z","updated":"2019-03-08T09:26:50.837Z","comments":true,"path":"2019/03/08/JVMModel-1552035735257/","link":"","permalink":"http://zhangbing.cc/2019/03/08/JVMModel-1552035735257/","excerpt":"","text":"JVM内存结构、 Java内存模型 以及 Java对象模型JVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。 可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。 一、JVM内存结构我们都知道，Java代码是要运行在虚拟机上的，Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故Java运行时内存结构，也就是指Java虚拟机的运行时内存结构。而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下： 1.JVM简介1.1线程私有区：这部分是线程独享 程序计数器：记录正在执行的虚拟机字节码的地址,行号；虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；本地方法栈：虚拟机的Native方法执行的内存区； 1.2线程共享区：Java堆：对象分配内存的区域；方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。 对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。 2. JVM结构详解运行时内存分为五大块区域（常量池属于方法区，算作一块区域），前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java内存总体结构图如下： 2.1 程序计数器PC程序计数器PC，当前线程所执行的字节码行号指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）。 从上面的介绍中我们知道程序计数器主要有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 2.2 虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。 虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)执行的同时都会创建一个栈帧结构，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。 2.2.1 栈帧(Stack Frame)结构 栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机栈的栈元素。见上图， 栈帧包括： 局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位,局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double),String引用类型，对象引用(reference类型)和returnAddress类型（它指向了一条字节码指令的地址） ,局部变量存储在局部变量表中，随着线程而生，线程而灭。并且线程间数据不共享。 操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配 动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。 前面的解析过程其实是静态解析； 对于运行期转化为直接引用，称为动态解析。 方法返回地址 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者 异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。 额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。 栈帧工作流程: 当Java应用程序调用函数调用时，会在调用堆栈上分配栈帧。栈帧包含调用方法的参数，其本地参数以及方法的返回地址。返回地址表示执行点，程序执行将在调用方法返回后继续执行。如果没有新栈帧的空间，则由Java虚拟机（JVM）抛出StackOverflowError。 可能耗尽Java应用程序堆栈的最常见情况是递归。在递归中，方法在执行期间调用自身。递归被认为是一种强大的通用编程技术，但必须谨慎使用，以避免StackOverflowError。 示例StackOverflowError： StackOverflowErrorExample.java：123456789101112131415public class StackOverflowErrorExample &#123; public static void recursivePrint(int num) &#123; System.out.println(\"Number: \" + num); if(num == 0) return; else recursivePrint(++num); &#125; public static void main(String[] args) &#123; StackOverflowErrorExample.recursivePrint(1); &#125;&#125; 在这个例子中，我们定义了一个递归方法，调用recursivePrint它打印一个整数，然后调用自身，下一个连续的整数作为参数。 使用-Xss1M指定线程堆栈大小等于1MB 的标志的示例执行如下所示： 12345678910111213141516171819202122Number: 1Number: 2Number: 3...Number: 6262Number: 6263Number: 6264Number: 6265Number: 6266Exception in thread \"main\" java.lang.StackOverflowError at java.io.PrintStream.write(PrintStream.java:480) at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291) at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104) at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185) at java.io.PrintStream.write(PrintStream.java:527) at java.io.PrintStream.print(PrintStream.java:669) at java.io.PrintStream.println(PrintStream.java:806) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:4) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9) at StackOverflowErrorExample.recursivePrint(StackOverflowErrorExample.java:9) 2.2.2 异常(Exception)Java虚拟机规范规定该区域有两种异常： StackOverFlowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出 2.3 本地方法栈本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。 异常(Exception)：Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。 2.4 Java堆Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。 从内存回收角度，Java堆被分为新生代和老年代；这样划分的好处是为了更快的回收内存；从内存分配角度，Java堆可以划分出线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)；这样划分的好处是为了更快的分配内存；对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下： 对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。 另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存. 异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 2.5 方法区 方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。 很多开发者更愿意把方法区称为“永久代”(Perm Gen)(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。 运行时常量池(Runtime Constant Pool)是方法区的一部分。 JDK 1.8 中，已经没有方法区(永久代)，而是将方法区直接放在一个与堆不相连的本地内存区域(Native Memory)，这个区域被叫做元空间。 异常(Exception)：Java虚拟机规范规定该区域可抛出OutOfMemoryError。 2.6 运行时常量池运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。 字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。符号引用：编译语言层面的概念，包括以下3类： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符但是该区域不会抛出OutOfMemoryError异常。 3. JVM总结一张图总结一下JVM Java内存模型Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所问。 在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的,他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。 Java对象模型Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型 总结我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。 JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbing.cc/categories/Java/"}],"tags":[{"name":"JVM内存结构","slug":"JVM内存结构","permalink":"http://zhangbing.cc/tags/JVM内存结构/"},{"name":"Java内存模型","slug":"Java内存模型","permalink":"http://zhangbing.cc/tags/Java内存模型/"},{"name":"Java对象模型","slug":"Java对象模型","permalink":"http://zhangbing.cc/tags/Java对象模型/"}]},{"title":"Android App/Activity 启动流程分析","slug":"activitystartstep-1551942246673","date":"2019-03-07T07:04:06.000Z","updated":"2019-03-08T09:26:29.286Z","comments":true,"path":"2019/03/07/activitystartstep-1551942246673/","link":"","permalink":"http://zhangbing.cc/2019/03/07/activitystartstep-1551942246673/","excerpt":"","text":"Android App/Activity 启动流程分析首先我们带着问题来看: 点击了图标之后系统道理做了哪些工作呢？ 应用进程是怎么被启动的呢？ Activity 的生命周期是什么时候被谁调用的呢？ 本文将继续基于 Android Nougat 的 Frameworks 层源码的解答这些问题。 阅读建议：如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。 1.1 调用过程分析1.1.1 Launcher.onClick在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 onClick 方法，packages/apps/Launcher3/src/com/android/launcher3/Launcher.java： 123456789101112131415161718192021222324public void onClick(View v) &#123; ... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; // 从快捷方式图标启动 onClickAppShortcut(v); &#125; else if (tag instanceof FolderInfo) &#123; // 文件夹 if (v instanceof FolderIcon) &#123; onClickFolderIcon(v); &#125; &#125; else if (v == mAllAppsButton) &#123; // “所有应用”按钮 onClickAllAppsButton(v); &#125; else if (tag instanceof AppInfo) &#123; // 从“所有应用”中启动的应用 startAppShortcutOrInfoActivity(v); &#125; else if (tag instanceof LauncherAppWidgetInfo) &#123; // 组件 if (v instanceof PendingAppWidgetHostView) &#123; onClickPendingWidget((PendingAppWidgetHostView) v); &#125; &#125;&#125; 1.1.2 Launcher.onClickAppShortcut如果是快捷方式图标，则调用 onClickAppShortcut 方法进而调用 startAppShortcutOrInfoActivity 方法： 1234567891011121314151617181920212223242526272829@Thunk void startAppShortcutOrInfoActivity(View v) &#123; Object tag = v.getTag(); final ShortcutInfo shortcut; final Intent intent; if (tag instanceof ShortcutInfo) &#123; shortcut = (ShortcutInfo) tag; // 去除对应的 Intent 对象 intent = shortcut.intent; int[] pos = new int[2]; v.getLocationOnScreen(pos); intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight())); &#125; else if (tag instanceof AppInfo) &#123; shortcut = null; intent = ((AppInfo) tag).intent; &#125; else &#123; throw new IllegalArgumentException(\"Input must be a Shortcut or AppInfo\"); &#125; // 调用 startActivitySafely 方法 boolean success = startActivitySafely(v, intent, tag); mStats.recordLaunch(v, intent, shortcut); if (success &amp;&amp; v instanceof BubbleTextView) &#123; mWaitingForResume = (BubbleTextView) v; mWaitingForResume.setStayPressed(true); &#125;&#125; 1.1.3 Launcher.startActivity获取相应 App 的 Intent 信息之后，调用 startActivity 方法：并设置Flags为Intent.FLAG_ACTIVITY_NEW_TASK,启动新的任务栈 12345678910111213141516171819202122232425private boolean startActivity(View v, Intent intent, Object tag) &#123; // 启动新的任务栈 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); try &#123; ... if (user == null || user.equals(UserHandleCompat.myUserHandle())) &#123; StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy(); try &#123; StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll() .penaltyLog().build()); // 调用 Activity 的 startActivity 方法 startActivity(intent, optsBundle); &#125; finally &#123; StrictMode.setVmPolicy(oldPolicy); &#125; &#125; else &#123; launcherApps.startActivityForProfile(intent.getComponent(), user, intent.getSourceBounds(), optsBundle); &#125; return true; &#125; catch (SecurityException e) &#123; ... &#125; return false;&#125; 1.1.4 Activity.startActivity这里最终调用了 Activity 中的 startActivity 方法，并且设置 Flag 为 FLAG_ACTIVITY_NEW_TASK。到此为止，已经跟启动普通的 Activity 流程汇合起来了，继续往下分析。frameworks/base/core/java/android/app/Activity.java： 1234567891011@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; // 第二个参数为 -1 表示不需要回调 onActivityResult 方法 if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125; 1.1.5 Activity.startActivityForResult调用 Activity 的 startActivityForResult 方法 123456789101112public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; // mParent 是当前 Activity 的父类，此时条件成立 if (mParent == null) &#123; // 调用 Instrumentation 的 execStartActivity 方法 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ... &#125; else &#123; ... &#125;&#125; 1.1.6 Instrumentation.execStartActivityframeworks/base/core/java/android/app/Instrumentation.java： 12345678910111213141516171819public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); // 获取 AMS 的代理对象并调用其 startActivity 方法 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 1.1.7 ActivityManagerProxy.startActivity以上过程是在 Launcher App所在的进程中发生的，由于远程 AMS(ActivityManagerService)跟使用 Service 的 Activity 不在同一个进程中，因此他们之间交互需要通过 Binder IPC 机制的支持，在这个过程中Client 首先获取到 Server 端的代理对象，在 Client 看来 ActivityManagerProxy 对象同样具有 ActivityManagerService 本地对象承诺的能力，因此 Client 可以调用 ActivityManagerProxy 跟 ActivityManagerService 对象进行数据交互，Binder 驱动作为桥梁在他们中间起到中间人的作用。同样，AMS 是运行在 system_server 线程中的，这时 AMS 就相当于 AIDL 中的远程 服务端，App 进程要与 AMS 交互，需要通过 AMS的代理对象 ActivityManagerProxy 来完成，来看 ActivityManagerNative.getDefault() 拿到的是什么：frameworks/base/core/java/android/app/ActivityManagerNative.java： 123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; getDefault 是一个静态变量： 1234567891011121314private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; // 向 ServiceManager 查询一个 key 为 \"activity\" 的引用 IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; ServiceManager 是 Binder IPC通信过程的核心，是上下文的管理者，Binder 服务端必须先向 ServerManager 注册才能够为客户端提供服务，Binder 客户端在与服务端通信之前需要从 ServerManager 中查找并获取 Binder 服务端的引用。 这里通过 “activity“ 这个名字向 ServiceManager 查询 AMS 的引用，获取 AMS 的引用后，调用 asInterface 方法： 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; // 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章 IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; // 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回 return new ActivityManagerProxy(obj);&#125; 因为 AMS 与 Launcher App 不在同一个进程中，这里返回的 IBinder 对象是一个 Binder 代理对象，因此这类将其包装成 ActivityManagerProxy对象并返回，ActivityManagerProxy 是ActivityManagerNative 的内部类，查看 ActivityManagerProxy 类 ： 1234567891011121314151617181920212223242526272829303132333435363738class ActivityManagerProxy implements IActivityManager&#123; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; ... // 调用号为 START_ACTIVITY_TRANSACTION mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; ... public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws RemoteException &#123; ... mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); ComponentName res = ComponentName.readFromParcel(reply); data.recycle(); reply.recycle(); return res; &#125; ...&#125; 可以看到，ActivityManagerProxy 里面将客户端的请求通过 mRemote.transact 进行转发，mRemote 对象正是 Binder 驱动返回来的 Binder 服务端的 Proxy 对象，通过 这个Binder Proxy，Binder 驱动最终将调用处于 Binder Server 端 ActivityManagerNative 中的 onTransact 方法： 12345678910111213141516171819202122232425@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // 根据方法调用号 code 决定调用哪个方法 switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; ... // 调用 startActivity 方法 int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; ... case START_SERVICE_TRANSACTION: &#123; ... ComponentName cn = startService(app, service, resolvedType, callingPackage, userId); reply.writeNoException(); ComponentName.writeToParcel(cn, reply); return true; &#125; ... &#125;&#125; 1.1.8 ActivityManagerService.startActivityActivityManagerNative 是一个抽象类，它的 startActivity 为抽象方法，具体的实现在 frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 中： 12345678@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; 1.2 小结你应该可以发现，相对于 AIDL 的调用过程，调用方 Launcher App 相当于 AIDL 过程中的 Clinent端；AMS 相当于远程 Service 的角色，充当 Server 端角色，他们的调用过程总体上都是一样的。从 Launcher App 到 AMS 的时序图如下： 2. AMS —— zygote2.1 调用过程分析2.1.1 ActivityManagerService.startActivityAsUser接着从 AMS 的 startActivityAsUser 方法开始分析： 12345678910111213@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. // 调用 ActivityStarter 的 startActivityMayWait 方法 return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);&#125; 2.1.2 ActivityStarter.startActivityMayWait继续跟进 frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java： 123456789101112131415161718192021final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ... synchronized (mService) &#123; ... // 调用 startActivityLocked 方法 int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask); ... return res; &#125;&#125; 2.1.3 ActivityStarter.startActivityLocked查看 startActivityLocked 方法： 1234567891011121314final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ... // 调用 doPendingActivityLaunchesLocked 方法，传入 false 参数 doPendingActivityLaunchesLocked(false); ... return err;&#125; 2.1.4 ActivityStarter.doPendingActivityLaunchesLocked查看 doPendingActivityLaunchesLocked 方法： 12345678910111213141516final void doPendingActivityLaunchesLocked(boolean doResume) &#123; while (!mPendingActivityLaunches.isEmpty()) &#123; final PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); final boolean resume = doResume &amp;&amp; mPendingActivityLaunches.isEmpty(); try &#123; // 调用 startActivityUnchecked 方法 final int result = startActivityUnchecked(pal.r, pal.sourceRecord, null, null, pal.startFlags, resume, null, null); postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, mSourceRecord, mTargetStack); &#125; catch (Exception e) &#123; Slog.e(TAG, \"Exception during pending activity launch pal=\" + pal, e); pal.sendErrorResult(e.getMessage()); &#125; &#125;&#125; 2.1.5 ActivityStarter.startActivityUnchecked查看 startActivityUnchecked 方法： 123456789private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ... // 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法 mSupervisor.resumeFocusedStackTopActivityLocked(); ... return START_SUCCESS;&#125; 2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLockedframeworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java： 123456789101112boolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; // 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法 mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false;&#125; 2.1.7 ActivityStack.resumeTopActivityUncheckedLocked查看 ActivityStack 的 resumeTopActivityUncheckedLocked 方法：1234567891011boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ... try &#123; ... // 调用 resumeTopActivityInnerLocked 方法 result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 2.1.8 ActivityStack.resumeTopActivityInnerLocked查看 resumeTopActivityInnerLocked 方法：12345678910111213141516private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... final ActivityRecord next = topRunningActivityLocked(); ... if (next.app != null &amp;&amp; next.app.thread != null) &#123; ... &#125; else &#123; ... if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Restarting \" + next); // 调用 ActivityStackSupervisor 的 startSpecificActivityLocked 方法 mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; 2.1.9 ActivityStackSupervisor.startSpecificActivityLocked回到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法：123456789101112131415161718192021222324void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // 当前 Activity 附属的 Application ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); // 如果 Application 已经运行 if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !\"android\".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; &#125; // 如果 Application 没有运行,调用AMS,启动新进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; 首先，在方法中获取了当前 Activity 附属的 Application，如果已经在运行了，说明这个 App 是已经被启动过了的，这时候调用 realStartActivityLocked 方法就可以进入下一步的流程了，同一个 App 中不同 Activity 的相互启动就是走的这个流程。当 Application 没有运行的时候，就需要调用 AMS 的 startProcessLocked 方法启动一个进程去承载它然后完成后续的工作，顺便铺垫一下，当新进程被启动完成后还会调用回到这个方法，查看 AMS 的 startProcessLocked 方法： 2.1.10 ActivityManagerService.startProcessLocked123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123; return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */);&#125; 2.1.11 ActivityManagerService.startProcessLocked调用 startProcessLocked 方法：123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)&#123; ... startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, \"startProcess: done starting proc!\"); return (app.pid != 0) ? app : null;&#125; 2.1.12 ActivityManagerService.startProcessLocked调用 startProcessLocked 的重载方法：123456789101112131415private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)&#123; ... try &#123; ... // 调用 Process 的 start 方法 Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); ... &#125; catch (RuntimeException e) &#123; ... &#125;&#125; 2.1.13 Process.startframeworks/base/services/core/java/android/os/Process.java：12345678910111213141516171819202122public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; // 调用 startViaZygote 方法 return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; 2.1.14 Process.startViaZygote查看 startViaZygote 方法：123456789101112131415161718private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ... // 调用 zygoteSendArgsAndGetResult 方法，传入 openZygoteSocketIfNeeded 的返回值 return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125; 2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded查看 zygoteSendArgsAndGetResult 方法：1234567891011121314151617181920212223242526272829303132333435private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; ... final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // 等待 socket 服务端（即zygote）返回新创建的进程pid; result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125;&#125; 在 zygoteSendArgsAndGetResult 中等待 Socket 服务端，也就是 zygote 进程返回创建新进程的结果，这里 zygoteState 参数是由 openZygoteSocketIfNeeded 方法返回的，openZygoteSocketIfNeeded 方法则负责根据 abi 向 Zygote 进程发起连接请求：1234567891011121314151617181920212223242526272829private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; // 向主zygote发起connect()操作 primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; // 当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作 secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 2.2 小结如果是从桌面新启动一个 App 中的 Activity，此时是没有进程去承载这个 App 的，因此需要通过 AMS 向 zygote 继承发起请求去完成这个任务，AMS 运行在 system_server 进程中，它通过 Socket 向 zygote 发起 fock 进程的请求，从 AMS 开始的调用时序图如下： 3. zygote —— ActivityThread3.1 调用过程分析3.1.1 ZygoteInit.mainzygote 进程的其中一项任务就是： 调用 registerZygoteSocket()函数建立 Socket 通道，使 zygote 进程成为 Socket 服务端，并通过runSelectLoop() 函数等待 ActivityManagerService 发送请求创建新的应用程序进程。 zygote 终于要再次上场了！接下来从 ZygoteInit.java 的 main 方法开始回顾一下 zygote 进程的工作： frameworks/base/core/java/com/android/internal/os/ZygoteInit.java：123456789101112public static void main(String argv[]) &#123; try &#123; ... runSelectLoop(abiList); .... &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; closeServerSocket(); throw ex; &#125;&#125; 3.1.2 ZygoteInit.runSelectLoop查看 runSelectLoop 方法：12345678910111213141516171819202122232425private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ... // 循环读取状态 while (true) &#123; ... for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; // 读取的状态不是客户端连接或者数据请求时，进入下一次循环 if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123;// i = 0 表示跟客户端 Socket 连接上了 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123;// i &gt; 0 表示接收到客户端 Socket 发送过来的请求 // runOnce 方法创建一个新的应用程序进程 boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 3.1.3 ZygoteConnection.runOnce查看 frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java 的 runOnce 方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; // 读取 socket 客户端发送过来的参数列表 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; // EOF reached. closeSocket(); return true; &#125; ... try &#123; // 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式 parsedArgs = new Arguments(args); ... // 同样调用 Zygote.java 的 forkAndSpecialize 方法 fock 出子进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (Exception e) &#123; ... &#125; try &#123; if (pid == 0) &#123; // 子进程执行 IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; // 进入子进程流程 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); return true; &#125; else &#123; // 父进程执行 IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 3.1.4 ZygoteConnection.handleChildProc首先解析 Socket 客户端传过来的参数，Zygote.java 的 forkAndSpecialize 返回的 pid == 0 的时候表示此时在 fock 出来的子进程中执行，继续调用 handleChildProc 方法，并将参数继续层层传递：123456789101112131415161718192021private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; /*由于 fock 出来的 system_server 进程会复制 zygote 进程的地址空间，因此它也得到了 zygote 进程中的 Socket，这个 Socket 对它来说并无用处，这里将其关闭 */ closeSocket(); ZygoteInit.closeServerSocket(); ... if (parsedArgs.niceName != null) &#123; // 设置进程名 Process.setArgV0(parsedArgs.niceName); &#125; if (parsedArgs.invokeWith != null) &#123; ... &#125; else &#123; // 调用 RuntimeInit 的 zygoteInit 方法 RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null); &#125;&#125; 3.1.5 RuntimeInit.zygoteInit查看 frameworks/base/core/java/com/android/internal/os/RuntimeInit.java 的 zygoteInit 方法：12345678910111213141516public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); // 重定向 log 输出 redirectLogStreams(); // 初始化一些通用的设置 commonInit(); /** *通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 的 *onZygoteInit 方法启动 Binder 线程池， 使 system_server 进程可以使用 Binder *与其他进程通信 **/ nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 3.1.6 RuntimeInit.applicationInit继续调用 applicationInit 方法：123456private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; ... // 提取出参数里面的要启动的类的名字 invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125; 3.1.7 RuntimeInit.invokeStaticMain主要调用了 invokeStaticMain 方法：123456789101112131415161718192021222324252627282930private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; /** className 为通过 Socket 客户端（AMS）传递过来的一系列参数中的其中一个，这里获取到的值为传\"com.android.app.ActivityThread\"，然后通过反射得到 ActivityThread 类 **/ cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; // 找到 ActivityThread 类的 main 方法 m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出 捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 3.1.8 MethodAndArgsCaller.run回到 ZygoteInit 的 main 方法：123456789101112public static void main(String argv[]) &#123; ... closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; // 接收到 caller 对象后调用它的 run 方法 caller.run(); &#125; catch (RuntimeException ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 跟 system_server 进程的启动过程一样，这里同样通过抛出异常的方式来清空调用 ActivityThread.main之前的方法栈帧。ZygoteInit 的 MethodAndArgsCaller 类是一个 Exception 类，同时也实现了 Runnable 接口：123456789101112131415161718192021public static class MethodAndArgsCaller extends Exception implements Runnable &#123; private final Method mMethod; private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; // 调用传递过来的 mMethod mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; ... &#125; &#125;&#125; 3.1.9 ActivityThread .main最后通过反射调用到 ActivityThread 的 main 方法：12345678910111213141516171819202122public static void main(String[] args) &#123; ... Environment.initForCurrentUser(); ... Process.setArgV0(\"&lt;pre-initialized&gt;\"); // 创建主线程 Looper Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); // attach 到系统进程 thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; // 主线程进入轮询状态 Looper.loop(); // 抛出异常说明轮询出现问题 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 3.2 小结zygote 进程作为 Socket 服务端在接收到作为客户端的 AMS 发送过来的请求和参数之后，fock 出新的进程并根据各种参数进程了初始化的工作，这个过程和 zygote 启动 system_server 进程的过程如出一辙，时序图如下所示： 4. ActivityThread —— Activity##4.1 调用过程分析 4.1.1 ActivityThread.attach上一小节的最后，ActivityThread 的 main 通过反射被运行起来了，接着会调用 ActivityThread 的 attach 方法： 123456789101112131415161718private void attach(boolean system) &#123; ... mSystemThread = system; if (!system) &#123; ... // 获取 ActivityManagerProxy 对象 final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; // 通过 Binder 调用 AMS 的 attachApplication 方法 mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; else &#123; ... &#125; ...&#125; 这里，我们再一次通过 Binder IPC 机制跟 AMS 通信，通信模型跟前面Launcher App调用 AMS 的 startActivity 方法一样，getDefault 过程不重复分析，这次是调用了 AMS 的 attachApplication 方法，注意这里将 ApplicationThead 类型的 mAppThread 对象作为参数传递了过去，ApplicationThead 是 ActivityThread 的一个内部类，后面我们会讲到，先查看 AMP 的 attachApplication 方法： 4.1.2 ActivityManagerProxy.attachApplication12345678910public void attachApplication(IApplicationThread app) throws RemoteException &#123; ... // 调用 asBinder 方法使其能够跨进程传输 data.writeStrongBinder(app.asBinder()); // 通过 transact 方法将数据交给 Binder 驱动 mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 4.1.3 ActivityManagerNative.onTransact123456789101112131415161718public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; ... case ATTACH_APPLICATION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); // 获取 ApplicationThread 的代理对象，这里返回的是 ApplicationThreadNative(ATN) // 的内部类：ApplicationThreadProxy(ATP) 对象 IApplicationThread app = ApplicationThreadNative.asInterface(data.readStrongBinder()); if (app != null) &#123; // 委托给 AMS 执行 attachApplication(app); &#125; reply.writeNoException(); return true; &#125; ... &#125;&#125; asInterface 将 ActivityThread 对象转换成了 ApplicationThreadNative 的 Binder 代理对象 ApplicationThreadProxy，并作为参数传给 attachApplication 方法，其中 ApplicationThreadProxy 是 ApplicationThreadNative 的内部类。 4.1.4 ActivityManagerService.attachApplication12345678public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; 4.1.5 ActivityManagerService.attachApplicationLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ProcessRecord app; ... try &#123; // 绑定死亡通知 AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; &#125; catch (RemoteException e) &#123; app.resetPackageList(mProcessStats); // 如果 system_server 进程死亡则重新启动进程 startProcessLocked(app, \"link fail\", processName); return false; &#125; ... try &#123; ... // 获取应用appInfo ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info; ... // 绑定应用 thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); ... &#125; catch (Exception e) &#123; app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); // bindApplication 失败也要重启进程 startProcessLocked(app, \"bind fail\", processName); return false; &#125; // 如果是 Activity: 检查最顶层可见的Activity是否等待在该进程中运行 if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // 如果是 Service: 寻找所有需要在该进程中运行的服务 if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // 如果是 BroadcastReceiver: 检查是否在这个进程中有下一个广播接收者 if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; didSomething |= sendPendingBroadcastsLocked(app); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // 检查是否在这个进程中有下一个 backup 代理 if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.appInfo.uid == app.uid) &#123; ensurePackageDexOpt(mBackupTarget.appInfo.packageName); try &#123; thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; if (badApp) &#123; // 杀掉 badApp app.kill(\"error during init\", true); handleAppDiedLocked(app, false, true); return false; &#125; if (!didSomething) &#123; // 更新 adj(组件的权值) updateOomAdjLocked(); &#125; return true;&#125; 首先，通过 ApplicationThreadProxy 使用 Binder 向 ApplicationThreadProxy 发起 bindApplication 请求，然后通过 normalMode 字段判断是否为 Activity，如果是则执行 ActivityStackSupervisor 的 attachApplicationLocked 方法。 4.1.5.1 ActivityThread.java::ApplicationThread.bindApplicationthread 对象类型是 ApplicationThreadProxy，通过 Binder 驱动调到了 ApplicationThreadNative 的方法，ApplicationThreadNative 是一个抽象类，它的实现都委托给了 ApplicationThread(这跟 AMS 跟 AMN 的关系一样)，ApplicationThread 作为 ActivityThread 的内部类存在，它的 binderApplication 方法如下：12345678910111213141516ActivityThread.java::ApplicationThread：public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; if (services != null) &#123; // 将services缓存起来, 减少binder检索服务的次数 ServiceManager.initServiceCache(services); &#125; ... // 发送消息 H.BIND_APPLICATION 给 Handler 对象 sendMessage(H.BIND_APPLICATION, data);&#125; H 是 ActivityThread 中的一个 Handler 对象，用于处理发送过来的各种消息：1234567891011121314private class H extends Handler &#123; public static final int BIND_APPLICATION = 110; public void handleMessage(Message msg) &#123; ... case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... &#125;&#125; 调用了 handleBindApplication 方法：1234567891011121314151617181920212223242526private void handleBindApplication(AppBindData data) &#123; // 获取 LoadedApk 对象 data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); ... // 创建 ContextImpl 上下文 final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); ... // 创建 Instrumentation 对象 if (data.instrumentationName != null) &#123; ... &#125; else &#123; mInstrumentation = new Instrumentation(); &#125; try &#123; // 调用 LoadedApk 的 makeApplication 方法创建 Application Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... mInstrumentation.onCreate(data.instrumentationArgs); // 调用 Application.onCreate 方法 mInstrumentation.callApplicationOnCreate(app); &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125;&#125; 4.1.5.2 ActivityStackSupervisor.attachApplicationLocked在 4.1.4 小节中通过 Binder 向 ActivityThread 发起 bindApplication 请求后，会根据启动组件的类型去做相应的处理，如果是 Acitivity，则会调用 ActivityStackSupervisor 的 attachApplicationLocked 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; // 获取前台stack中栈顶第一个非 finishing 状态的 Activity ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; // 真正的启动 Activity if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (RemoteException e) &#123; throw e; &#125; &#125; &#125; &#125; &#125; ... return didSomething;&#125;##### 4.1.5.2.1 ActivityStackSupervisor.realStartActivityLocked前面 **2.1.8ActivityStackSupervisor.startSpecificActivityLocked** 小节中分析过，如果当前 `Activity` 依附的 `Application` 已经被启动，则调用 `realStartActivityLocked` 方法，否则创建新的进程，再创建新的进程之后，两个流程的在这里合并起来了：```javafinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... final ActivityStack stack = task.stack; try &#123; ... app.forceProcessStateUpTo(mService.mTopProcessState); // 通过 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法 app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... &#125; catch (RemoteException e) &#123; if (r.launchFailed) &#123; // 第二次启动失败，则结束该 Activity mService.appDiedLocked(app); stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null, \"2nd-crash\", false); return false; &#125; // 第一个启动失败，则重启进程 app.activities.remove(r); throw e; &#125; ... return true;&#125;``` 这里有一次使用 `Binder` 调用 `ApplicationThread` 的 `scheduleLaunchActivity` 方法。##### 4.1.5.2.2 ApplicationThread.scheduleLaunchActivity```javapublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ... updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); ... sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 上面提到过，H 是 ActivityThread 中一个 Handler 类，它接收到 LAUNCH_ACTIVITY 消息后会调用 handleLaunchActivity 方法。 4.1.5.2.3 ActivityThread.handleLaunchActivity123456789101112131415161718192021222324private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... // 初始化 WMS WindowManagerGlobal.initialize(); // 执行 performLaunchActivity 方法 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; // 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); r.paused = true; &#125; &#125; else &#123; // 停止该 Activity ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); &#125;&#125; 4.1.4.2.4 ApplicationThread.performLaunchActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); // Instrumentation 中使用反射创建 Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); ... &#125; catch (Exception e) &#123; ... &#125; try &#123; // 创建 Application 对象并调用 Application 的 onCreate 方法 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; ... // attach 到 Window 上 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; // 设置主题 activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; // 重新创建的 Activity mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; // 第一次创建的 Activity mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... &#125; ... &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; 4.1.5.2.5 Instrumentation.callActivityOnCreate1234567public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123; prePerformCreate(activity); // 调用 Activity 的 performCreate 方法 activity.performCreate(icicle, persistentState); postPerformCreate(activity);&#125; 4.1.5.2.6 Activity.performCreate123456final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle, persistentState); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; 终于，onCreate 方法被调用了！！！ 4.2 小结从 ActivityThread 到最终 Activity 被创建及生命周期被调用，核心过程涉及到了三次 Binder IPC 过程，分别是： 1. ActivityThread 调用 AMS 的 attachApplication 方法 2. AMS 调用 ApplicationThread 的 bindApplication 方法 3. ActivityStackSupervisor 调用 Application 的 attachApplicationLocked 方法 整个过程的时序图如下： 总结纵观整个过程，从 Launcher 到 AMS、从 AMS 再到 Zygote、再从 Zygote 到 ActivityThread，最后在 ActivitThread 中层层调用到 Activity 的生命周期方法，中间涉及到了无数的细节，但总体上脉络还是非常清晰的，各个 Android 版本的 Framework 层代码可以某些过程的实现不太一样，但是整个调用流程大体上也是相同的，借用 Gityuan 大神的一张图作为结尾：","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangbing.cc/categories/Android/"}],"tags":[{"name":"Activity 启动流程分析","slug":"Activity-启动流程分析","permalink":"http://zhangbing.cc/tags/Activity-启动流程分析/"}]},{"title":"深入理解Android 消息机制：Handler、MessageQueue 和 Looper","slug":"HandlerMessagequeueLooper-1551427172528","date":"2019-03-01T07:59:32.000Z","updated":"2019-03-08T09:25:40.081Z","comments":true,"path":"2019/03/01/HandlerMessagequeueLooper-1551427172528/","link":"","permalink":"http://zhangbing.cc/2019/03/01/HandlerMessagequeueLooper-1551427172528/","excerpt":"Android 消息机制：Handler、MessageQueue 和 Looper在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：","text":"Android 消息机制：Handler、MessageQueue 和 Looper在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解： 1、Handler 的作用通常，当我们在非主线程当中做了异步的操作之后使用 Handler 来在主线程当中更新 UI。之所以这么设计无非就是因为 Android 中的 View 不是线程安全的。之所以将 View 设计成非线程安全的，是因为： 1).对 View 进行加锁之后会增加控件使用的复杂度；2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI， 确切来说它有两个作用： 任务调度：即通过 post() 和 send() 等方法来指定某个任务在某个时间执行； 线程切换：你也许用过 RxJava，但如果在 Android 中使用的话还要配合 RxAndroid，而这里的 RxAndroid 内部就使用 Handler 来实现线程切换。 下文中，我们就来分别看一下它的这两个功能的作用和原理。 1.1 任务调度使用 Hanlder 可以让一个任务在某个时间点执行或者等待某段时间之后执行。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 post() 和 sned() 两类方法。post() 类的用来指定某个 Runnable 在某个时间点执行，send() 类的用来指定某个 Message 在某个时间点执行。这里的 Message 是 Android 中定义的一个类。它内部有多个字段，比如 what、arg1、arg2、replyTo 和 sendingUid 来帮助我们指定该消息的内容和对象。同时， Message 还实现了 Parcelable 接口，这表明它可以被用来跨进程传输。此外，它内部还定义了一个 Message 类型的 next 字段，这表明 Message 可以被用作链表的结点。实际上 MessageQueue 里面只存放了一个 mMessage，即链表的头结点。所以，MessageQueue 内部的消息队列，本质上是一个单链表，每个链表的结点就是 Message。当调用 post() 类型的方法来调度某个 Runnable 的时候，首先会将其包装成一个 Message，然后再使用 send()类的方法进行任务分发。所以，不论是 post() 类的方法还是 send() 类的方法，最终都会使用 Handler 的 sendMessageAtTime() 方法来将其加入到队列中：12345678public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; // ... 无关代码 return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 使用 Handler 进行任务调度是非常简单的。下面的代码就实现了让一个 Runnable 在 500ms 之后执行的逻辑： 123456new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; // do something &#125;&#125;, 500); 上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。既然每个 Runnable 被 post() 发送之后还要被包装成 Message，那么 Message 的意义何在呢？Runnable 被包装的过程依赖于 Handler 内部的 getPostMessage() 方法。下面是该方法的定义： 12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 可见，我们的 Runnable 会被赋值给 Message 的 callback。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要： 首先，要使用 send() 类型的方法来传递我们的 Message 给 Handler； 然后，我们的 Handler 要覆写 handleMessage() 方法，并在该方法中获取每个 Message 并根据其内部的信息依次处理。 下面的一个例子用来演示 send() 类型的方法。首先，我们要定义 Handler 并覆写其 handleMessage() 方法来处理消息： 123456789101112private final static int SAY_HELLO = 1;private static Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SAY_HELLO: LogUtils.d(\"Hello!\"); break; &#125; &#125;&#125;; 然后，我们向该 Handler 发送消息： 123Message message = Message.obtain(handler);message.what = SAY_HELLO;message.sendToTarget(); 这样，我们的 Handler 接收到了消息并根据其 what 得知要 SAY_HELLO，于是就打印出了日志信息。除了调用 Message 的 sendToTarget() 方法，我们还可以直接调用 handler 的 sendMessage() 方法（sendToTarget() 内部调用了 handler 的 sendMessage()）。 1.2 线程切换下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。 123456789101112// 在主线程中获取 Handlerprivate static Handler handler = new Handler(); // 更新UI，会将消息发送到主线程当中new Thread(() -&gt; &#123; try &#123; Thread.sleep(2000); handler.post(() -&gt; getBinding().tv.setText(\"主线程更新UI\")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;).start(); 上面之所以能够在主线程当中更新 UI，主要是因为我们的 Handler 是在主线程当中进行获取的。随后，我们调用 handler 的 post() 方法之后，传入的 Runnable 会被包装成 Message，然后加入到主线程对应的消息队列中去，并由主线程对应的 Looper 获取到并执行。所以，就使得该 Runnable 的操作最终在主线程中完成。也许你会觉得先在主线程当中获取到 Handler 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 Looper 的 getMainLooper() 方法来获取主线程对应的 Looper，然后使用它来实例化一个 Handler 并使用该 Handler来处理消息： 12new Handler(Looper.getMainLooper()) .post(() -&gt; getBinding().tv.setText(\"主线程更新UI\")); 本质上，当我们调用 Handler 的无参构造方法，或者说不指定 Looper 的构造方法的时候，会直接使用当前线程对应的 Looper 来实例化 Handler。每个线程对应的 Looper 存储在该线程的局部变量 ThreadLocal 里。当某个线程的局部变量里面没有 Looper 的时候就会抛出一个异常。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。主线程对应的 Looper 会在 ActivityThread 的静态方法 main() 中被创建，它会调用 Looper 的 prepareMainLooper() 静态方法来创建主线程对应的 Looper。然后会调用 Looper 的 loop() 静态方法来开启 Looper 循环以不断处理消息。这里的 ActivityThread 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。ActivityThread 内部定义了一个内部类 H，它继承自 Handler，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 Looper。下面的代码中，我们开启了一个线程，并在线程中先调用 Looper 的 prepare() 静态方法，此时 Looper 会为我们当前的线程创建 Looper，然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息： 123456new Thread(() -&gt; &#123; LogUtils.d(\"+++++++++\" + Thread.currentThread()); Looper.prepare(); new Handler().post(() -&gt; LogUtils.d(\"+++++++++\" + Thread.currentThread())); Looper.loop();&#125;).start(); 从以上的内容我们可以看出，Handler 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 ThreadLocal 来对每个线程对应的Looper中的消息队列进行存储。 2、源码解析以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。 2.1 实例化 HandlerHandler 提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 Looper，另一种在构造方法中不需要指定任何 Looper，在构造方法内部会获取当前线程对应的 Looper 来初始化 Handler。第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作： 123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 第二种初始化的方式最终会调用下面的方法。这里使用 Looper 的静态方法 myLooper() 来获取当前线程对应的 Looper。如果当前线程不存在任何 Looper 就会抛出一个异常。 1234567891011121314151617181920public Handler(Callback callback, boolean async) &#123; // 潜在内存泄漏的检查 if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; // 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException(); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 而 Looper 的静态方法 myLooper() 会使用线程局部变量 sThreadLocal 来获取之前存储到该线程内部的 Looper： 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 2.2 Looper 的初始化前面我们也说过 Looper 的创建过程。对于主线程的 Looper 会在 ActivityThread 的 main() 方法中被调用： 12345678public static void main(String[] args) &#123; // ... 无关代码 Looper.prepareMainLooper(); // ... 无关代码 // 开启 Looper 循环 Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 这里调用了 Looper 的静态方法 prepareMainLooper() 来初始化主线程的 Looper： 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125; 其内部先调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中，然后判断 sMainLooper 是否之前存在过。这是一种基本的单例校验，显然，我们只允许主线程的 Looper 被实例化一次。同样，非主线程的 Looper 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 prepare() 静态方法。它同样调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。 下面是 prepare() 方法的代码:12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 经过上述分析，我们可以得知，对于一个线程只能实例化一个 Looper，所以当我们在同一个线程中多次创建 Handler 实例，它们是共享一个 Looper 。或者说是一个 Looper 对应多个 Handler 也是可以的。 2.3 MessageQueue 的实例化相比于 Looper 和 Handler，MessageQueue 就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 native 的方法。你可以在 android_os_MessageQueue 查看其源码的定义。每当我们实例化一个 Looper 的时候会调用它的构造方法，并在其中实例化一个 MessageQueue： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在实例化 Handler 的小节中可以看出，每次实例化一个 Handler 的时候，会从当前线程对应的 Looper 中取出 MessageQueue。所以，这里我们又可以得出结论: 一个 Handler 对应一个 MessageQueue。 当我们实例化一个 MessageQueue 的时候会使用它的构造方法。这里会调用 native 层的 nativeInit() 方法来完成 MessageQueue 的初始化： 1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 在 native 层，nativeInit() 方法的定义如下： 123456789static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 上面我们可以看出，在该方法中实例化了一个NativeMessageQueue 之后返回了 mPtr 作为是 Java 层 MessageQueue 与NativeMessesageQueue 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 MessageQueue 同样使用 mPtr 来表示 native 层的消息队列。NativeMessageQueue 在 native 层的部分定义和其构造方法的定义如下。 12345678910class NativeMessageQueue : public MessageQueue, public LooperCallback &#123;// ... 无关代码NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 从上面我们可以看出，NativeMessageQueue 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper （其源码在 Looper）。 在 Android 的 native 层存在着一个于 Java 层类似的 Looper，它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信。当消息队列中有消息存入时，会唤醒 Native 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Native 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。 既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？ 这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长以至于无法处理其他事件的时候才会出现 ANR。上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下： 12345678910111213141516171819202122232425void Looper::rebuildEpollLocked() &#123; // 如果之前存在的话就关闭之前的 epoll 实例 if (mEpollFd &gt;= 0) &#123; mEpollFd.reset(); // 关闭旧的epoll实例 &#125; // 申请新的 epoll 实例，并且注册 “Wake管道” mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT)); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance: %s\", strerror(errno)); struct epoll_event eventItem; // 把未使用的数据区域进行置0操作 memset(&amp; eventItem, 0, sizeof(epoll_event)); eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd.get(); // 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd) int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\", strerror(errno)); // 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加 for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); // 将 request 队列的事件，分别添加到 epoll 实例 int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem); &#125;&#125; 这里涉及了 epoll 相关的知识。epoll 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。上面的代码中使用了 epoll_ctl 方法来将被监听的描述符添加到 epoll 句柄。关于 epoll 的指令，可以参考这篇博文 《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》。这部分代码的主要作用是创建一个 epoll 实例并用它来监听 event 触发。 2.4 消息的执行过程2.4.1 消息入队的过程在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 从上面可以看出，入队的时候实际上是使用了 MessageQueue 的 enqueueMessage() 方法。所以，我们再来看下该方法的定义： 123456789101112131415161718192021222324252627282930313233boolean enqueueMessage(Message msg, long when) &#123; // ... 无关代码，校验 synchronized (this) &#123; // ... 无关代码 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。这里的 nativeWake() 方法会最终调用 native 层的 Looper 的 awake() 方法： 123456789void Looper::wake() &#123; uint64_t inc = 1; ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d: %s\", mWakeEventFd.get(), strerror(errno)); &#125; &#125;&#125; 2.4.2 消息执行的过程在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。 123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper(); // .. 无关代码 final MessageQueue queue = me.mQueue; // .. 无关代码 for (;;) &#123; Message msg = queue.next(); // 可能会 bolck if (msg == null) &#123; return; &#125; // ... 无关代码 final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; // ... 无关代码 msg.recycleUnchecked(); &#125;&#125; 从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 MessageQueue 的 next() 方法来取出下一个消息并进行分发。这里我们先不看 next() 方法的定义。我们先把这个方法中涉及的部分分析一下。当获取到了下一个消息之后，会调用它的target 也就是发送该消息的 Handler 的 dispatchMessage() 方法来进行处理。该方法的定义如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 从上面可以看出，如果该消息是通过包装 Runnable 得到的话，会直接调用它的 handleCallback() 方法进行处理。在该方法内部会直接调用 Runnable 的 run() 方法。因为比较见到那，我们就不贴出代码了。然后，会根据 mCallback 是否为空来决定是交给 mCallback 进行处理还是内部的 handleMessage() 方法。这里的 mCallback 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 handleMessage() 方法，我们就再熟悉不过了，它就是我们创建 Handler 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 Handler 中进行处理了。以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 MessageQueue 是如何获取 “下一个” 消息的。 2.4.3 MessageQueue 的消息管理上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑： 1234567891011121314151617Message next() &#123; // 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。 final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 调用 native 的方法，可能会这个函数发生 block nativePollOnce(ptr, nextPollTimeoutMillis); // ... 无关代码 &#125;&#125; 从上面可以看出 Java 层的 MessageQueue 的 next() 方法是一个循环。除了获取消息队列之外，还要监听Natvie 层 Looper 的事件触发。通过调用 native 层的 nativePollOnce() 方法来实现。该方法内部又会调用 NativeMessageQueue 的 pollOnce() 方法。而且注意下，在下面的方法中，nativeMessageQueue 是从 Java 层的 mPtr 中获取到的。所以我们说，在初始化 MessageQueue 的时候得到的 mPtr 起到了桥梁的作用： 12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 在 NativeMessageQueue 的 pollOnce() 方法中会调用 native 层的 Looper 的 pollOnce()，并最终调用 native 层 Looper 的 pollInner() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192int Looper::pollInner(int timeoutMillis) &#123; // ... 根据下一个消息的事件调整超时时间 int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; // 将要空闲 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 待已注册之事件被触发或计时终了 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; // 不再空闲 mLock.lock(); // 请求锁 if (mEpollRebuildRequired) &#123; mEpollRebuildRequired = false; rebuildEpollLocked(); // 根据需要重建 epoll goto Done; &#125; // 进行检查 if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; result = POLL_ERROR; // 错误 goto Done; &#125; if (eventCount == 0) &#123; result = POLL_TIMEOUT; // 超时 goto Done; &#125; // 处理所有消息 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd.get()) &#123; // 唤醒 fd 有反应 if (epollEvents &amp; EPOLLIN) &#123; awoken(); // 已经唤醒了，则读取并清空管道数据 &#125; &#125; else &#123; // 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; // 将消息放进 mResponses 中 pushResponse(events, mRequests.valueAt(requestIndex)); &#125; &#125; &#125;Done: ; // 触发所有的消息回调，处理 Native 层的Message mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; &#123; // 获取 handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); &#125; // 释放 handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; &#125; else &#123; // 队列头部的消息决定了下个唤醒的时间 mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; mLock.unlock(); // 释放锁 // 触发所有的响应回调 for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); // 移除文件描述符 &#125; response.request.callback.clear(); result = POLL_CALLBACK; &#125; &#125; return result;&#125; 从上面我们可以看出 Native 层的 pollInner() 方法首先会根据 Java 层传入的 timeoutMillis 调用 epoll_wait 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 enqueueMessage() 方法的最后几行代码： 123if (needWake) &#123; nativeWake(mPtr);&#125; 即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。 3、总结在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。 3.1 Handler、MessageQueue 和 Looper 之间的关系首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示： HandlerMessageQueueLooper 也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。 3.2 Handler 的消息发送过程然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析： Handler 根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 Message 类型的数据。但不论哪种类型最终都会调用 Handler 的 sendMessageAtTime() 方法来加入到 MessageQueue 的队列中。区别在于，post 类型的方法需要经过 Handler 的 getPostMessage() 包装成 Message 之后再发送。 3.3 Looper 的执行过程当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 loop() 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述： Looper 当我们调用 Looper 的 loop()方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 next() 方法来获取下一个消息的时候，会调用 nativePollOnce() 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangbing.cc/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://zhangbing.cc/tags/Handler/"},{"name":"MessageQueue","slug":"MessageQueue","permalink":"http://zhangbing.cc/tags/MessageQueue/"},{"name":"Looper","slug":"Looper","permalink":"http://zhangbing.cc/tags/Looper/"},{"name":"Android 消息机制","slug":"Android-消息机制","permalink":"http://zhangbing.cc/tags/Android-消息机制/"}]},{"title":"ThreadLocal 源码深入分析","slug":"ThradLocalCodeRead1551409309746","date":"2019-03-01T03:01:49.000Z","updated":"2019-03-08T09:25:55.534Z","comments":true,"path":"2019/03/01/ThradLocalCodeRead1551409309746/","link":"","permalink":"http://zhangbing.cc/2019/03/01/ThradLocalCodeRead1551409309746/","excerpt":"ThreadLocal 源码深入分析以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～ ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 GC。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal 通常定义为 private static 类型。 假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，Thread作为key，变量作为value。事实上，JDK 中确实使用了类似 Map 的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中ThreadLocal的实现。","text":"ThreadLocal 源码深入分析以前只知道 ThreadLocal 的大致思路，没有去深入研究。今天读了读源码，果然博大精深～ ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 GC。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal 通常定义为 private static 类型。 假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用HashMap来实现，Thread作为key，变量作为value。事实上，JDK 中确实使用了类似 Map 的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中ThreadLocal的实现。 初探 ThreadLocal我们从 ThreadLocal 的几个成员变量入手： 12345678910111213141516171819private final int threadLocalHashCode = nextHashCode();/** * The next hash code to be given out. Updated atomically. Starts at * zero. */private static AtomicInteger nextHashCode = new AtomicInteger();/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; ThreadLocal 通过 threadLocalHashCode 来标识每一个 ThreadLocal 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(这个数的原理没有探究)。 再看 set 方法： 1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 可以看到通过Thread.currentThread()方法获取了当前的线程引用，并传给了getMap(Thread)方法获取一个ThreadLocalMap的实例。我们继续跟进getMap(Thread)方法： 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 可以看到getMap(Thread)方法直接返回Thread实例的成员变量threadLocals。它的定义在Thread内部，访问级别为package级别： 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 到了这里，我们可以看出，每个Thread里面都有一个ThreadLocal.ThreadLocalMap成员变量，也就是说每个线程通过ThreadLocal.ThreadLocalMap与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。 我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用ThreadLocalMap.ThreadLocalMap#set方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给Thread.threadLocals。 ThreadLocal#createMap方法的源码如下： 1234void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 下面我们探究一下 ThreadLocalMap 的实现。 ThreadLocalMapThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下： ThreadLocalMap 可以看到ThreadLocalMap有一个常量和三个成员变量： 1234567891011121314151617/** * The initial capacity -- MUST be a power of two. */private static final int INITIAL_CAPACITY = 16;/** * The table, resized as necessary. * table.length MUST always be a power of two. */private Entry[] table;/** * The number of entries in the table. */private int size = 0;/** * The next size value at which to resize. */private int threshold; // Default to 0 其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。 Entry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下： 12345678910111213141516/** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。 ThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)： 123456789101112/** * Construct a new map initially containing (firstKey, firstValue). * ThreadLocalMaps are constructed lazily, so we only create * one when we have at least one entry to put in it. */ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; 构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。 注意一个细节，计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 2的指数，因为这可以使得hash发生冲突的次数减小。 接下来我们来看ThreadLocalMap#set方法的实现： 1234567891011121314151617181920212223242526272829303132/** * Set the value associated with key. * * @param key the thread local object * @param value the value to be set */private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 如果冲突了，就会通过nextIndex方法再次计算哈希值： 123456/** * Increment i modulo len. */private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125; 到这里，我们看到 ThreadLocalMap 解决冲突的方法是 线性探测法（不断加 1），而不是 HashMap 的 链地址法，这一点也能从 Entry 的结构上推断出来。 如果entry里对应的key为null的话，表明此entry为staled entry，就将其替换为当前的key和value： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Replace a stale entry encountered during a set operation * with an entry for the specified key. The value passed in * the value parameter is stored in the entry, whether or not * an entry already exists for the specified key. * * As a side effect, this method expunges all stale entries in the * \"run\" containing the stale entry. (A run is a sequence of entries * between two null slots.) * * @param key the key * @param value the value to be associated with key * @param staleSlot index of the first stale entry encountered while * searching for key. */private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; 具体实现不再深究，这替换过程里面也进行了不少的垃圾清理动作以防止引用关系存在而导致的内存泄露。 若是经历了上面步骤没有命中hash，也没有发现无用的Entry，set方法就会创建一个新的Entry，并会进行启发式的垃圾清理，用于清理无用的Entry。主要通过cleanSomeSlots方法进行清理（清理的时机通常为添加新元素或另一个无用的元素被回收时。参见注释）： 123456789101112131415161718192021222324252627282930313233343536373839/** * Heuristically scan some cells looking for stale entries. * This is invoked when either a new element is added, or * another stale one has been expunged. It performs a * logarithmic number of scans, as a balance between no * scanning (fast but retains garbage) and a number of scans * proportional to number of elements, that would find all * garbage but would cause some insertions to take O(n) time. * * @param i a position known NOT to hold a stale entry. The * scan starts at the element after i. * * @param n scan control: &#123;@code log2(n)&#125; cells are scanned, * unless a stale entry is found, in which case * &#123;@code log2(table.length)-1&#125; additional cells are scanned. * When called from insertions, this parameter is the number * of elements, but when from replaceStaleEntry, it is the * table length. (Note: all this could be changed to be either * more or less aggressive by weighting n instead of just * using straight log n. But this version is simple, fast, and * seems to work well.) * * @return true if any stale entries have been removed. */private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; 一旦发现一个位置对应的 Entry 所持有的 ThreadLocal 弱引用为null，就会把此位置当做 staleSlot 并调用 expungeStaleEntry 方法进行整理 (rehashing) 的操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). */private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 只要没有清理任何的 stale entries 并且 size 达到阈值的时候（即 table 已满，所有元素都可用），都会触发rehashing： 1234567891011121314151617181920212223/** * Re-pack and/or re-size the table. First scan the entire * table removing stale entries. If this doesn't sufficiently * shrink the size of the table, double the table size. */private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize();&#125;/** * Expunge all stale entries in the table. */private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125;&#125; rehash 操作会执行一次全表的扫描清理工作，并在 size 大于等于 threshold 的四分之三时进行 resize。但注意在 setThreshold 的时候又取了三分之二： 123456/** * Set the resize threshold to maintain at worst a 2/3 load factor. */private void setThreshold(int len) &#123; threshold = len * 2 / 3;&#125; 因此 ThreadLocalMap 的实际 load factor 为 3/4 * 2/3 = 0.5。 我们继续看 getEntry 的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Get the entry associated with key. This method * itself handles only the fast path: a direct hit of existing * key. It otherwise relays to getEntryAfterMiss. This is * designed to maximize performance for direct hits, in part * by making this method readily inlinable. * * @param key the thread local object * @return the entry associated with key, or null if no such */private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125;/** * Version of getEntry method for use when key is not found in * its direct hash slot. * * @param key the thread local object * @param i the table index for key's hash code * @param e the entry at table[i] * @return the entry associated with key, or null if no such */private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; 逻辑很简单，hash以后如果是ThreadLocal对应的Entry就返回，否则调用getEntryAfterMiss方法，根据线性探测法继续查找，直到找到或对应entry为null，并返回。 ThreadLocal的get方法就是调用了ThreadLocalMap的getEntry方法： 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; remove 方法的思想类似，直接放源码： 1234567891011121314151617/** * Remove the entry for key. */private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125;&#125; remove的时候同样也会调用expungeStaleEntry方法执行清理工作。 总结每个 Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的 ThreadLocal 被及时回收，不会造成内存泄露，又可以提升性能。假如我们把 ThreadLocalMap 做成一个 Map 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将 ThreadLocalMap 与线程相绑定的实现，完美地解决了这个问题。 总结一下什么时候无用的 Entry 会被清理： Thread 结束的时候插入元素时，发现 staled entry，则会进行替换并清理插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容调用 ThreadLocalMap 的 remove 方法或set(null) 时尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。 特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 remove 了。 总的来说，对于多线程资源共享的问题，同步机制采用了 以时间换空间 的方式，而 ThreadLocal 则采用了 以空间换时间 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。","categories":[{"name":"Java","slug":"Java","permalink":"http://zhangbing.cc/categories/Java/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://zhangbing.cc/tags/ThreadLocal/"}]},{"title":"Android 源码分析之 AsyncTask 源码分析","slug":"AsyncTask20190228155539","date":"2019-02-28T07:54:26.000Z","updated":"2019-03-08T09:24:42.266Z","comments":true,"path":"2019/02/28/AsyncTask20190228155539/","link":"","permalink":"http://zhangbing.cc/2019/02/28/AsyncTask20190228155539/","excerpt":"Android 源码分析之 AsyncTask 源码分析1、AsyncTask的使用使用 AsyncTask 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 ThreadPoolExecutor 和 FutureTask等。AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 Params、Progress 和 Result，分别用来指定参数、进度和结果的值的类型。以及四个重要的方法，分别是 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()。这四个方法中，除了 doInBackground()，其他三个都是运行在UI线程的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 doInBackground() 运行在后台线程中，用来执行耗时的任务。","text":"Android 源码分析之 AsyncTask 源码分析1、AsyncTask的使用使用 AsyncTask 可以更加简单地实现任务的异步执行，以及任务执行完毕之后与主线程的交互。它被设计用来执行耗时比较短的任务，通常是几秒种的那种，如果要执行耗时比较长的任务，那么就应该使用 JUC 包中的框架，比如 ThreadPoolExecutor 和 FutureTask等。AsyncTask 用来在后台线程中执行任务，当任务执行完毕之后将结果发送到主线程当中。它有三个重要的泛类型参数，分别是 Params、Progress 和 Result，分别用来指定参数、进度和结果的值的类型。以及四个重要的方法，分别是 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()。这四个方法中，除了 doInBackground()，其他三个都是运行在UI线程的，分别用来处理在任务开始之前、任务进度改变的时候以及任务执行完毕之后的逻辑，而 doInBackground() 运行在后台线程中，用来执行耗时的任务。 一种典型的使用方法如下： 123456789101112131415161718192021222324private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; @Override protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); if (isCancelled()) break; &#125; return totalSize; &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; setProgressPercent(progress[0]); &#125; @Override protected void onPostExecute(Long result) &#123; showDialog(\"Downloaded \" + result + \" bytes\"); &#125;&#125; 上面说 AsyncTask 有4个重要的方法，这里我们覆写了3个。doInBackground()运行在线程当中，耗时的任务可以放在这里进行；onProgressUpdate() 用来处理当任务的进度发生变化时候的逻辑；onPostExecute() 用来处理当任务执行完毕之后的逻辑。另外，这里我们还用到了 publishProgress() 和 isCancelled() 两个方法，分别用来发布任务进度和判断任务是否被取消。然后，我们可以用下面的方式来使用它： 1new DownloadFilesTask().execute(url1, url2, url3); 使用AsyncTask的时候要注意以下几点内容： AsyncTask 的类必须在主线程中进行加载，当在4.1之后这个过程会自动进行； AsyncTask 的对象必须在主线程中创建； execute()方法必须在UI线程中被调用； 不要直接调用 onPreExecute(), doInBackground(), onProgressUpdate() 和 onPostExecute()； 一个AsyncTask对象的 execute() 方法只能被调用一次； Android 1.6 之前，AsyncTask 是串行执行任务的；1.6 采用线程池处理并行任务；从 3.0 开始，又采用一个线程来串行执行任务。3.0 之后可以用 executeOnExecutor() 来并行地执行任务，如果我们希望在3.0之后能并行地执行上面的任务，那么我们应该这样去写： 1new DownloadFilesTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url1, url2, url3); 这里的 AsyncTask.THREAD_POOL_EXECUTOR 是 AsyncTask 内部定义的一个线程池，我们可以使用它来将 AsyncTask 设置成并行的。 2、AsyncTask源码分析2.1 AsyncTask 的初始化过程当初始化一个 AsyncTask 的时候，所有的重载构造方法都会调用下面的这个构造方法。这里做了几件事情： 初始化一个 Handler 对象 mHandler，该 Handler 用来将消息发送到它所在的线程中，通常使用默认的值，即主线程的 Handler； 初始化一个 WorkerRunnable 对象 mWorker。它是一个 WorkerRunnable 类型的实例，而 WorkerRunnable 又继承自 Callable，因此它是一个可以被执行的对象。我们会把在该对象中回调 doInBackground() 来将我们的业务逻辑放在线程池中执行。 初始化一个 FutureTask 对象 mFuture。该对象包装了 mWorker 并且当 mWorker 执行完毕之后会调用它的 postResultIfNotInvoked()方法来通知主线程（不论任务已经执行完毕还是被取消了，都会调用这个方法）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public AsyncTask(@Nullable Looper callbackLooper) &#123; // 1. 初始化用来发送消息的 Handler mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); // 2. 封装一个对象用来执行我们的任务 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 回调我们的业务逻辑 result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; // 发送结果给主线程 postResult(result); &#125; return result; &#125; &#125;; // 3. 初始化一个 FutureTask，并且当它执行完毕的时候，会调用 postResultIfNotInvoked 来将消息的执行结果发送到主线程中 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; // 如果任务没有被触发，也要发送一个结果 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 当这样设置完毕之后，我们就可以使用 execute() 方法来开始执行任务了。 2.2 AsyncTask 中任务的串行执行过程我们从 execute() 方法开始分析 AsyncTask: 12345678910111213141516171819@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; // 1.判断线程当前的状态 switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(...); case FINISHED: throw new IllegalStateException(...); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); // 2.回调生命周期方法 mWorker.mParams = params; // 3.赋值给可执行的对象 WorkerRunnable exec.execute(mFuture); // 4.在线程池中执行任务 return this;&#125; 当我们调用 AsyncTask 的 execute() 方法的时候会立即调用它的 executeOnExecutor() 方法。这里传入了两个参数，分别是一个 Executor 和任务的参数 params。从上面我们可以看出，当直接调用 execute() 方法的时候会使用默认的线程池 sDefaultExecutor，而当我们指定了线程池之后，会使用我们指定的线程池来执行任务。在 1 处，会对 AsyncTask 当前的状态进行判断，这就对应了前面说的，一个任务只能被执行一次。在 2 处会调用onPreExecute()方法，如果我们覆写了该方法，那么它就会在这个时候被调用。在 3 处的操作是在为 mWorker 赋值，即把调用 execute 方法时传入的参数赋值给了 mWorker。接下来，会将 mFuture 添加到线程池中执行。当我们不指定任何线程池的时候使用的 sDefaultExecutor 是一个串行的线程池，它的定义如下： 1234567891011121314151617181920212223242526272829303132public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; // 相当于对传入的Runnable进行了一层包装 r.run(); &#125; finally &#123; // 分配下一个任务 scheduleNext(); &#125; &#125; &#125;); // 如果当前没有正在执行的任务，那么就尝试从队列中取出并执行 if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; // 从队列中取任务并使用THREAD_POOL_EXECUTOR执行 if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 从上面我们可以看出，我们添加到线程池中的任务实际上并没有直接交给线程池来执行，而是对其进行了处理之后才执行的，SerialExecutor 通过内部维护了双端队列，每当一个 AsyncTask 调用 execute() 方法的时候都会被放在该队列当中进行排队。如果当前没有正在执行的任务，那么就从队列中取一个任务交给 THREAD_POOL_EXECUTOR 执行；当一个任务执行完毕之后又会调用 scheduleNext() 取下一个任务执行。也就是说，实际上 sDefaultExecutor 在这里只是起了一个任务调度的作用，任务最终还是交给 THREAD_POOL_EXECUTOR 执行的。这里的THREAD_POOL_EXECUTOR也是一个线程池，它在静态代码块中被初始化： 12345678static &#123; // 使用指定的参数创建一个线程池 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 我们也可以直接将这个静态的线程池作为我们任务执行的线程池而不是放在上面的队列中被串行地执行。 2.3 将任务执行的结果发送到其他线程上面的 WorkerRunnable 中已经用到了 postResult 方法，它用来将任务执行的结果发送给 Handler： 123456private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; mHandler 会在创建 AsyncTask 的时候初始化。我们可以通过 AsyncTask 的构造方法传入 Handler 和 Looper 来指定该对象所在的线程。当我们没有指定的时候，会使用 AsyncTask 内部的 InternalHandler 创建 Handler： 123456789101112131415161718192021222324252627282930313233private final Handler mHandler;public AsyncTask(@Nullable Looper callbackLooper) &#123; // 根据传入的参数创建Handler对象 mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper);&#125;private static Handler getMainHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; // 使用 InternalHandler 创建对象 sHandler = new InternalHandler(Looper.getMainLooper()); &#125; return sHandler; &#125;&#125;// AsyncTask 内部定义 的Handler 类型private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; // 根据传入的消息类型进行处理 switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 3、总结上面我们梳理了 AsyncTask 的大致过程，我们来梳理下：每当我们实例化一个 AsyncTask 的时候都会在内部封装成一个 Runnable 对象，该对象可以直接放在线程池中执行。这里存在两个线程池，一个是 SerialExecutor 一个是 THREAD_POOL_EXECUTOR，前者主要用来进行任务调度，即把交给线程的任务放在队列中进行排队执行，而时机上所有的任务都是在后者中执行完成的。这个两个线程池都是静态的字段，所以它们对应于整个类的。也就是说，当使用默认的线程池的时候，实例化的 AsyncTask 会一个个地，按照加入到队列中的顺序依次执行。","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangbing.cc/categories/Android/"}],"tags":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"http://zhangbing.cc/tags/AsyncTask/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-18T01:59:04.000Z","updated":"2019-02-28T07:54:22.337Z","comments":true,"path":"2018/12/18/hello-world/","link":"","permalink":"http://zhangbing.cc/2018/12/18/hello-world/","excerpt":"","text":"换硬盘博客都丢了,就从头再来吧!","categories":[],"tags":[]}]}